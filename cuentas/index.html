<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, viewport-fit=cover">
    <title>Ctas aiDANaI</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link rel="manifest" href="data:application/manifest+json,{
    %22name%22:%22Gestor de Cuentas%22,
    %22short_name%22:%22Cuentas%22,
    %22start_url%22:%22.%22,
    %22display%22:%22standalone%22,
    %22background_color%22:%22#000000%22,
    %22theme_color%22:%22#007AFF%22,
    %22description%22:%22Gestor de finanzas personales, elegante y profesional.%22,
    %22icons%22:[
        {%22src%22:%22data:image/svg+xml,%3svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='85' font-size='90'%3E%F0%9F%92%B0%3C/text%3E%3C/svg%3E%22,%22sizes%22:%22192x192%22,%22type%22:%22image/svg%2bxml%22},
        {%22src%22:%22data:image/svg+xml,%3svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='85' font-size='90'%3E%F0%9F%92%B0%3C/text%3E%3C/svg%3E%22,%22sizes%22:%22512x512%22,%22type%22:%22image/svg%2bxml%22}
    ]
}">
    <meta name="theme-color" content="#000000"/>
    <link rel="apple-touch-icon" href="aiDANaI.webp">
    <link rel="icon" href="data:image/svg+xml,%3svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='85' font-size='90'%3E%F0%9F%92%B0%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>
	<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@2.3.0"></script>
	<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
	    
    <style>
	
/* === INICIO: Estilos para el Informe de Cuenta (Cartilla) - VERSIÓN FINAL CORREGIDA === */

.informe-extracto-container {
    border: 1px solid var(--c-outline);
    border-radius: var(--border-radius-lg);
    background-color: var(--c-surface);
    overflow: hidden; 
}

/* Estilo común para la cabecera y las filas de movimiento */
.informe-linea-header,
.informe-linea-movimiento {
    display: flex;
    align-items: center;
    gap: var(--sp-2);
    padding: var(--sp-2) var(--sp-3);
    font-size: 0.8rem;
    line-height: 1.3;
}

.informe-linea-header {
    font-weight: 700;
    color: var(--c-on-surface-secondary);
    background-color: var(--c-surface-variant);
    border-bottom: 1px solid var(--c-outline);
}

.informe-linea-movimiento {
    border-bottom: 1px solid var(--c-outline);
}
.informe-linea-movimiento:last-child {
    border-bottom: none;
}

/* Definición del comportamiento de cada campo */

.informe-linea-header > *,
.informe-linea-movimiento > * {
    flex-shrink: 0;
}

/* CAMPO 1: Fecha */
.informe-linea-movimiento .fecha,
.informe-linea-header .fecha {
    width: 45px;
}

/* CAMPO 2: Descripción (el campo flexible) */
.informe-linea-movimiento .descripcion,
.informe-linea-header .descripcion {
    flex-grow: 1;
    flex-shrink: 1;
    min-width: 0;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* CAMPO 3 y 4: Importe y Saldo AHORA COMPARTEN EXACTAMENTE EL MISMO ESTILO */
.informe-linea-movimiento .importe,
.informe-linea-movimiento .saldo,
.informe-linea-header .importe,
.informe-linea-header .saldo {
    width: 90px; /* Ancho fijo para alinear bien las cifras */
    text-align: right;
    font-family: monospace, sans-serif;
    font-weight: 600;
    font-size: 0.9em; /* Mismo tamaño de fuente para ambos */
}


/* Se mantiene la regla de color solo para el importe para diferenciarlo */
.text-ingreso { color: var(--c-success); }
.text-gasto { color: var(--c-danger); }

/* === FIN: Estilos para el Informe de Cuenta (Cartilla) - VERSIÓN FINAL CORREGIDA === */

	/* Estilo para el input cuando es TRASPASO */
#movimiento-cantidad-form-group.is-traspaso #movimiento-cantidad {
    border-color: var(--c-info); /* Azul */
    color: var(--c-info);
}
#movimiento-cantidad-form-group.is-traspaso #movimiento-cantidad:focus {
     background-color: var(--c-surface);
}

/* Clases para colorear el título del modal */
#form-movimiento-title.title--gasto {
    color: var(--c-danger); /* Rojo */
}
#form-movimiento-title.title--ingreso {
    color: var(--c-success); /* Verde */
}
#form-movimiento-title.title--traspaso {
    color: var(--c-info); /* Azul */
}
/* === FIN: Estilos de Color para el Formulario === */
	/* === INICIO: Estilos para Selector Ingreso/Gasto === */
.filter-pill[data-type="gasto"].filter-pill--active {
    background-color: var(--c-danger);
    border-color: var(--c-danger);
    color: var(--c-white);
}
.filter-pill[data-type="ingreso"].filter-pill--active {
    background-color: var(--c-success);
    border-color: var(--c-success);
    color: var(--c-white);
}
/* === FIN: Estilos para Selector === */
	#diario-filter-active-indicator {
    background-color: color-mix(in srgb, var(--c-primary) 20%, transparent);
    padding: var(--sp-2) var(--sp-4);
    margin: var(--sp-4) var(--sp-4) 0 var(--sp-4);
    border-radius: var(--border-radius-md);
    text-align: center;
    border: 1px solid var(--c-primary);
	display: flex; /* Añade esto */
    justify-content: space-between; /* Añade esto */
    align-items: center; /* Añade esto */
}
#diario-filter-active-indicator p {
    margin: 0;
    font-size: var(--fs-sm);
    font-weight: 500;
	display: flex;
    gap: 8px;
}
#diario-filter-active-indicator button {
    background: none;
    border: none;
    color: var(--c-primary);
    text-decoration: underline;
    font-weight: 700;
    cursor: pointer;
}
	/* === INICIO: Estilos para Animación de Guardado === */

.save-animation-bubble {
    /* Apariencia de la burbuja */
    width: 20px;
    height: 20px;
    border-radius: 50%;
    
    /* Posicionamiento y capa */
    position: fixed; /* Fijo en la pantalla para que viaje sobre todo */
    z-index: 99999; /* La capa más alta de todas */
    
    /* Estado inicial (invisible) */
    opacity: 0;
    pointer-events: none; /* No se puede hacer clic en ella */
}

/* La animación que la hará volar y desaparecer */
@keyframes fly-to-list {
    0% {
        /* Al principio, es opaca y tiene su tamaño normal */
        opacity: 0.8;
        transform: scale(1.2);
    }
    99% {
        /* Justo antes de terminar, ya es casi invisible y pequeña */
        opacity: 0.1;
        transform: scale(0.2);
    }
    100% {
        /* Al final, es totalmente invisible y desaparece */
        opacity: 0;
        transform: scale(0);
    }
}
/* === FIN: Estilos para Animación de Guardado === */
	/* === INICIO: ESTILOS A PEGAR PARA LA INTRO CON VÍDEO Y SONIDO === */
#start-overlay {
    position: fixed;
    inset: 0;
    z-index: 10001; /* El más alto de todos para que tape todo */
    background-color: #000;
    display: flex;
    justify-content: center;
    align-items: center;
}
#start-button {
    background: none;
    border: 2px solid white;
    color: white;
    padding: 15px 30px;
    font-size: 1.2rem;
    font-weight: 700;
    cursor: pointer;
    border-radius: 50px;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: all 0.2s ease-in-out;
}
#start-button:hover {
    background-color: white;
    color: black;
}
#video-intro-overlay {
    position: fixed;
    inset: 0;
    z-index: 10000;
    background-color: #000;
    transition: opacity 0.75s ease-in-out;
}
#intro-video {
    width: 100%;
    height: 100%;
    object-fit: contain; 
}
/* === FIN: ESTILOS A PEGAR === */
	 .form-input--error {
    border: 2px solid red;
    background: #ffecec;
  }
	/* === INICIO: Estilos para el Asistente aiDANaI === */
.aidanai-modal-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    padding: var(--sp-2);
}
.aidanai-modal-content img {
    width: 80px;
    height: 80px;
    border-radius: 24px;
    margin-bottom: var(--sp-3);
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
}
.aidanai-modal-content h4 {
    color: var(--c-primary);
    font-weight: 700;
    margin-bottom: var(--sp-2);
    font-size: var(--fs-lg);
}
.aidanai-modal-content p {
    color: var(--c-on-surface-secondary);
    line-height: 1.6;
    font-size: var(--fs-sm);
}
.aidanai-modal-content p strong {
    color: var(--c-on-surface);
    font-weight: 600;
}
/* === FIN: Estilos para el Asistente aiDANaI === */
	
	#pending-recurrents-container .accordion__content {
    display: flex;
    flex-direction: column; 
    gap: 12px;              
}	
    .acciones-recurrentes-corregidas {
        display: flex;
        flex-wrap: wrap; 
        gap: 8px; 
        justify-content: flex-end; 
        margin-top: 4px; 
    }
	
	/* === INICIO: Estilos para la nueva Guía de Ayuda === */
#help-modal-body h3 { 
    margin-top: 1.5em; 
    margin-bottom: 0.8em; 
    color: var(--c-primary); 
    font-weight: 700; 
    display: flex; 
    align-items: center; 
    gap: 8px; 
    border-bottom: 1px solid var(--c-outline); 
    padding-bottom: 8px;
}
#help-modal-body h4 {
    color: var(--c-on-surface);
    margin-top: 1.2em;
    margin-bottom: 0.5em;
}
#help-modal-body .accordion > summary {
    font-size: 1.1em;
    font-weight: 600;
    color: var(--c-on-surface);
}
#help-modal-body .accordion .accordion__content {
    padding: 8px 16px 16px 16px;
}
#help-modal-body p, #help-modal-body li {
    color: var(--c-on-surface-secondary);
    line-height: 1.6;
}
#help-modal-body ul {
    list-style-type: disc;
    padding-left: 20px;
}
#help-modal-body li {
    margin-bottom: 8px;
}
#help-modal-body code {
    display: block;
    background-color: var(--c-surface-variant);
    padding: 12px;
    border-radius: var(--border-radius-md);
    font-family: monospace;
    font-size: 0.9em;
    margin: 1em 0;
    border: 1px solid var(--c-outline);
}
/* === FIN: Estilos para la nueva Guía de Ayuda === */
	
/* === INICIO: NUEVOS ESTILOS PARA CALENDARIOS === */
.calendar-container { padding: 0 var(--sp-4); }
.calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--sp-3); }
.calendar-header__title { font-size: var(--fs-lg); font-weight: 700; }
.calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 4px; }
.calendar-weekday { text-align: center; font-size: var(--fs-xs); font-weight: 600; color: var(--c-on-surface-tertiary); margin-bottom: var(--sp-2); }
.calendar-day { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; background-color: var(--c-surface); border: 1px solid var(--c-outline); border-radius: var(--border-radius-md); aspect-ratio: 1 / 1; min-height: 50px; cursor: pointer; transition: background-color 0.2s, transform 0.2s, border-color 0.2s; position: relative; }
.calendar-day:hover { background-color: var(--c-surface-variant); border-color: var(--c-primary); transform: scale(1.05); }
.calendar-day.empty { background-color: transparent; border: none; cursor: default; }
.calendar-day__number { font-size: var(--fs-xs); font-weight: 600; padding-top: var(--sp-1); }
.calendar-day.is-today .calendar-day__number { color: var(--c-white); background-color: var(--c-primary); border-radius: 50%; width: 1.5em; height: 1.5em; display: inline-flex; justify-content: center; align-items: center; }
.calendar-day__total { font-size: 0.65rem; font-weight: 700; text-align: center; margin-top: auto; padding: 2px 4px; border-radius: 4px; width: 90%; margin-bottom: 2px; }
.calendar-day__markers { display: flex; gap: 3px; position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%); }
.calendar-day__marker { width: 5px; height: 5px; border-radius: 50%; }
.marker--income { background-color: var(--c-success); }
.marker--expense { background-color: var(--c-danger); }
/* === FIN: NUEVOS ESTILOS PARA CALENDARIOS === */	

.transaction-card__recurrent-actions {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap; /* Esta línea es la clave para que no se amontonen si no caben */
}

	/* Pega este código CSS justo después de <style> */
.widget-config-item { display: flex; align-items: center; gap: var(--sp-3); padding: var(--sp-2); background-color: var(--c-surface-variant); border-radius: var(--border-radius-md); margin-bottom: var(--sp-2); border: 1px solid var(--c-outline); }
.widget-config-item.dragging { opacity: 0.5; background-color: var(--c-primary); }
.widget-config-item__details { flex-grow: 1; }
.widget-config-item__title { font-weight: 700; color: var(--c-on-surface); }
.widget-config-item__desc { font-size: var(--fs-xs); color: var(--c-on-surface-secondary); }
.drag-handle { cursor: grab; color: var(--c-on-surface-tertiary); }
.drag-handle:active { cursor: grabbing; }

/* ================================================================== */
/* === TEMA PRINCIPAL: "CIBER-NEÓN" (OSCURO AMOLED Y ELÉCTRICO)  === */
/* ================================================================== */
:root {
    /* PALETA "CIBER-NEÓN": Cian eléctrico sobre negro puro. */
    --c-primary: #00B34D;       /* Verde Esmeralda Profundo */
	--c-primary-hover: #00CC55; /* Versión más brillante para hover */
    --c-danger: #FF3B30;        /* Rojo Neón */
    --c-success: #39FF14;       /* Verde Lima Neón */
    --c-warning: #FFD60A;       /* Amarillo Neón */
    --c-info: #BF5AF2;          /* Púrpura Neón */

    /* FONDO: Negro puro para AMOLED. */
    --c-background: #000000;
    
    /* SUPERFICIES: "Cristal Holográfico" oscuro. */
    --c-surface: rgba(10, 25, 40, 0.70); /* Tinte azulado oscuro translúcido */
    --c-surface-variant: rgba(20, 35, 50, 0.70);

    /* BORDES Y RESPLANDOR: El corazón del efecto neón. */
    --c-outline: rgba(0, 255, 255, 0.35);
    --c-border-glow: 0 0 12px rgba(0, 255, 255, 0.4); /* Resplandor para inputs */

    /* TEXTOS: Optimizados para brillar. */
    --c-on-surface: #F0F8FF; /* Blanco Alice Blue (muy claro, casi blanco) */
    --c-on-surface-secondary: rgba(240, 248, 255, 0.75); /* WCAG CORRECCIÓN: Aumentada opacidad de 0.65 a 0.75 por seguridad */
    --c-on-surface-tertiary: rgba(240, 248, 255, 0.60); /* WCAG CORRECCIÓN: Aumentada opacidad de 0.45 a 0.60 para pasar el test de contraste */
    --c-on-surface-disabled: #444444;
    
    --c-white: #FFFFFF;
    --c-black: #000000;
    
    --c-chart-positive: var(--c-success);
    --c-chart-negative: var(--c-danger);

    /* SOMBRAS: Resplandor de neón pronunciado ("Bloom Effect"). */
    --shadow-sm: 0 0 8px rgba(0, 255, 255, 0.25);
    --shadow-md: 0 0 20px rgba(0, 255, 255, 0.45);
    --glow-red: 0 0 20px rgba(255, 59, 48, 0.55);

    /* Tipografía y espaciado base (NO SE TOCAN) */
    --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    --fs-xs: 0.75rem; --fs-sm: 0.875rem; --fs-base: 1rem; --fs-lg: 1.125rem; --fs-xl: 1.25rem;
    --sp-1: 0.25rem; --sp-2: 0.5rem; --sp-3: 0.75rem; --sp-4: 1rem; --sp-5: 1.25rem; --sp-6: 1.5rem;
    --border-radius-md: 10px; --border-radius-lg: 16px;
}

/* ====================================================================== */
/* === TEMA SECUNDARIO: "CRISTAL PRISMÁTICO" (COLORIDO Y VIBRANTE)    === */
/* ====================================================================== */

body[data-theme="prismatic-glass"] {
    /* PALETA "PRISMÁTICA": Colores saturados y de alto contraste. */
    --c-primary: #0060C0;       /* WCAG CORRECCIÓN: Azul oscurecido para mejorar contraste (antes #007AFF) */
    --c-primary-hover: #007AFF;
    --c-danger: #FF3B30;        /* Rojo Vibrante */
    --c-success: #34C759;       /* Verde Vibrante */
    --c-warning: #FF9500;       /* Naranja Vibrante */
    --c-info: #5856D6;          /* Índigo Vibrante */

    /* FONDO: Gradiente abstracto y colorido. */
    --c-background: #E5E5EA; /* Un gris muy claro como base */
    
    /* SUPERFICIES: El efecto de cristal es la estrella. */
    --c-surface: rgba(252, 252, 252, 0.75); /* WCAG CORRECCIÓN: Aumentada opacidad para mejorar legibilidad */
    --c-surface-variant: rgba(255, 255, 255, 0.5);
    --c-outline: rgba(60, 60, 67, 0.2); /* WCAG CORRECCIÓN: Borde más oscuro para mejor definición */

    /* TEXTOS: Oscuros para un contraste perfecto sobre el fondo claro y borroso. */
    --c-on-surface: #1C1C1E; /* Negro suave */
    --c-on-surface-secondary: #3C3C4399;
    --c-on-surface-tertiary: #3C3C4380; /* WCAG CORRECCIÓN: Aumentada opacidad de 66 a 80 para mejorar contraste */
    
    /* SOMBRAS: Suaves y difusas para realzar el efecto de flotación. */
    --shadow-sm: 0 4px 15px rgba(0, 0, 0, 0.06);
    --shadow-md: 0 8px 30px rgba(0, 0, 0, 0.12);
}


/* ================================================================= */
/* === ESTILOS GLOBALES DEL ENCABEZADO (INVARIABLE A LOS TEMAS)   === */
/* ================================================================= */

/* 1. Estilo base del encabezado (oscuro, para que contraste en ambos temas) */
.top-bar {
    background-color: rgba(10, 10, 15, 0.7); /* Un fondo oscuro translúcido */
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--c-outline); /* Usa el borde del tema activo */
}

/* 2. Anulación específica para Contabilidad A (el encabezado se vuelve azul corporativo) */
body[data-ledger-mode="A"] .top-bar {
    background-color: #002D5B; /* Azul oscuro y profesional */
}

/* 3. Anulación específica para Contabilidad B (el encabezado se vuelve rojo oscuro) */
body[data-ledger-mode="B"] .top-bar {
    background-color: #5B0000; /* Rojo oscuro, serio */
}

/* 4. Asegura que el texto y botones dentro del encabezado SIEMPRE sean blancos y legibles */
.top-bar, 
.top-bar .btn, 
.top-bar .icon-btn, 
#page-title-display {
    color: var(--c-white) !important; /* !important es clave para anular los temas */
}

/* ================================================================= */
/* === ESTILOS DE CONTABILIDAD DUAL (BOTÓN Y NAV INFERIOR)        === */
/* ================================================================= */

/* Contabilidad A (Botón Azul) */
body[data-ledger-mode="A"] #ledger-toggle-btn {
    background-color: var(--c-primary);
    border-color: var(--c-primary);
    color: var(--c-white);
    box-shadow: 0 0 10px rgba(0, 122, 255, 0.5);
}
body[data-ledger-mode="A"] #ledger-toggle-btn:hover {
    background-color: var(--c-primary-hover);
    border-color: var(--c-primary-hover);
}
body[data-ledger-mode="A"] .bottom-nav__item--active {
    color: var(--c-primary); /* El icono activo usa el color primario del tema */
}

/* Contabilidad B (Botón Rojo) */
body[data-ledger-mode="B"] #ledger-toggle-btn {
    background-color: var(--c-danger);
    border-color: var(--c-danger);
    color: var(--c-white);
    box-shadow: var(--glow-red);
}
body[data-ledger-mode="B"] #ledger-toggle-btn:hover {
    background-color: color-mix(in srgb, var(--c-danger) 85%, black);
    border-color: color-mix(in srgb, var(--c-danger) 85%, black);
}
body[data-ledger-mode="B"] .bottom-nav__item--active {
    color: var(--c-danger) !important; /* El icono activo siempre será rojo en Cont. B */
}
/* ================================================================= */
/* === ESTILOS BASE Y ESTRUCTURALES (COMUNES A AMBOS TEMAS)       === */
/* ================================================================= */
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html { height: -webkit-fill-available; scroll-behavior: smooth; }
body { font-family: var(--font-family); background-color: var(--c-background); color: var(--c-on-surface); line-height: 1.4; min-height: 100vh; min-height: -webkit-fill-available; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow: hidden; font-weight: 500; }
*:focus-visible { outline: 2px solid var(--c-primary); outline-offset: 2px; border-radius: var(--sp-2); }
@keyframes fade-out-and-collapse {
    from {
        opacity: 1;
        transform: scaleY(1);
        max-height: 76px; /* Altura máxima de un item */
        padding-top: var(--sp-2);
        padding-bottom: var(--sp-2);
    }
    to {
        opacity: 0;
        transform: scaleY(0.8);
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        margin: 0;
        border: 0;
    }
}

.item-deleting {
    animation: fade-out-and-collapse 0.4s ease-out forwards;
    overflow: hidden;
}
@keyframes item-enter {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Esta es la clase que prepara el elemento para animar, pero lo mantiene invisible */
.list-item-animate {
    opacity: 0;
}

/* Esta es la clase que dispara la animación */
.list-item-animate.item-enter-active {
    animation: item-enter 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}
@keyframes pop-in { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
@keyframes slide-in-from-right {
    from { transform: translateX(100%); opacity: 0.8; }
    to { transform: translateX(0); opacity: 1; }
}
@keyframes slide-out-to-left {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(-100%); opacity: 0.8; }
}
@keyframes slide-in-from-left {
    from { transform: translateX(-100%); opacity: 0.8; }
    to { transform: translateX(0); opacity: 1; }
}
@keyframes slide-out-to-right {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0.8; }
}

.view-transition-in-forward {
    animation: slide-in-from-right 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}
.view-transition-out-forward {
    animation: slide-out-to-left 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}
.view-transition-in-backward {
    animation: slide-in-from-left 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}
.view-transition-out-backward {
    animation: slide-out-to-right 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
}
@keyframes view-fade-in { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
@keyframes view-fade-out { from { opacity: 1; } to { opacity: 0; } }
.view-entering { animation: view-fade-in 0.3s ease-out forwards; }
.view-exiting { animation: view-fade-out 0.2s ease-in forwards; }
@keyframes highlight-card { 0% { background-color: color-mix(in srgb, var(--c-primary) 15%, transparent); } 100% { background-color: transparent; } }
.highlight-animation { animation: highlight-card 2s ease-out; }
@keyframes highlight-field-success {
    0% {
        background-color: color-mix(in srgb, var(--c-success) 20%, transparent);
    }
    100% {
        background-color: transparent;
    }
}

.field-highlighted {
    animation: highlight-field-success 1s ease-out;
}

@keyframes highlight-field-success { 0% { background-color: color-mix(in srgb, var(--c-success) 20%, transparent); } 100% { background-color: transparent; } }
.field-highlighted { animation: highlight-field-success 1s ease-out; }
@keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
.skeleton { background-color: var(--c-surface-variant); background-image: linear-gradient(90deg, var(--c-surface-variant), color-mix(in srgb, var(--c-outline) 20%, var(--c-surface-variant)), var(--c-surface-variant)); background-size: 200% 100%; animation: shimmer 1.5s infinite linear; border-radius: var(--sp-2); color: transparent !important; user-select: none; }
.skeleton > * { visibility: hidden; }
.skeleton-card {
    display: flex;
    align-items: center;
    padding: var(--sp-2) 0;
    min-height: 64px;
    margin: 0 var(--sp-4);
}
.skeleton-card__indicator {
    width: 3px;
    height: 48px;
    margin-right: var(--sp-2);
}
.skeleton-card__content {
    flex-grow: 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.skeleton-card__line {
    height: 12px;
    border-radius: 4px;
}
.skeleton-card__line--sm { width: 60%; }
.skeleton-card__line--xs { width: 40%; margin-top: 8px; }
.skeleton-card__amount {
    width: 80px;
    height: 16px;
    border-radius: 4px;
}
/* === INICIO: Estilos para Widgets en Carga === */
.widget-container {
    position: relative; /* Necesario para posicionar el spinner dentro */
}

.widget--loading::after {
    content: '';
    position: absolute;
    inset: 0; /* Cubre todo el widget */
    background-color: var(--c-surface);
    opacity: 0.7;
    border-radius: var(--border-radius-lg);
    z-index: 10;
    transition: opacity 0.2s ease-in-out;
}

.widget-spinner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 11; /* Por encima de la capa de opacidad */
}
/* === FIN: Estilos para Widgets en Carga === */

/* --- Pantalla de Introducción --- */
.intro-screen { position: fixed; inset: 0; z-index: 9999; display: flex; justify-content: center; align-items: center; background-color: #000000; transition: opacity 0.75s ease-in-out; }
.starry-background { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: radial-gradient(1px 1px at 10% 20%,#fff,transparent),radial-gradient(1px 1px at 80% 30%,#fff,transparent),radial-gradient(2px 2px at 50% 50%,#fff,transparent),radial-gradient(1px 1px at 30% 80%,#fff,transparent),radial-gradient(2px 2px at 90% 90%,#fff,transparent); background-size: 300px 300px; animation: twinkle 15s linear infinite; }
@keyframes twinkle { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
.intro-screen__logo { width: 250px; height: auto; border-radius: 24px; opacity: 0; position: absolute; animation: logoExplode 2.5s cubic-bezier(0.5, 0, 0.5, 1) forwards; }
@keyframes logoExplode { 0% { transform: scale(0.2) rotate(-25deg); opacity: 0; } 30% { transform: scale(1.1) rotate(10deg); opacity: 1; } 50% { transform: scale(0.95) rotate(-8deg); opacity: 1; } 80% { transform: scale(1.5) rotate(5deg); opacity: 1; } 100% { transform: scale(12) rotate(20deg); opacity: 0; } }
.intro-screen__quote-container { text-align: center; color: var(--c-white); padding: var(--sp-5); max-width: 800px; z-index: 1; opacity: 0; transition: opacity 1.5s ease-in-out; }
.intro-screen__quote-container.visible { opacity: 1; }
.intro-screen__quote-text { font-size: clamp(1.2rem, 4vw, 1.8rem); font-style: italic; font-weight: 400; line-height: 1.4; margin-bottom: 16px; text-shadow: 0 0 15px rgba(255, 255, 255, 0.5); }
.intro-screen__quote-author { display: block; font-size: clamp(0.8rem, 2.4vw, 1rem); color: var(--c-on-surface-secondary); font-weight: 500; }

/* --- Estructura de la App --- */
.app-layout { display: none; max-width: 500px; margin: 0 auto; height: 100vh; background-color: var(--c-background); flex-direction: column; opacity: 0; transition: opacity 0.5s ease-out, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), border-radius 0.4s; }
.app-layout--visible { display: flex; opacity: 1; }
.app-layout__main { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; padding: 44px 0 48px 0; }
.view { display: none; flex-direction: column; width: 100%; padding: 0 var(--sp-4); gap: var(--sp-4); }
.view--active { display: flex; }

/* --- Navegación Superior (Top Bar) --- */
.top-bar { display: flex; align-items: center; justify-content: space-between; padding: var(--sp-2) var(--sp-4); background-color: rgba(0,0,0,0.7); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-bottom: 1px solid var(--c-outline); z-index: 200; height: 44px; position: fixed; top: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 500px; transition: background-color 0.3s ease-in-out; }
.top-bar__title { font-size: var(--fs-lg); font-weight: 800; padding-left: var(--sp-2); text-align: center; }
#page-title-display { font-size: var(--fs-base); font-weight: 700; margin-left: var(--sp-3); color: inherit; white-space: nowrap; }
.top-bar__actions { display: flex; align-items: center; gap: var(--sp-1); }
.top-bar__left-button { min-width: 85px; display: flex; align-items: center; }
.top-bar__left-group { display: flex; align-items: center; gap: var(--sp-3); }
 .top-bar .top-bar__actions .icon-btn[data-action="toggle-theme"] .material-icons { 
    background-image: linear-gradient(45deg, var(--c-info), #F43F5E); 
    text-shadow: 0 0 8px color-mix(in srgb, var(--c-info) 50%, transparent); 
}

/* --- Navegación Inferior (Bottom Nav) --- */
.bottom-nav { 
    position: fixed; 
    bottom: 0; 
    left: 50%; 
    transform: translateX(-50%); 
    width: 100%; 
    max-width: 500px; 
    background-color: var(--c-surface); 
    border-top: 1px solid var(--c-outline); 
    display: flex; 
    padding-bottom: env(safe-area-inset-bottom); 
    z-index: 200; 
    box-shadow: 0 -2px 15px rgba(0,0,0,0.2); 
    height: 48px; 
}
.bottom-nav__item { 
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    padding: var(--sp-1) var(--sp-2); 
    cursor: pointer; 
    transition: color 0.2s; 
    /* CAMBIO CLAVE: Usamos una variable semántica que se adapta al tema en lugar de un color fijo. */
    color: var(--c-on-surface-secondary); 
    border: none; 
    background: none; 
}
.bottom-nav__item--active { 
    /* Esta regla ya es correcta, el color primario cambia con el tema. */
    color: var(--c-primary); 
}
.bottom-nav__item .material-icons { 
    font-size: 22px; 
} 
.bottom-nav__label { 
    display: none; 
    font-size: var(--fs-xs); 
    margin-top: 2px; 
}

/* --- Botón Flotante (FAB) --- */
.fab-container {
    position: fixed;
    bottom: calc(64px + env(safe-area-inset-bottom)); /* 48px de la barra + 16px de margen */
    right: 16px;  /* Más pegado al borde */
    z-index: 1040;
    display: flex;
    flex-direction: column; /* Apila los elementos hacia arriba */
    align-items: center;
    gap: 16px; /* Espacio entre los botones cuando se expanden */
}

/* Estilo del botón principal (+) */
#fab-main {
    width: 48px;  /* Un poco más pequeño y discreto */
    height: 48px;
    background-color: var(--c-primary);
    color: var(--c-white);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: var(--shadow-md);
    
    /* LA MAGIA: Transparencia al 50% */
    opacity: 0.7; 
    
    transition: all 0.25s ease-in-out;
    position: relative; /* Necesario para que esté por encima de los otros al cerrarse */
}

#fab-main .material-icons {
    font-size: 24px;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Efectos al interactuar con el botón principal */
#fab-main:hover {
    opacity: 1; /* Se vuelve opaco */
    transform: scale(1.1);
}

/* Estilos de los botones pequeños (Gasto, Ingreso, Traspaso) */
.fab-action-item {
    display: flex;
    align-items: center;
    gap: 12px;
    
    /* Estado inicial: ocultos y ligeramente desplazados hacia abajo */
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    pointer-events: none; /* No se puede hacer clic cuando están ocultos */
}
.fab-action-btn {
    width: 40px; /* Aún más pequeños para un look más limpio */
    height: 40px;
    border-radius: 50%;
    border: none;
    color: var(--c-white);
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: var(--shadow-sm);
}
.fab-action-label {
    background-color: var(--c-surface);
    color: var(--c-on-surface);
    padding: 4px 10px;
    border-radius: var(--border-radius-md);
    font-size: var(--fs-xs);
    font-weight: 600;
    box-shadow: var(--shadow-sm);
    white-space: nowrap;
}

/* --- Lógica de Apertura y Cierre --- */
.fab-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    opacity: 0;
    z-index: -1;
    transition: opacity 0.3s ease-out;
    pointer-events: none;
}

/* ESTADO ACTIVO: Cuando el menú está desplegado */
.fab-container--active #fab-main {
    opacity: 1; /* El botón principal se vuelve opaco */
}
.fab-container--active #fab-main .material-icons {
    transform: rotate(45deg); /* Gira el '+' para convertirlo en 'x' */
}
.fab-container--active .fab-overlay {
    opacity: 1;
    pointer-events: auto;
}
.fab-container--active .fab-action-item {
    opacity: 1;
    transform: translateY(0); /* Vuelven a su posición original */
    pointer-events: auto;
}

/* Pequeño retraso para que aparezcan en cascada hacia arriba */
.fab-container--active .fab-action-item:nth-child(3) { transition-delay: 0.05s; }
.fab-container--active .fab-action-item:nth-child(2) { transition-delay: 0.1s; }
.fab-container--active .fab-action-item:nth-child(1) { transition-delay: 0.15s; }

/* Colores de los botones pequeños */
.fab-action-btn.btn--danger { background-color: var(--c-danger); }
.fab-action-btn.btn--success { background-color: var(--c-success); }
.fab-action-btn.btn--info { background-color: var(--c-info); }

/* --- Modales --- */
.modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(12px); display: flex; align-items: flex-end; justify-content: center; z-index: 1050; opacity: 0; transition: opacity 0.3s ease-out; pointer-events: none; }
.app-layout.app-layout--transformed-by-modal { transform: scale(0.96) translateY(-8px); border-radius: var(--border-radius-lg); overflow: hidden; box-shadow: 0 0 30px rgba(0,0,0,0.5); }
.modal-overlay--active { opacity: 1; pointer-events: auto; }
.modal { background: var(--c-surface); border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0; padding: var(--sp-5); width: 100%; max-width: 420px; max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 0 30px rgba(0,0,0,0.5); transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
.modal-overlay--active .modal { transform: translateY(0); }
.modal__header { display: flex; align-items: center; justify-content: space-between; margin-bottom: var(--sp-3); flex-shrink: 0;}
.modal__title { font-size: var(--fs-xl); font-weight: 800; }
.modal__body { overflow-y: auto; flex-grow: 1; -webkit-overflow-scrolling: touch; padding-right: var(--sp-2); margin-right: calc(-1 * var(--sp-2)); }
.modal__list-item { display:flex; justify-content:space-between; align-items:center; padding: var(--sp-3) 0; border-bottom:1px solid var(--c-outline); gap: var(--sp-2); }
.modal__list-item:last-child { border-bottom: none; }
.modal__actions { margin-top: var(--sp-4); display: flex; justify-content: flex-end; gap: var(--sp-2); width: 100%;}
.modal__grabber { width: 40px; height: 5px; background-color: var(--c-outline); border-radius: 99px; position: absolute; top: 8px; left: 50%; transform: translateX(-50%); }

/* --- Componentes UI --- */
.card__title { font-size: var(--fs-lg); font-weight: 700; margin-bottom: var(--sp-3); display: flex; align-items: center; gap: var(--sp-2); padding: var(--sp-4) var(--sp-4) 0 var(--sp-4); }
.card__content { padding: 0 var(--sp-4) var(--sp-4) var(--sp-4); }
.card__title .material-icons { font-size: var(--fs-lg); }
.card--no-bg { background: none; border: none; box-shadow: none; padding: 0; border-radius: 0; }
.chart-container { position: relative; height: 220px; width: 100%; margin-bottom: var(--sp-4); }
.kpi-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: var(--sp-3); }
.kpi-item { border-radius: var(--border-radius-lg); padding: var(--sp-3); text-align: center; transition: background-color 0.3s, transform 0.2s; }
.kpi-item__label { font-size: var(--fs-xs); font-weight: 600; color: var(--c-on-surface-secondary); margin-bottom: var(--sp-1); text-transform: uppercase; }
.kpi-item__value { font-size: var(--fs-base); font-weight: 800; }
.kpi-item__comparison { font-size: var(--fs-xs); font-weight: 500; margin-top: var(--sp-1); height: 14px; }
/* --- AÑADE ESTE BLOQUE A TU CSS --- */
.kpi-item[data-action] {
    /* Reseteamos la apariencia de botón */
    border: none;
    background: none;
    padding: 0;
    text-align: inherit;
    font-family: inherit;
    
    /* Añadimos la interactividad visual */
    cursor: pointer;
    transition: transform 0.2s, background-color 0.2s;
}

.kpi-item[data-action]:hover {
    background-color: var(--c-surface-variant);
}

.kpi-item[data-action]:active {
    transform: scale(0.97);
}
/* Lista de Movimientos Virtualizada */
#movimientos-list-container { position: relative; padding: 0 var(--sp-4); }
#virtual-list-sizer { position: relative; width: 100%; }
#virtual-list-content { position: absolute; top: 0; left: 0; width: 100%; }

/* Tarjeta de Transacción */
.transaction-card { display: flex; align-items: flex-start; padding: var(--sp-2) 0; cursor: pointer; border-bottom: 1px solid var(--c-outline); line-height: 1.25; min-height: 64px; transition: background-color 0.2s; user-select: none; }
.transaction-card:hover { background-color: var(--c-surface-variant); }
.transaction-card:last-child { border-bottom: none; }
.transaction-card__indicator { flex-shrink: 0; width: 3px; align-self: stretch; border-radius: 99px; margin-right: var(--sp-2); }
.transaction-card__indicator--income { background-color: var(--c-success); }
.transaction-card__indicator--expense { background-color: var(--c-danger); }
.transaction-card__indicator--transfer { background-color: var(--c-info); }
.transaction-card__indicator--recurrent { background-color: var(--c-warning); }
.transaction-card__content { flex-grow: 1; display: flex; justify-content: space-between; align-items: center; min-width: 0; }
.transaction-card__details { flex-grow: 1; min-width: 0; padding-right: var(--sp-2); }
.transaction-card__row-1, .transaction-card__concept { font-size: var(--fs-sm); font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.transaction-card__row-2, .transaction-card__description { font-size: var(--fs-xs); color: var(--c-on-surface-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.transaction-card__figures {
    flex-shrink: 1; 
    text-align: right;
    min-width: 120px; 
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 8px; /* Espacio entre el importe y el contenedor de botones */
}
.transaction-card__amount { font-size: var(--fs-sm); font-weight: 700; display: block; }
.transaction-card__balance { font-size: 0.7rem; color: var(--c-on-surface-secondary); display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100px; }
.transaction-card__transfer-details { display: flex; flex-direction: column; gap: 0; margin: 2px 0 0 0; }
.transaction-card__transfer-row { display: flex; justify-content: space-between; align-items: center; color: var(--c-on-surface-secondary); font-size: 0.75rem; }
.transaction-card__transfer-row .material-icons { font-size: 11px; vertical-align: middle; margin-right: var(--sp-1); }
.transaction-card__transfer-row > span:first-child { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

/* Acciones de Swipe */
.swipe-container { position: relative; overflow: hidden; }
.swipe-container .transaction-card { position: relative; z-index: 2; background-color: var(--c-background); transition: transform 0.3s ease-out; }
.swipe-actions-container { position: absolute; top: 0; bottom: 0; display: flex; align-items: center; z-index: 1; }
.swipe-actions-container.left { left: 0; }
.swipe-actions-container.right { right: 0; }
.swipe-action-btn { width: 75px; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; color: var(--c-white); border: none; cursor: pointer; font-size: var(--fs-xs); font-weight: 600; gap: 4px; }
.swipe-action-btn .material-icons {
    font-size: 20px;
    transform: scale(0.5); /* Empieza a la mitad de su tamaño */
    opacity: 0;            /* Empieza totalmente transparente */
    transition: transform 0.2s ease-out, opacity 0.2s ease-out; /* Transición suave */
}
.swipe-actions-container--visible .swipe-action-btn .material-icons {
    transform: scale(1); /* Vuelve a su tamaño normal */
    opacity: 1;            /* Se vuelve totalmente opaco */
}
.swipe-action-btn.duplicate { background-color: #FF9500; } /* Naranja Neón */
.swipe-action-btn.delete { background-color: var(--c-danger); }

/* Acordeón */
.accordion { margin-bottom: 0; background-color: var(--c-surface); overflow: hidden; }
.accordion-wrapper > .accordion:first-child { border-top-left-radius: var(--border-radius-lg); border-top-right-radius: var(--border-radius-lg); }
.accordion-wrapper > .accordion:last-child { border-bottom-left-radius: var(--border-radius-lg); border-bottom-right-radius: var(--border-radius-lg); }
.accordion-wrapper > .accordion:not(:last-child) { border-bottom: 1px solid var(--c-outline); border-radius: 0; }
.accordion[open] > summary { border-bottom: 1px solid var(--c-outline); }
.accordion > summary { font-weight: 700; cursor: pointer; padding: var(--sp-3) var(--sp-4); display: flex; align-items: center; justify-content: space-between; list-style: none; font-size: var(--fs-base); }
.accordion > summary::-webkit-details-marker { display: none; }
.accordion > summary .accordion__icon { transition: transform 0.2s; color: var(--c-on-surface-secondary); }
.accordion[open] > summary .accordion__icon { transform: rotate(180deg); }
.accordion__content { padding: 0 var(--sp-4) var(--sp-4) var(--sp-4); }

/* --- Formularios --- */
.form-group { margin-bottom: var(--sp-3); position: relative; }
.form-label { display: block; font-size: var(--fs-sm); font-weight: 600; margin-bottom: var(--sp-2); color: var(--c-on-surface-secondary); }
.form-input, .form-select { width: 100%; padding: var(--sp-3); border: 1px solid var(--c-outline); border-radius: var(--border-radius-md); background: var(--c-surface-variant); color: var(--c-on-surface); font-size: var(--fs-base); appearance: none; transition: border-color 0.2s, box-shadow 0.2s, background-color 0.2s; }
.form-input:focus, .form-select:focus { outline: none; border-color: var(--c-primary); background-color: var(--c-surface); box-shadow: var(--c-border-glow); }
.form-select { background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23FFFFFF' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3csvg%3e"); background-repeat: no-repeat; background-position: right 12px center; background-size: 14px; padding-right: 36px; }
.form-grid { display: grid; grid-template-columns: 1fr; gap: var(--sp-3); }
.form-group-addon { display: flex; align-items: center; gap: var(--sp-2); }
.form-group-addon .form-group { flex-grow: 1; margin-bottom: 0; }
.form-error { color: var(--c-danger); font-size: var(--fs-xs); margin-top: var(--sp-1); min-height: 14px; display: block; font-weight: 600; }
.form-input--invalid { border-color: var(--c-danger) !important; box-shadow: var(--glow-red) !important; }
.form-checkbox-group { display: flex; align-items: center; gap: var(--sp-2); margin-bottom: var(--sp-2); }
.form-switch-group { display: flex; align-items: center; justify-content: space-between; }
.form-switch { position: relative; display: inline-block; width: 44px; height: 26px; }
.form-switch input { opacity: 0; width: 0; height: 0; }
.form-switch .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--c-surface-variant); transition: .4s; border-radius: 34px; border: 1px solid var(--c-outline); }
.form-switch .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
.form-switch input:checked + .slider { background-color: var(--c-success); border-color: var(--c-success); }
.form-switch input:checked + .slider:before { transform: translateX(18px); }
/* === INICIO: Estilos para el Campo de Importe Reactivo === */

/* El campo de texto ahora crece para ocupar el espacio disponible */
#movimiento-cantidad {
    flex-grow: 1; /* Ocupa todo el espacio que sobra en el 'form-group-addon' */
    text-align: right; /* Alineamos el texto a la derecha */
    font-size: 1.2rem; /* Hacemos el número aún más grande y protagonista */
    font-weight: 700;
    line-height: 1.2; /* Ajuste para que encaje bien verticalmente */
}

/* --- Estilos visuales para el campo de cantidad --- */

/* Contenedor padre del campo de cantidad */
#movimiento-cantidad-form-group {
    transition: all 0.2s ease-in-out;
}

/* Estilo del input cuando es INGRESO */
#movimiento-cantidad-form-group.is-ingreso #movimiento-cantidad {
    border-color: var(--c-success);
    color: var(--c-success);
}

/* Estilo del input cuando es GASTO */
#movimiento-cantidad-form-group.is-gasto #movimiento-cantidad {
    border-color: var(--c-danger);
    color: var(--c-danger);
}

/* Quitamos el fondo de color del input para un look más limpio */
#movimiento-cantidad-form-group.is-ingreso #movimiento-cantidad:focus,
#movimiento-cantidad-form-group.is-gasto #movimiento-cantidad:focus {
     background-color: var(--c-surface-variant);
}

#movimiento-cantidad-form-group.is-ingreso #movimiento-cantidad:focus,
#movimiento-cantidad-form-group.is-gasto #movimiento-cantidad:focus {
     background-color: var(--c-surface);
}

/* === FIN: Estilos para el Campo de Importe Reactivo === */
/* --- Botones --- */
.btn { padding: var(--sp-3) var(--sp-4); border: 1px solid transparent; border-radius: var(--border-radius-md); font-size: var(--fs-sm); font-weight: 700; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: var(--sp-2); -webkit-user-select: none; user-select: none; }
.btn {
    /* ... (propiedades existentes) ... */
    transition: all 0.2s, transform 0.1s ease-out; /* Añadimos una transición específica para el transform */
}
.btn:active { transform: scale(0.98); opacity: 0.85; }
.btn--primary { background-color: var(--c-primary); color: var(--c-white); border-color: var(--c-primary); } .btn--primary:hover { background-color: var(--c-primary-hover); border-color: var(--c-primary-hover); box-shadow: var(--shadow-md); }
.btn--secondary { background-color: var(--c-surface-variant); color: var(--c-on-surface); border: 1px solid var(--c-outline); } .btn--secondary:hover { background-color: var(--c-outline); border-color: var(--c-on-surface-tertiary); }
.btn--danger { background-color: var(--c-danger); color: var(--c-white); } .btn--danger:hover { box-shadow: var(--glow-red); }
.btn--full { width: 100%; } .btn--loading { pointer-events: none; opacity: .8; }
.icon-btn { background: none; border: none; color: var(--c-on-surface-secondary); cursor: pointer; width: 36px; height: 36px; display: inline-flex; align-items: center; justify-content: center; border-radius: 50%; transition: background-color 0.2s, color 0.2s, transform 0.2s; }
.icon-btn .material-icons { font-size: 20px; }
.icon-btn:hover { background-color: var(--c-surface-variant); color: var(--c-primary); }
.icon-btn:active { transform: scale(0.9); }

/* --- Otros Componentes --- */
.login-view { position: fixed; inset: 0; z-index: 1040; display: none; flex-direction: column; justify-content: center; align-items: center; padding: var(--sp-4); opacity: 0; transition: opacity .5s; background-color: transparent; }
.login-view--visible { display: flex; opacity: 1; }
.login-view__card { padding: var(--sp-6) var(--sp-5); max-width: 380px; z-index: 10; text-align: center; animation: pop-in 0.3s ease-out; }
.empty-state { text-align: center; padding: var(--sp-5) 0; color: var(--c-on-surface-secondary); animation: fade-in 0.3s; border-radius: var(--border-radius-lg); }
.empty-state .material-icons { font-size: 40px; margin-bottom: var(--sp-2); color: var(--c-primary); }
.empty-state h3 { font-size: var(--fs-lg); font-weight: 700; color: var(--c-on-surface); margin-bottom: var(--sp-2); }
.filter-pills { display: flex; flex-wrap: wrap; gap: var(--sp-2); margin-bottom: var(--sp-4); }
.filter-pill { padding: var(--sp-1) var(--sp-3); border: 1px solid var(--c-outline); border-radius: 99px; font-size: var(--fs-xs); font-weight: 600; background-color: var(--c-surface-variant); color: var(--c-on-surface); cursor: pointer; transition: all 0.2s; }
.filter-pill:hover { opacity: 0.8; border-color: var(--c-primary); }
.filter-pill--active { background-color: var(--c-primary); color: var(--c-white); font-weight: 700; border-color: var(--c-primary); }
.toast-container { position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%); z-index: 9999; display: flex; flex-direction: column; align-items: center; gap: var(--sp-2); pointer-events: none;}
.toast { background-color: var(--c-surface); color: var(--c-white); padding: var(--sp-2) var(--sp-4); border-radius: var(--border-radius-md); box-shadow: 0 0 20px rgba(0,0,0,0.5); pointer-events: all; border: 1px solid var(--c-outline); }
@keyframes fade-out-and-collapse { from { opacity: 1; transform: scaleY(1); max-height: 76px; padding-top: var(--sp-2); padding-bottom: var(--sp-2); } to { opacity: 0; transform: scaleY(0.8); max-height: 0; padding-top: 0; padding-bottom: 0; margin: 0; border: 0; } }
.item-deleting { animation: fade-out-and-collapse 0.4s ease-out forwards; overflow: hidden; }
#description-suggestions {
    display: none; /* Empezará oculto */
    position: absolute;
    top: 100%; /* Justo debajo del campo de descripción */
    left: 0;
    right: 0;
    background-color: var(--c-surface);
    border-radius: var(--border-radius-md);
    box-shadow: 0 10px 20px rgba(0,0,0,0.4);
    z-index: 1060; /* Muy alto para estar por encima de otros elementos */
    max-height: 150px; /* Evita que la lista sea demasiado larga */
    overflow-y: auto; /* Añade una barra de scroll si es necesario */
    border: 1px solid var(--c-outline);
}
.suggestion-item { padding: var(--sp-2) var(--sp-3); cursor: pointer; font-size: var(--fs-sm); }
.suggestion-item:hover { background-color: var(--c-surface-variant); }
.suggestion-item small { color: var(--c-on-surface-secondary); font-size: var(--fs-xs); }
.movimiento-date-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 12px;
    background-color: color-mix(in srgb, var(--c-surface-variant) 85%, transparent); /* Ligera transparencia */
    color: var(--c-on-surface);
    font-weight: 700;
    font-size: var(--fs-sm);
    border-radius: 99px;
    margin-top: var(--sp-4);
    margin-bottom: var(--sp-2);
}
.movimiento-month-header {
    background-color: var(--c-surface);
    padding: var(--sp-3) var(--sp-4);
    margin-top: var(--sp-4);
    border-radius: var(--border-radius-lg);
    border: 1px solid var(--c-outline);
    box-shadow: var(--shadow-sm);

    display: flex;
    justify-content: space-between;
    align-items: center;
}

.movimiento-month-header__title {
    font-size: var(--fs-lg);
    font-weight: 800;
    color: var(--c-primary);
    text-transform: capitalize;
}

.movimiento-month-header__summary {
    text-align: right;
}

.movimiento-month-header__summary p {
    margin: 0;
    font-size: var(--fs-sm);
    font-weight: 700;
}
/* --- Calculadora Flotante --- */
#calculator-overlay { z-index: 1100; /* Debe estar por encima de otros modales */ }
.calculator-ui { position: fixed; bottom: 0; left: 50%; transform: translateX(-50%) translateY(100%); width: 100%; max-width: 420px; z-index: 10; background-color: var(--c-surface-variant); border-top: 1px solid var(--c-outline); padding: var(--sp-3); padding-bottom: calc(var(--sp-3) + env(safe-area-inset-bottom)); border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0; box-shadow: 0 -5px 20px rgba(0,0,0,0.3); transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
#calculator-overlay.modal-overlay--active .calculator-ui { transform: translateX(-50%) translateY(0); visibility: visible; }
.modal__body.calculator-active { padding-bottom: 0; }
.calculator-display { font-size: 2.1rem; font-weight: 300; text-align: right; padding: var(--sp-1) var(--sp-3); margin-bottom: var(--sp-3); min-height: 48px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.calculator-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
.calculator-btn { font-family: var(--font-family); font-size: 1.2rem; font-weight: 500; height: 48px; border-radius: var(--border-radius-md); border: none; background-color: var(--c-surface); color: var(--c-on-surface); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background-color 0.2s, transform 0.1s; }
.calculator-btn:active { transform: scale(0.95); }
.calculator-btn.btn-operator { color: var(--c-primary); }
.calculator-btn.btn-confirm { background-color: var(--c-primary); color: var(--c-white); }
.calculator-btn.zero { grid-column: span 2; }
.material-icons.backspace-icon { font-size: 1.2rem; }
/* Estilo para el nuevo display de historial */
.calculator-history-display {
    font-size: 1.1rem;
    font-weight: 500;
    color: var(--c-on-surface-secondary);
    text-align: right;
    padding: 0 var(--sp-3);
    min-height: 22px;
    margin-bottom: var(--sp-1);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Estilo para el botón de operador cuando está activo */
.calculator-btn.btn-operator--active {
    background-color: var(--c-primary);
    color: var(--c-white);
}
/* --- Estilos de Contabilidad Dual (A/B) --- */
body[data-ledger-mode="A"] #ledger-toggle-btn { background-color: var(--c-primary); border-color: var(--c-primary); color: var(--c-white); box-shadow: var(--shadow-sm); }
body[data-ledger-mode="A"] #ledger-toggle-btn:hover { background-color: var(--c-primary-hover); border-color: var(--c-primary-hover); box-shadow: var(--shadow-md); }
body[data-ledger-mode="B"] #ledger-toggle-btn { background-color: var(--c-danger); border-color: var(--c-danger); color: var(--c-white); box-shadow: var(--shadow-sm); }
body[data-ledger-mode="B"] #ledger-toggle-btn:hover { background-color: color-mix(in srgb, var(--c-danger) 85%, black); border-color: color-mix(in srgb, var(--c-danger) 85%, black); box-shadow: var(--glow-red); }
body[data-ledger-mode="B"] .bottom-nav__item--active { color: var(--c-danger); }
#ledger-toggle-btn { font-weight: 700; padding: 6px 10px; font-size: 0.8rem; min-width: 40px; text-align: center; }

/* --- Iconos y Clases de Ayuda --- */
.text-positive { color: var(--c-success); } .text-negative { color: var(--c-danger); } .text-warning { color: var(--c-warning); } .text-info { color: var(--c-info); }
.hidden { display: none !important; }
.spinner { display: inline-block; width: 1em; height: 1em; border: .15em solid currentColor; border-radius: 50%; border-top-color: transparent; animation: spin .8s linear infinite; vertical-align: middle; }
@keyframes spin { to { transform:rotate(360deg); } }
.visually-hidden { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }

/* --- Iconos de Encabezado con Estilo --- */
.top-bar .top-bar__actions .icon-btn { width: 40px; height: 40px; position: relative; overflow: hidden; transition: transform 0.25s ease-out; }
.top-bar .top-bar__actions .icon-btn .material-icons { font-size: 24px; font-weight: 600; -webkit-background-clip: text; background-clip: text; color: transparent; transition: all 0.25s ease-out; }
.top-bar .top-bar__actions .icon-btn[data-action="global-search"] .material-icons { background-image: linear-gradient(45deg, var(--c-primary), var(--c-info)); text-shadow: 0 0 8px color-mix(in srgb, var(--c-primary) 50%, transparent); }
.top-bar .top-bar__actions .icon-btn[data-action="show-main-menu"] .material-icons {
    background-image: linear-gradient(45deg, var(--c-on-surface), var(--c-on-surface-secondary));
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
}
.top-bar .top-bar__actions .icon-btn[data-action="show-aidanai-help"] .material-icons {
    background-image: linear-gradient(45deg, #2DD4BF, var(--c-primary));
    text-shadow: 0 0 8px color-mix(in srgb, var(--c-info) 50%, transparent);
}
.top-bar .top-bar__actions .icon-btn[data-action="toggle-theme"] .material-icons { background-image: linear-gradient(45deg, var(--c-info), #F43F5E); text-shadow: 0 0 8px color-mix(in srgb, var(--c-info) 50%, transparent); }
.top-bar .top-bar__actions .icon-btn[data-action="help"] .material-icons { background-image: linear-gradient(45deg, var(--c-success), #2DD4BF); text-shadow: 0 0 8px color-mix(in srgb, var(--c-success) 50%, transparent); }
.top-bar .top-bar__actions .icon-btn[data-action="exit"] .material-icons { background-image: linear-gradient(45deg, var(--c-danger), var(--c-warning)); text-shadow: 0 0 8px color-mix(in srgb, var(--c-danger) 50%, transparent); }
.top-bar .top-bar__actions .icon-btn:hover { transform: scale(1.15); background-color: color-mix(in srgb, var(--c-surface-variant) 80%, transparent); }
.top-bar .top-bar__actions .icon-btn:hover .material-icons { transform: scale(1.1); }
.top-bar .top-bar__actions .icon-btn:active { transform: scale(0.95); transition-duration: 0.1s; }

/* --- Componentes Específicos (Inversiones, Presupuestos, etc.) --- */
.investment-asset-card { background-color: var(--c-surface); border: 1px solid var(--c-outline); border-radius: var(--border-radius-lg); padding: var(--sp-3); margin-bottom: var(--sp-2); cursor: pointer; transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s; }
.investment-asset-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-md); border-color: var(--c-primary); }
.investment-asset-card__header { display: grid; grid-template-columns: 1fr auto; align-items: flex-start; gap: var(--sp-2); }
.investment-asset-card__name { font-size: var(--fs-base); font-weight: 700; }
.investment-asset-card__value { font-size: var(--fs-lg); font-weight: 800; text-align: right; }
.investment-asset-card__pnl { font-size: var(--fs-xs); font-weight: 600; text-align: right; }
.budget-item__progress { width: 100%; -webkit-appearance: none; appearance: none; height: 6px; border-radius: 99px; overflow: hidden; background-color: var(--c-surface-variant); }
.budget-item__progress::-webkit-progress-bar { background-color: var(--c-surface-variant); }
.budget-item__progress::-webkit-progress-value { background-color: var(--c-primary); transition: width 0.3s ease; }
.budget-item__progress.budget-item__progress--danger::-webkit-progress-value { background-color: var(--c-danger); }
.budget-item__progress.budget-item__progress--warning::-webkit-progress-value { background-color: var(--c-warning); }
#exit-screen { display: none; opacity: 0; position: fixed; inset: 0; background-color: var(--c-background); color: var(--c-on-surface); flex-direction: column; align-items: center; justify-content: center; z-index: 9999; font-size: 1.5rem; text-align: center; transition: opacity 0.5s ease; }
#list-loader { text-align: center; padding: var(--sp-4); color: var(--c-on-surface-secondary); }

/* PIN Input Styles */
.pin-inputs { display: flex; justify-content: center; gap: 12px; margin: 2rem 0; }
.pin-input { width: 50px; height: 60px; font-size: 2rem; text-align: center; border: 2px solid var(--c-outline); border-radius: var(--border-radius-md); background-color: var(--c-surface-variant); color: var(--c-on-surface); caret-color: var(--c-primary); transition: border-color 0.2s, box-shadow 0.2s; }
.pin-input:focus { outline: none; border-color: var(--c-primary); box-shadow: var(--shadow-md); }
.pin-input::-webkit-outer-spin-button, .pin-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.pin-input[type=number] { -moz-appearance: textfield; }

/* ... (El resto de estilos de componentes específicos se mantienen sin cambios) ... */
#movimiento-modal .form-group { margin-bottom: var(--sp-2); }
#movimiento-fecha-display { justify-content: space-between; font-weight: 500; padding-top: var(--sp-3); padding-bottom: var(--sp-3); }
#movimiento-fecha-display .material-icons { color: var(--c-on-surface-tertiary); font-size: 18px; }
.movements-modal-container { max-height: 60vh; overflow-y: auto; }
#sync-status-icon { font-size: 20px; transition: color 0.3s ease-in-out, transform 0.3s ease; }
.sync-status--synced { color: var(--c-success); transform: scale(1.1); }
.sync-status--syncing .sync-icon-spinner { animation: spin 1.2s linear infinite; }
.sync-status--error { color: var(--c-danger); }
.login-view__logo { max-width: 90px; height: auto; border-radius: 18px; margin-bottom: var(--sp-4); box-shadow: 0 0 25px rgba(255, 255, 255, 0.1); }
.login-view__tagline { font-size: var(--fs-base); color: var(--c-on-surface-secondary); margin-bottom: var(--sp-5); }
.patrimonio-header-grid { display: flex; flex-direction: column; gap: var(--sp-4); padding: var(--sp-4); margin-bottom: var(--sp-4); }
.patrimonio-header-grid__filters .kpi-item__label { margin-bottom: var(--sp-3); font-weight: 600; }

/* ================================================================= */
/* === RESPONSIVIDAD (Móvil, Tablet y Escritorio)                 === */
/* ================================================================= */

/* Para pantallas pequeñas */
@media (max-width: 380px) {
    /* 1. Hacemos que el contenedor del título sea flexible y pueda encogerse */
    .top-bar__left-button {
        flex-shrink: 1; /* Permite que este elemento se encoja si no hay espacio */
        min-width: 0;   /* Un truco de flexbox para permitir el encogimiento real */
        flex-grow: 1;   /* Permite que ocupe el espacio disponible */
    }

    /* 2. Aplicamos la magia del truncado al título */
    #page-title-display {
        display: none; /* ¡Y con esto desaparece! */
    }
    
    /* 3. Optimizamos el espaciado de los iconos */
    .top-bar__left-group {
        gap: var(--sp-1); /* Reducimos el espacio en el grupo izquierdo */
    }
    .top-bar__actions {
        gap: 0; /* Eliminamos el espacio entre los iconos de la derecha */
    }
    
    /* 4. Ajustamos el tamaño de los iconos para que sean un poco más compactos */
    .top-bar .top-bar__actions .icon-btn {
        width: 38px; /* Ligeramente más grande para un toque más fácil */
        height: 38px;
    }
    .top-bar .top-bar__actions .icon-btn .material-icons {
        font-size: 22px;
    }
}

/* Para tablets y pantallas medianas */
@media (min-width: 768px) {
    .app-layout { max-width: 95%; }
    .top-bar, .bottom-nav { max-width: 100%; }
    .modal-overlay { align-items: center; }
    .calculator-overlay { align-items: flex-end !important; }
    .modal { border-radius: var(--border-radius-lg); transform: translateY(0) scale(0.95); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s; }
    .modal-overlay--active .modal { transform: translateY(0) scale(1); }
    .view { padding: 0 var(--sp-5); }
    .kpi-grid { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: var(--sp-4); }
    .form-grid { grid-template-columns: 1fr 1fr; }
    .patrimonio-header-grid { flex-direction: row; align-items: flex-start; }
    .patrimonio-header-grid__kpi { flex: 1; min-width: 220px; }
    .patrimonio-header-grid__filters { flex: 3; padding-left: var(--sp-4); border-left: 1px solid var(--c-outline); }
}

/* Para escritorio */
@media (min-width: 1024px) {
    body { overflow-y: auto; }
    .app-layout { flex-direction: row; max-width: 100%; height: 100vh; }
    .bottom-nav { position: fixed; flex-direction: column; width: 240px; height: 100vh; left: 0; top: 0; transform: none; border-top: none; border-right: 1px solid var(--c-outline); padding: var(--sp-5) var(--sp-3); justify-content: flex-start; gap: var(--sp-2); box-shadow: none; background-color: var(--c-background); }
    .bottom-nav__item { flex: 0 0 auto; flex-direction: row; justify-content: flex-start; width: 100%; height: auto; padding: var(--sp-2) var(--sp-3); border-radius: var(--border-radius-md); }
    .bottom-nav__item:hover { background-color: var(--c-surface-variant); }
    body[data-ledger-mode="A"] .bottom-nav__item--active { background-color: var(--c-primary); color: var(--c-white); }
    body[data-ledger-mode="B"] .bottom-nav__item--active { background-color: var(--c-danger); color: var(--c-white) !important; }
    body[data-ledger-mode="A"] .bottom-nav__item--active:hover { background-color: var(--c-primary-hover); }
    body[data-ledger-mode="B"] .bottom-nav__item--active:hover { background-color: color-mix(in srgb, var(--c-danger) 80%, white); }
    .bottom-nav__item .material-icons { margin-right: var(--sp-3); font-size: 20px; }
    .bottom-nav__label { display: inline-block; font-size: var(--fs-sm); font-weight: 600; margin-top: 0; }
    .app-layout__main { margin-left: 240px; width: calc(100% - 240px); height: 100vh; padding: 60px var(--sp-6) var(--sp-6) var(--sp-6); }
    .view { max-width: 1100px; margin: 0 auto; padding: 0; }
    .top-bar { max-width: none; width: calc(100% - 240px); left: auto; right: 0; transform: none; padding-left: var(--sp-6); padding-right: var(--sp-6); }
    .toast-container { bottom: var(--sp-4); left: auto; right: calc(240px / 2); transform: translateX(50%); }
}

/* El resto de estilos de componentes específicos y helpers se mantienen sin cambios,
   ya que son estructurales y se adaptan a las variables de los temas. */
#generic-modal-body h3, #generic-modal-body h4 { margin-top: 1.2em; margin-bottom: 0.6em; color: var(--c-primary); font-weight: 700; } 
#generic-modal-body h4 { font-size: var(--fs-base); } 
#generic-modal-body p, #generic-modal-body li, #generic-modal-body small { color: var(--c-on-surface-secondary); line-height: 1.5; } 
#generic-modal-body ul, #generic-modal-body ol { list-style-position: inside; padding-left: var(--sp-2); } 
#generic-modal-body ul li, #generic-modal-body ol li { margin-bottom: 6px; }
#generic-modal-body ul ul { margin-top: 6px; }
#generic-modal-body a { color: var(--c-primary); text-decoration: none; font-weight: 600; }
#generic-modal-body a:hover { text-decoration: underline; }

.csv-converter-modal .upload-area { border: 2px dashed var(--c-outline); border-radius: var(--border-radius-lg); padding: 2.5rem; text-align: center; cursor: pointer; transition: border-color 0.3s, background-color 0.3s; margin-bottom: 1.5rem; }
.csv-converter-modal .upload-area.drag-over { border-color: var(--c-primary); background-color: color-mix(in srgb, var(--c-primary) 10%, transparent); }
.csv-converter-modal .upload-area p { margin: 0; color: var(--c-on-surface-tertiary); }
.csv-converter-modal .upload-area strong { color: var(--c-primary); }
.csv-converter-modal #file-name { font-weight: 600; color: var(--c-success); margin-top: 1rem; display: block; min-height: 24px; }
.csv-converter-modal .results-log { margin-top: 2rem; background-color: var(--c-surface-variant); border: 1px solid var(--c-outline); border-radius: var(--border-radius-md); padding: 1.5rem; display: none; }
.csv-converter-modal .results-log h2 { font-size: 1.2rem; margin-bottom: 1rem; color: var(--c-on-surface-secondary); }
.csv-converter-modal .results-log ul { list-style: none; padding: 0; }
.csv-converter-modal .results-log li { padding: 0.5rem 0; border-bottom: 1px solid var(--c-outline); display: flex; justify-content: space-between; align-items: center; }
.csv-converter-modal .results-log li:last-child { border-bottom: none; }
.csv-converter-modal .results-log li .label { color: var(--c-on-surface-tertiary); }
.csv-converter-modal .results-log li .value { font-weight: 700; color: var(--c-on-surface); padding: 0.1rem 0.5rem; border-radius: 6px; }
.csv-converter-modal .results-log .value.success { background-color: color-mix(in srgb, var(--c-success) 20%, transparent); }
.csv-converter-modal .results-log .value.warning { background-color: color-mix(in srgb, var(--c-warning) 20%, transparent); }
.csv-converter-modal .results-log .value.danger { background-color: color-mix(in srgb, var(--c-danger) 20%, transparent); }
.csv-converter-modal #download-container { margin-top: 1.5rem; display: none; }

#json-drop-zone { border: 2px dashed var(--c-outline); border-radius: var(--border-radius-lg); padding: var(--sp-6); text-align: center; cursor: pointer; transition: border-color 0.3s, background-color 0.3s; }
#json-drop-zone.drag-over { border-color: var(--c-primary); background-color: color-mix(in srgb, var(--c-primary) 10%, transparent); }
#json-preview-list { list-style: none; padding-left: 0; }
#json-preview-list li { background-color: var(--c-surface-variant); padding: var(--sp-3); border-radius: var(--border-radius-md); margin-bottom: var(--sp-2); display: flex; align-items: center; gap: var(--sp-3); }
#json-preview-list .material-icons { color: var(--c-success); }

/* === INICIO: Estilos Profesionales para Búsqueda Global === */
#global-search-results {
    padding-top: var(--sp-2);
}
.search-result-group {
    margin-bottom: var(--sp-5);
}
.search-result-group__title {
    font-size: var(--fs-xs);
    font-weight: 700;
    color: var(--c-on-surface-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 0 var(--sp-4) var(--sp-2) var(--sp-4);
    border-bottom: 1px solid var(--c-outline);
    margin-bottom: var(--sp-2);
}
.search-result-item {
    display: flex;
    align-items: center;
    gap: var(--sp-4);
    width: 100%;
    padding: var(--sp-3) var(--sp-4);
    border: none;
    background: none;
    text-align: left;
    cursor: pointer;
    border-radius: var(--border-radius-md);
    transition: background-color 0.2s ease-in-out;
}
.search-result-item:hover {
    background-color: var(--c-surface-variant);
}
.search-result-item__icon {
    flex-shrink: 0;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: var(--c-surface-variant);
    color: var(--c-primary);
}
.search-result-item__details {
    flex-grow: 1;
    min-width: 0;
}
.search-result-item__details p {
    font-weight: 600;
    color: var(--c-on-surface);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0;
}
.search-result-item__details small {
    color: var(--c-on-surface-secondary);
    font-size: var(--fs-xs);
}
.search-result-item__amount {
    font-weight: 700;
    font-size: var(--fs-base);
    white-space: nowrap;
}
/* === FIN: Estilos Profesionales para Búsqueda Global === */

/* === INICIO: Estilos para Pull-to-Refresh === */
#pull-to-refresh-indicator {
    position: absolute;
    top: 44px; /* Altura de la barra superior para que no quede debajo */
    left: 0;
    right: 0;
    z-index: 10;
    display: flex;
    justify-content: center;
    padding: 10px;
    opacity: 0; /* Empieza totalmente invisible */
    transform: translateY(-50px); /* Empieza escondido arriba */
    transition: opacity 0.3s, transform 0.3s;
}

#pull-to-refresh-indicator.visible {
    opacity: 1;
    transform: translateY(0); /* Se desliza a su posición visible */
}

#pull-to-refresh-indicator .spinner {
    width: 24px;
    height: 24px;
    border-width: 3px;
    color: var(--c-primary);
}
/* === FIN: Estilos para Pull-to-Refresh === */
 /* === INICIO: Estilos para el Menú Desplegable === */
.popover-menu {
    position: fixed;
    top: 48px; /* Justo debajo de la barra superior */
    right: 8px;
    z-index: 1100; /* Muy alto para que esté por encima de todo */
    background-color: var(--c-surface-variant);
    border-radius: var(--border-radius-md);
    border: 1px solid var(--c-outline);
    box-shadow: var(--shadow-md);
    width: 220px;
    padding: var(--sp-2);
    
    /* Magia para ocultar/mostrar */
    opacity: 0;
    transform: translateY(-10px) scale(0.95);
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
    pointer-events: none; /* No se puede hacer clic cuando está oculto */
}

.popover-menu--visible {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
}

.popover-menu__item {
    display: flex;
    align-items: center;
    gap: var(--sp-3);
    width: 100%;
    padding: var(--sp-2) var(--sp-3);
    border-radius: 6px;
    border: none;
    background: none;
    cursor: pointer;
    text-align: left;
    font-size: var(--fs-sm);
    font-weight: 500;
    color: var(--c-on-surface);
    transition: background-color 0.2s;
}

.popover-menu__item:hover {
    background-color: var(--c-surface);
}

.popover-menu__item--danger {
    color: var(--c-danger);
}

.popover-menu__divider {
    height: 1px;
    background-color: var(--c-outline);
    margin: var(--sp-2) 0;
}
/* === FIN: Estilos para el Menú Desplegable === */
/* Pega este bloque al final de tu <style> */
@media (max-width: 380px) {
    /* --- Optimizaciones Generales para Pantallas Pequeñas --- */
    
    /* 1. Reducimos el espaciado lateral para ganar espacio vital */
    .view {
        padding: 0 var(--sp-2); 
    }

    /* 2. Hacemos que los títulos y contenidos de las tarjetas sean más compactos */
    .card__content {
        padding: var(--sp-2);
    }
    .card__title {
        padding: var(--sp-3) var(--sp-2) 0 var(--sp-2);
    }

    /* --- Soluciones Específicas --- */

    /* 3. ¡LA SOLUCIÓN A TU PROBLEMA EN INVERSIONES! */
    /* Forzamos el resumen del portafolio a apilarse verticalmente */
    #inversiones-page .card__content {
        flex-direction: column;
        gap: var(--sp-3);
        align-items: center;
    }

    /* 4. Forzamos TODOS los grids (KPIs, formularios, etc.) a una sola columna */
    .kpi-grid,
    .form-grid {
        grid-template-columns: 1fr !important; /* Usamos !important para asegurar la anulación */
        gap: var(--sp-2);
    }

    /* 5. Aseguramos que los filtros de fecha también se apilen correctamente */
    #custom-date-filters.form-grid {
        grid-template-columns: 1fr !important;
    }
    
    /* --- Reglas Originales (Mantenidas) --- */
    
    /* 6. Optimizamos la barra superior para que no se desborde */
    .top-bar__left-button {
        flex-shrink: 1; 
        min-width: 0;   
        flex-grow: 1;   
    }
    #page-title-display {
        display: none; 
    }
    .top-bar__left-group {
        gap: var(--sp-1);
    }
    .top-bar__actions {
        gap: 0;
    }
    .top-bar .top-bar__actions .icon-btn {
        width: 38px;
        height: 38px;
    }
    .top-bar .top-bar__actions .icon-btn .material-icons {
        font-size: 22px;
    }
}
/* Pega este bloque DENTRO de tu @media (max-width: 380px) { ... } */

/* --- INICIO: Corrección para Informe de Cuenta en Móviles Pequeños --- */

/* 1. Ocultamos la cabecera original, ya no tiene sentido en la vista de tarjeta. */
.informe-linea-header {
    display: none;
}

/* 2. Transformamos cada fila de movimiento en una "mini-tarjeta" apilada. */
.informe-linea-movimiento {
    grid-template-columns: 1fr auto; /* Columna izquierda flexible, derecha ajustada al contenido. */
    grid-template-rows: auto auto;    /* Dos filas para apilar la información. */
    padding: var(--sp-3);            /* Más espaciado para que respire como una tarjeta. */
    gap: 4px var(--sp-4);            /* Pequeño espacio vertical, más grande horizontal. */
    align-items: center;
    border-bottom: 1px solid var(--c-outline); /* Separamos visualmente cada "tarjeta". */
}
.informe-extracto-container {
    border: none; /* Quitamos el borde general para un look más limpio. */
}

/* 3. Reposicionamos cada elemento en la nueva rejilla de 2x2. */
.informe-linea-movimiento .fecha {
    grid-column: 1;
    grid-row: 1;
    font-size: var(--fs-xs); /* Hacemos la fecha un poco más pequeña. */
    color: var(--c-on-surface-secondary);
    font-weight: 600;
}

.informe-linea-movimiento .concepto {
    grid-column: 1;
    grid-row: 2;
    /* El estilo del concepto (negrita, etc.) ya es bueno, lo dejamos. */
}

.informe-linea-movimiento .importe {
    grid-column: 2;
    grid-row: 1;
    font-size: 1.1em; /* Hacemos el importe un poco más grande para destacarlo. */
}

.informe-linea-movimiento .saldo {
    grid-column: 2;
    grid-row: 2;
    font-size: var(--fs-xs);
    color: var(--c-on-surface-secondary);
}


/* --- FIN: Corrección para Informe de Cuenta --- */
/* === INICIO: Estilos para Resumen Mensual en Extracto === */
.informe-linea-resumen {
    display: flex;
    align-items: center;
    gap: var(--sp-2);
    padding: var(--sp-3) var(--sp-3); /* Más espacio vertical */
    font-size: 0.85rem; /* Ligeramente más grande */
    line-height: 1.3;
    background-color: var(--c-surface-variant);
    border-top: 1px solid var(--c-outline); /* Separador superior */
    font-weight: 700; /* Texto en negrita */
    margin-top: -1px; /* Solapar borde con el último ítem */
}

.informe-linea-resumen .fecha {
    width: 45px;
    visibility: hidden; /* Mantiene el espacio pero oculta el contenido */
}

.informe-linea-resumen .descripcion {
    flex-grow: 1;
    flex-shrink: 1;
    min-width: 0;
    text-align: right; /* Alinear texto del resumen a la derecha */
    font-style: italic;
    color: var(--c-on-surface-secondary);
    padding-right: var(--sp-4); /* Añadir espacio antes de los números */
}
 /* Hacer que el resumen use monoespaciado para alinear */
.informe-linea-resumen .importe,
.informe-linea-resumen .saldo {
    width: 90px;
    text-align: right;
    font-family: monospace, sans-serif;
    font-size: 0.9em;
}

.informe-linea-resumen .saldo {
     visibility: hidden; /* Mantiene el espacio pero oculta el contenido */
}
/* === FIN: Estilos para Resumen Mensual en Extracto === */
    </style>
	
</head>

<body data-ledger-mode="A">
    <noscript>You need to enable JavaScript to run this app.</noscript>
     
<div id="login-screen" class="login-view">
    <div class="starry-background"></div>
    <div class="login-view__card">
        <img src="aiDANaI.webp" alt="Logo Cuentas aiDANaI" class="login-view__logo">
        
        <h2 id="login-title" class="login-view__title">Bienvenido de nuevo</h2>
        <p class="login-view__tagline">Inicia sesión para controlar tus finanzas.</p>

        <form id="login-form" noValidate>
            <div class="form-group form-group--with-icon">
                <span class="material-icons">alternate_email</span>
                <input type="email" id="login-email" class="form-input" placeholder="Correo electrónico" required autoComplete="email" autoCapitalize="none" aria-describedby="login-email-error" />
                <span class="form-error" id="login-email-error"></span>
            </div>
            <div class="form-group form-group--with-icon">
                <span class="material-icons">lock</span>
                <input type="password" id="login-password" class="form-input" placeholder="Contraseña" required autoComplete="current-password" aria-describedby="login-password-error" />
                <span class="form-error" id="login-password-error"></span>
            </div>

            <div class="login-view__actions">
                <a href="#" class="login-view__link" data-action="forgot-password">¿Olvidaste tu contraseña?</a>
            </div>

            <p id="login-error" class="form-error" style="min-height: 16px; margin-top: 8px;"></p>
            
            <div class="login-view__footer">
                <button type="submit" data-action="login" class="btn btn--primary btn--full">Iniciar Sesión</button>
                <p class="login-view__secondary-action">
                    <span>¿No tienes una cuenta?</span> <a href="#" class="login-view__link" data-action="show-register">Regístrate aquí</a>
                </p>
            </div>
        </form>
    </div>
</div>

<div id="pin-login-screen" class="login-view">
    <div class="starry-background"></div>
    <div class="login-view__card">
        <img src="aiDANaI.webp" alt="Logo" class="login-view__logo">
        <h2 class="login-view__title">Acceso Rápido</h2>
        <p class="login-view__tagline">Introduce tu PIN de 4 dígitos.</p>

        <form id="pin-form">
            <div class="pin-inputs" id="pin-inputs-container">
                <input type="password" class="pin-input" pattern="[0-9]*" inputmode="numeric" maxlength="1" required>
                <input type="password" class="pin-input" pattern="[0-9]*" inputmode="numeric" maxlength="1" required>
                <input type="password" class="pin-input" pattern="[0-9]*" inputmode="numeric" maxlength="1" required>
                <input type="password" class="pin-input" pattern="[0-9]*" inputmode="numeric" maxlength="1" required>
            </div>
            <p id="pin-error" class="form-error" style="min-height: 16px; margin-top: 8px;"></p>
        </form>
        
    <div class="login-view__footer">
    <p class="login-view__secondary-action">
        <a href="#" class="login-view__link" data-action="use-password-instead">
            Usar contraseña en su lugar
        </a>
    </p>
    <p class="login-view__secondary-action" style="margin-top: var(--sp-2);">
        <a href="#" class="login-view__link" data-action="logout">O iniciar sesión con otra cuenta</a>
    </p>
</div>
    </div>
</div>
    
    <div id="app-root" class="app-layout">
    <nav class="bottom-nav">
    <button data-action="navigate" data-page="inicio-page" class="bottom-nav__item">
    <span class="material-icons">home</span> <span class="bottom-nav__label">Inicio</span>
</button>
    <button data-action="navigate" data-page="diario-page" class="bottom-nav__item">
        <span class="material-icons">receipt_long</span>
        <span class="bottom-nav__label">Diario</span>
    </button>
            <button data-action="navigate" data-page="inversiones-page" class="bottom-nav__item">
                <span class="material-icons">rocket_launch</span>
                <span class="bottom-nav__label">Inversiones</span>
            </button>
            <button data-action="navigate" data-page="otros-page" class="bottom-nav__item">
    <span class="material-icons">apps</span>
    <span class="bottom-nav__label">Otros</span>
</button>
            <button data-action="navigate" data-page="configuracion-page" class="bottom-nav__item">
                <span class="material-icons">settings</span>
                <span class="bottom-nav__label">Ajustes</span>
            </button>
        </nav>

        <header id="app-top-bar" class="top-bar">
            <div class="top-bar__left-group">
                <div id="top-bar-left-button" class="top-bar__left-button">
                </div>
            </div>

            <h1 id="top-bar-title" class="top-bar__title"></h1>

            <div id="top-bar-actions" class="top-bar__actions"></div>
			 <span id="sync-status-icon" class="material-icons"></span>
        </header>
		<!-- INICIO: Menú desplegable de la barra superior -->
<div id="main-menu-popover" class="popover-menu">
    
    <button data-action="show-aidanai-help" class="popover-menu__item">
        <span class="material-icons">support_agent</span>
        <span>Asistente aiDANaI</span>
    </button>
    <button data-action="help" class="popover-menu__item">
        <span class="material-icons">help_outline</span>
        <span>Guía de Usuario</span>
    </button>
    <div class="popover-menu__divider"></div>
    <button data-action="exit" class="popover-menu__item popover-menu__item--danger">
        <span class="material-icons">exit_to_app</span>
        <span>Salir</span>
    </button>
</div>
<!-- FIN: Menú desplegable -->
        <main class="app-layout__main">
            
            <section id="inicio-page" class="view">
    
    <!-- INICIO: Nuevo Contenedor para Filtros Globales -->
    <div id="dashboard-global-filters" class="card" style="margin-bottom: var(--sp-4);">
        <div class="card__content" style="padding-bottom: var(--sp-3);">
            <div class="form-group">
                <label for="filter-periodo" class="form-label">Periodo de Análisis</label>
                <select id="filter-periodo" class="form-select">
                    <option value="mes-actual">Este Mes</option>
                    <option value="año-actual" selected>Este Año</option>
                    <option value="custom">Personalizado</option>
                </select>
            </div>
            <div id="custom-date-filters" class="form-grid hidden" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                    <label for="filter-fecha-inicio" class="form-label">Desde</label>
                    <input type="date" id="filter-fecha-inicio" class="form-input">
                </div>
                <div class="form-group">
                    <label for="filter-fecha-fin" class="form-label">Hasta</label>
                    <input type="date" id="filter-fecha-fin" class="form-input">
                </div>
            </div>
             <!-- El botón "Aplicar" solo es necesario para el modo personalizado -->
            <button data-action="apply-filters" class="btn btn--primary btn--full hidden" style="margin-top: var(--sp-4);">Aplicar Filtros</button>
        </div>
    </div>
    <!-- FIN: Nuevo Contenedor para Filtros Globales -->

    <div id="resumen-content-container">
        <!-- El contenido (los widgets) se renderizará aquí vía JS -->
    </div>

</section>

            <section id="diario-page" class="view" style="padding: 0; gap: 0;">
				<div id="pull-to-refresh-indicator">
					<span class="spinner"></span>
				</div>
				<div id="diario-view-container">
					</div>
			</section>
			<section id="inversiones-page" class="view">
                <!-- El contenido del portafolio se renderizará aquí -->
            </section>
            <section id="otros-page" class="view">
    <!-- El nuevo contenido unificado se renderizará aquí -->
</section>
            
            <section id="configuracion-page" class="view">
                <div class="card card--no-bg accordion-wrapper">
                    <details class="accordion">
                        <summary>
                            <h3 class="card__title" style="margin:0; padding: 0; color: var(--c-on-surface);">
                                <span class="material-icons">person_outline</span>
                                <span>Cuenta y Preferencias</span>
                            </h3>
                            <span class="material-icons accordion__icon">expand_more</span>
                        </summary>
                        <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                            
                            <h3 class="card__title" style="margin-top: 0; font-size: var(--fs-base); padding: 0;">
                                <span class="material-icons">account_circle</span>
                                <span>Cuenta de Usuario</span>
                            </h3>
                            <div class="modal__list-item" style="padding-left: 0; padding-right: 0; margin-top: var(--sp-2);">
                                <span>Sesión iniciada como:</span>
                                <strong id="config-user-email">cargando...</strong>
                            </div>
                            <button data-action="logout" class="btn btn--danger btn--full" style="margin-top: var(--sp-4);">
                                <span class="material-icons" style="font-size: 16px;">logout</span>
                                <span>Cerrar Sesión</span>
                            </button>
                            <button data-action="set-pin" class="btn btn--secondary btn--full" style="margin-top: var(--sp-2);">
                                <span class="material-icons" style="font-size: 16px;">password</span>
                                <span>Configurar PIN de Acceso Rápido</span>
                            </button>
                            <button data-action="delete-account" class="btn btn--danger btn--full" style="margin-top: var(--sp-2); background-color: var(--c-black); border: 1px solid var(--c-danger);">
                                <span class="material-icons" style="font-size: 16px;">delete_forever</span>
                                <span>Eliminar Mi Cuenta Permanentemente</span>
                            </button>

                                                        
                            <button data-action="save-config" class="btn btn--primary btn--full" style="margin-top: var(--sp-5);">Guardar Preferencias</button>

                        </div>
                    </details>
                </div>
                
                <div class="card card--no-bg accordion-wrapper">
                    <details class="accordion">
                        <summary>
                            <h3 class="card__title" style="margin:0; padding: 0; color: var(--c-on-surface);">
                                <span class="material-icons">edit_note</span><span>Gestión de Datos</span>
                            </h3>
                            <span class="material-icons accordion__icon">expand_more</span>
                        </summary>
                        <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                            <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                                <button data-action="manage-cuentas" class="btn btn--secondary"><span class="material-icons" style="font-size: 16px;">account_balance</span><span>Cuentas</span></button>
                                <button data-action="manage-conceptos" class="btn btn--secondary"><span class="material-icons" style="font-size: 16px;">category</span><span>Conceptos</span></button>
                            </div>
                            <button data-action="recalculate-balances" class="btn btn--secondary btn--full" style="margin-top: var(--sp-4);">
							<span class="material-icons" style="font-size: 16px;">verified_user</span>
							<span>Auditar y Corregir Saldos</span>
							</button>
                        </div>
                    </details>
                </div>
                <div class="card card--no-bg accordion-wrapper">
                    <details class="accordion">
                        <summary>
                            <h3 class="card__title" style="margin:0; padding: 0; color: var(--c-on-surface);">
                                <span class="material-icons">backup</span><span>Copia de Seguridad</span>
                            </h3>
                            <span class="material-icons accordion__icon">expand_more</span>
                        </summary>
                        <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                            <p style="font-size: var(--fs-sm); color: var(--c-on-surface-secondary); margin-bottom: var(--sp-4);">La importación de JSON o CSV reemplazará todos los datos actuales. Se recomienda exportar primero para tener una copia de seguridad.</p>
                            <div class="form-grid">
                                <button data-action="export-data" class="btn btn--secondary" title="Exportar una copia de seguridad completa en formato JSON."><span class="material-icons" style="font-size: 16px;">save</span><span>Exportar JSON</span></button>
                                <button data-action="export-csv" class="btn btn--secondary"><span class="material-icons" style="font-size: 16px;">grid_on</span>Exportar CSV</button>
                                <button data-action="import-data" class="btn btn--secondary" title="Importar desde un archivo de seguridad JSON."><span class="material-icons" style="font-size: 16px;">file_upload</span><span>Importar JSON</span></button>
                                <button data-action="import-csv" class="btn btn--secondary"><span class="material-icons" style="font-size: 16px;">upload_file</span><span>Importar CSV</span></button>
                            </div>
                            <input type="file" id="import-file-input" class="hidden" accept=".json,application/json" />
                            <button data-action="clear-data" class="btn btn--danger btn--full" style="margin-top: var(--sp-4);">Borrar Todos los Datos</button>
                        </div>
                    </details>
                </div>
            </section>

        </main>
        
    <div class="fab-container">
    <!-- Overlay para cerrar el menú al hacer clic fuera -->
    <div class="fab-overlay"></div>

    <!-- Acciones que aparecen hacia arriba -->
    <div class="fab-action-item">
        <span class="fab-action-label">Traspaso</span>
        <button data-action="open-fab-action" data-type="traspaso" class="fab-action-btn btn--info">
            <span class="material-icons">swap_horiz</span>
        </button>
    </div>
    <div class="fab-action-item">
        <span class="fab-action-label">Ingreso</span>
        <button data-action="open-fab-action" data-type="ingreso" class="fab-action-btn btn--success">
            <span class="material-icons">arrow_downward</span>
        </button>
    </div>
    <div class="fab-action-item">
        <span class="fab-action-label">Gasto</span>
        <button data-action="open-fab-action" data-type="gasto" class="fab-action-btn btn--danger">
            <span class="material-icons">arrow_upward</span>
        </button>
    </div>
    
    <!-- Botón Principal (+) que siempre se ve -->
    <button data-action="toggle-fab-menu" id="fab-main" class="fab">
        <span class="material-icons">add</span>
    </button>
</div>
    
    <div id="toast-container" aria-live="assertive"></div>
    
    <div id="movimiento-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="form-movimiento-title">
        <div class="modal">
            <div class="modal__grabber"></div>
            <header class="modal__header" style="padding-top: var(--sp-2);">
                <h3 id="form-movimiento-title" class="modal__title">Añadir Movimiento</h3>
                <button class="icon-btn" data-action="close-modal" data-modal-id="movimiento-modal" title="Cerrar" aria-label="Cerrar"><span class="material-icons">close</span></button>
            </header>
            <div class="modal__body">
            <!-- ▼▼▼ REEMPLAZA TU <form> ENTERO CON ESTE BLOQUE COMPLETO ▼▼▼ -->
<form id="form-movimiento" novalidate>
    <input type="hidden" id="movimiento-id" />
    <input type="hidden" id="movimiento-mode" value="new" />
    
    <div class="filter-pills" style="justify-content: center; margin-bottom: var(--sp-3);">
        <button type="button" class="filter-pill filter-pill--active" data-action="set-movimiento-type" data-type="gasto">Gasto</button>
        <button type="button" class="filter-pill" data-action="set-movimiento-type" data-type="ingreso">Ingreso</button>
        <button type="button" class="filter-pill" data-action="set-movimiento-type" data-type="traspaso">Traspaso</button>
    </div>

    <div class="form-grid" style="grid-template-columns: 40% 1fr; align-items: flex-start;">
        <div class="form-group" id="movimiento-cantidad-form-group">
            <label for="movimiento-cantidad" class="form-label">Cantidad</label>
            <div class="form-group-addon">
                <input type="text" id="movimiento-cantidad" class="form-input" required placeholder="25,50" />
                <button type="button" id="calculator-toggle-btn" class="icon-btn" title="Abrir Calculadora">
                    <span class="material-icons">calculate</span>
                </button>
            </div>
            <span class="form-error" id="movimiento-cantidad-error"></span>
        </div>
        <div class="form-group">
            <label for="movimiento-descripcion" class="form-label">Descripción</label>
            <input type="text" id="movimiento-descripcion" class="form-input" required placeholder="Ej: Compra semanal" />
            <span class="form-error" id="movimiento-descripcion-error"></span>
            <div id="description-suggestions"></div>
        </div>
    </div>

    <!-- ✅ INICIO DE LA CORRECCIÓN ESTRUCTURAL ✅ -->
    <!-- Estos son los contenedores que controlan qué campos se ven -->
    <div id="movimiento-fields">
        <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
            <div class="form-group-addon">
                <div class="form-group">
                    <label for="movimiento-concepto" class="form-label">Concepto</label>
                    <select id="movimiento-concepto" class="form-select" required></select>
                    <span class="form-error" id="movimiento-concepto-error"></span>
                </div>
                <button type="button" data-action="manage-conceptos" class="icon-btn" title="Gestionar Conceptos"><span class="material-icons">more_vert</span></button>
            </div>
            <div class="form-group-addon">
                <div class="form-group">
                    <label for="movimiento-cuenta" class="form-label">Cuenta</label>
                    <select id="movimiento-cuenta" class="form-select" required></select>
                    <span class="form-error" id="movimiento-cuenta-error"></span>
                </div>
                <button type="button" data-action="manage-cuentas" class="icon-btn" title="Gestionar Cuentas"><span class="material-icons">more_vert</span></button>
            </div>
        </div>
    </div>

    <div id="traspaso-fields" class="hidden">
         <div class="form-group">
            <label class="form-label" for="traspaso-show-all-accounts-toggle">Cuentas</label>
            <div class="form-checkbox-group" style="margin-bottom: var(--sp-2);">
                <input type="checkbox" id="traspaso-show-all-accounts-toggle" data-action="toggle-traspaso-accounts-filter" />
                <label for="traspaso-show-all-accounts-toggle" style="font-size: var(--fs-xs);">Mostrar cuentas de ambas contabilidades (A y B)</label>
            </div>
        </div>
        <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
            <div class="form-group">
                <label for="movimiento-cuenta-origen" class="form-label">Cuenta Origen</label>
                <select id="movimiento-cuenta-origen" class="form-select"></select>
                <span class="form-error" id="movimiento-cuenta-origen-error"></span>
            </div>
            <div class="form-group">
                <label for="movimiento-cuenta-destino" class="form-label">Cuenta Destino</label>
                <select id="movimiento-cuenta-destino" class="form-select"></select>
                <span class="form-error" id="movimiento-cuenta-destino-error"></span>
            </div>
        </div>
    </div>
    <!-- ✅ FIN DE LA CORRECCIÓN ESTRUCTURAL ✅ -->
    
    <div style="border-top: 1px solid var(--c-outline); margin-top: var(--sp-3); padding-top: var(--sp-2);">
        <div class="form-switch-group modal__list-item" style="padding: var(--sp-2) 0;">
            <label for="movimiento-recurrente" style="font-weight: 700;">¿Programar como recurrente?</label>
            <label class="form-switch"><input type="checkbox" id="movimiento-recurrente"><span class="slider"></span></label>
        </div>
        <div id="recurrent-options" class="hidden" style="animation: fade-in 0.3s; margin-top: var(--sp-2);">
            <div class="form-group">
                <label for="recurrent-frequency" class="form-label">Frecuencia</label>
                <select id="recurrent-frequency" class="form-select">
                    <option value="once">Única vez</option>
                    <option value="daily">Diaria</option>
                    <option value="weekly">Semanal</option>
                    <option value="monthly" selected>Mensual</option>
                    <option value="yearly">Anual</option>
                </select>
            </div>
            <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                <div class="form-group">
                    <label for="recurrent-next-date" class="form-label">Próxima ejecución</label>
                    <input type="date" id="recurrent-next-date" class="form-input">
                </div>
                <div class="form-group">
                    <label for="recurrent-end-date" class="form-label">Finaliza el (opcional)</label>
                    <input type="date" id="recurrent-end-date" class="form-input">
                </div>
            </div>
        </div>
    </div>
    
    <div class="form-group" style="margin-top: var(--sp-2);">
        <label for="movimiento-fecha-display" class="form-label">Fecha</label>
        <div class="form-group-addon">
            <input type="date" id="movimiento-fecha" class="visually-hidden" required />
            <button type="button" id="movimiento-fecha-display" class="btn btn--secondary" style="flex-grow: 1;">
                <span id="movimiento-fecha-text"></span>
                <span class="material-icons">edit_calendar</span>
            </button>
        </div>
        <span class="form-error" id="movimiento-fecha-error"></span>
    </div>

    <div class="modal__actions">
        <div class="left-actions">
            <button type="button" id="delete-movimiento-btn" data-action="delete-movement-from-modal" class="icon-btn btn--danger hidden" title="Borrar"><span class="material-icons">delete</span></button>
            <button type="button" id="duplicate-movimiento-btn" data-action="duplicate-movement" class="icon-btn btn--secondary hidden" title="Duplicar"><span class="material-icons">content_copy</span></button>
        </div>
        <div class="right-actions">
            <button id="save-and-new-movimiento-btn" type="button" data-action="save-and-new-movement" class="btn btn--secondary">Guardar y Nuevo</button>
            <button id="save-movimiento-btn" type="submit" class="btn btn--primary">Guardar</button>
        </div>
    </div>
</form>
<!-- ▲▲▲ FIN DEL BLOQUE DE REEMPLAZO ▲▲▲ -->
			</div>
			
    </div>
                 
    </div>
	    <div id="generic-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="generic-modal-title">
        <div class="modal">
            <header class="modal__header">
                <h3 id="generic-modal-title" class="modal__title"></h3>
                <button class="icon-btn" data-action="close-modal" data-modal-id="generic-modal" title="Cerrar" aria-label="Cerrar"><span class="material-icons">close</span></button>
            </header>
            <div id="generic-modal-body" class="modal__body"></div>
        </div>
    </div>
	 <div id="diario-filters-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="diario-filters-title">
    <div class="modal">
        <div class="modal__grabber"></div>
        <header class="modal__header" style="padding-top: var(--sp-2);">
            <h3 id="diario-filters-title" class="modal__title">Filtrar Diario</h3>
            <button class="icon-btn" data-action="close-modal" data-modal-id="diario-filters-modal" title="Cerrar" aria-label="Cerrar"><span class="material-icons">close</span></button>
        </header>
        <div class="modal__body">
            <form id="diario-filters-form" novalidate>
                <div class="form-group">
                    <label class="form-label">Rango de Fechas</label>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                        <input type="date" id="filter-diario-start-date" class="form-input">
                        <input type="date" id="filter-diario-end-date" class="form-input">
                    </div>
                </div>

                <div class="form-group">
                    <label for="filter-diario-description" class="form-label">La descripción contiene...</label>
                    <input type="search" id="filter-diario-description" class="form-input" placeholder="Ej: Amazon, compra semanal...">
                </div>

                <div class="form-group">
                    <label class="form-label">Importe entre...</label>
                    <div class="form-grid" style="grid-template-columns: 1fr 1fr;">
                        <input type="number" id="filter-diario-min-amount" class="form-input" placeholder="Mínimo (€)">
                        <input type="number" id="filter-diario-max-amount" class="form-input" placeholder="Máximo (€)">
                    </div>
                </div>

                <div class="form-group">
                    <label for="filter-diario-cuentas" class="form-label">Cuentas (selección múltiple)</label>
                    <select id="filter-diario-cuentas" class="form-select" multiple style="height: 120px;"></select>
                </div>
                
                <div class="form-group">
                    <label for="filter-diario-conceptos" class="form-label">Conceptos (selección múltiple)</label>
                    <select id="filter-diario-conceptos" class="form-select" multiple style="height: 120px;"></select>
                </div>
                
                <div class="modal__actions" style="justify-content: space-between;">
                    <button type="button" data-action="clear-diario-filters" class="btn btn--secondary">Limpiar Filtros</button>
                    <button type="submit" class="btn btn--primary">Aplicar Filtros</button>
                </div>
            </form>
        </div>
    </div>
</div>
<div id="global-search-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="global-search-title">
        <div class="modal">
            <header class="modal__header">
                <div id="global-search-input-wrapper">
                    <span class="material-icons" style="color: var(--c-on-surface-secondary);">search</span>
                    <input type="search" id="global-search-input" placeholder="Buscar en toda la app..." autocomplete="off">
                </div>
                <button class="icon-btn" data-action="close-modal" data-modal-id="global-search-modal" title="Cerrar" aria-label="Cerrar"><span class="material-icons">close</span></button>
            </header>
            <div id="global-search-results" class="modal__body">
                <div class="empty-state" style="background:transparent; border: none;">
                    <span class="material-icons">manage_search</span>
                    <h3>Encuéntralo todo</h3>
                    <p>Busca movimientos, cuentas o conceptos. <br>Atajo: <strong>Cmd/Ctrl + K</strong></p>
                </div>
            </div>
        </div>
    </div>
    
    
    <div id="json-import-wizard-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="json-wizard-title">
        <div class="modal" style="max-width: 500px; height: auto; max-height: 85vh;">
            <header class="modal__header">
                <h3 id="json-wizard-title" class="modal__title">Asistente de Importación JSON</h3>
                <button class="icon-btn" data-action="close-modal" data-modal-id="json-import-wizard-modal" title="Cerrar" aria-label="Cerrar"><span class="material-icons">close</span></button>
            </header>
            <div id="json-wizard-body" class="modal__body" style="display: flex; flex-direction: column;">

                <div id="json-wizard-step-1" class="json-wizard-step">
                    <h4>Paso 1: Selecciona tu copia de seguridad</h4>
                    <p class="form-label" style="margin-bottom: var(--sp-3);">Arrastra y suelta el archivo <code>.json</code> o haz clic para seleccionarlo. La importación reemplazará <strong>todos</strong> tus datos actuales.</p>
                    <div id="json-drop-zone">
                        <span class="material-icons" style="font-size: 48px; color: var(--c-outline);">upload_file</span>
                        <p id="json-drop-zone-text">Arrastra tu archivo aquí o haz clic</p>
                    </div>
                    <div id="json-file-error" class="form-error" style="text-align: center; margin-top: var(--sp-3);"></div>
                </div>

                <div id="json-wizard-step-2" class="json-wizard-step" style="display: none;">
                    <h4>Paso 2: Revisa y confirma</h4>
                    <p class="form-label" style="margin-bottom: var(--sp-3);">Hemos analizado tu archivo. Si los datos son correctos, pulsa "Importar" para reemplazar tus datos actuales.</p>
                    <div id="json-preview-container">
                        <ul id="json-preview-list"></ul>
                        <div class="form-error" style="margin-top: var(--sp-2); text-align: center;"><strong>Atención:</strong> <span>Esta acción es irreversible.</span></div>
                    </div>
                    <div class="modal__actions" style="justify-content: space-between;">
                        <button class="btn btn--secondary" data-action="json-wizard-back-2">Atrás</button>
                        <button class="btn btn--danger" data-action="json-wizard-import-final"><span class="material-icons">warning</span><span>Importar y Reemplazar</span></button>
                    </div>
                </div>

                <div id="json-wizard-step-3" class="json-wizard-step" style="display: none; justify-content: center; align-items: center; text-align: center; min-height: 200px;">
                    <div id="json-import-progress">
                        <span class="spinner" style="width: 48px; height: 48px; border-width: 4px;"></span>
                        <h4 style="margin-top: var(--sp-4);">Importando...</h4>
                        <p>Estamos guardando tus datos. Por favor, no cierres esta ventana.</p>
                    </div>
                     <div id="json-import-result" style="display: none;">
                        <span class="material-icons" style="font-size: 60px; color: var(--c-success);">task_alt</span>
                        <h4 id="json-result-title" style="margin-top: var(--sp-2);">¡Importación Completada!</h4>
                        <p id="json-result-message"></p>
                        <div class="modal__actions" style="justify-content: center;">
                            <button class="btn btn--primary" data-action="close-modal" data-modal-id="json-import-wizard-modal">Finalizar</button>
                        </div>
                     </div>
                </div>

            </div>
        </div>
    </div>


    <div id="exit-screen">
        <p>Finanzas al día ✅ Movimientos revisados 👀  <br>💰 aiDANaI simplifica tus cuentas 💰</p>
    </div>
<div id="help-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="help-modal-title">
    <div class="modal" style="max-width: 650px; max-height: 80vh;">
        <header class="modal__header">
            <h3 id="help-modal-title" class="modal__title"></h3>
            <button class="icon-btn" data-action="close-modal" data-modal-id="help-modal" title="Cerrar" aria-label="Cerrar">
                <span class="material-icons">close</span>
            </button>
        </header>
        <div id="help-modal-body" class="modal__body">
        </div>
    </div>
</div>
<div id="calculator-overlay" class="modal-overlay" style="background: transparent; pointer-events: none;">
    <div id="calculator-ui" class="calculator-ui" style="pointer-events: all;">
    <!-- === INICIO: CÓDIGO AÑADIDO === -->
    <div id="calculator-history-display" class="calculator-history-display"></div>
    <!-- === FIN: CÓDIGO AÑADIDO === -->
    <div id="calculator-display" class="calculator-display">0</div>
    <div id="calculator-grid" class="calculator-grid">
        <button class="calculator-btn btn-operator" data-key="clear">C</button>
        <button class="calculator-btn btn-operator" data-key="sign">+/-</button>
        <button class="calculator-btn btn-operator" data-key="backspace"><span class="material-icons backspace-icon">backspace</span></button>
        <button class="calculator-btn btn-confirm" id="calculator-btn-done" data-key="done">OK</button>
        
        <button class="calculator-btn" data-key="7">7</button>
        <button class="calculator-btn" data-key="8">8</button>
        <button class="calculator-btn" data-key="9">9</button>
        <button class="calculator-btn btn-operator" data-key="divide">/</button>

        <button class="calculator-btn" data-key="4">4</button>
        <button class="calculator-btn" data-key="5">5</button>
        <button class="calculator-btn" data-key="6">6</button>
        <button class="calculator-btn btn-operator" data-key="multiply">x</button>
        
        <button class="calculator-btn" data-key="1">1</button>
        <button class="calculator-btn" data-key="2">2</button>
        <button class="calculator-btn" data-key="3">3</button>
        <button class="calculator-btn btn-operator" data-key="subtract">-</button>

        <button class="calculator-btn zero" data-key="0">0</button>
        <button class="calculator-btn" data-key="comma">,</button>
        <button class="calculator-btn btn-operator" data-key="add">+</button>
    </div>
</div>

    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>
    
    <script type="module">
	
	const handleExportFilteredCsv = (btn) => {
    // La lista de movimientos a exportar es la que ya tenemos filtrada en db.movimientos
    const movementsToExport = db.movimientos;

    if (movementsToExport.length === 0) {
        showToast("No hay datos para exportar.", "warning");
        return;
    }

    setButtonLoading(btn, true, 'Exportando...');

    try {
        const cuentasMap = new Map(db.cuentas.map(c => [c.id, c.nombre]));
        const conceptosMap = new Map(db.conceptos.map(c => [c.id, c.nombre]));

        const csvHeader = ['FECHA', 'CUENTA', 'CONCEPTO', 'IMPORTE', 'DESCRIPCIÓN'];
        let csvRows = [csvHeader.join(';')];
        
        // Ordenamos los movimientos por fecha para la exportación
        movementsToExport.sort((a, b) => new Date(a.fecha) - new Date(b.fecha));

        for (const mov of movementsToExport) {
            const fecha = formatDateForCsv(mov.fecha);
            const descripcion = `"${mov.descripcion.replace(/"/g, '""')}"`;
            const importeStr = (mov.cantidad / 100).toLocaleString('es-ES', { useGrouping: false, minimumFractionDigits: 2 });
            let cuentaNombre = '';
            let conceptoNombre = '';

            if (mov.tipo === 'traspaso') {
                const origen = cuentasMap.get(mov.cuentaOrigenId) || '?';
                const destino = cuentasMap.get(mov.cuentaDestinoId) || '?';
                cuentaNombre = `"${origen} -> ${destino}"`;
                conceptoNombre = '"TRASPASO"';
            } else {
                cuentaNombre = `"${cuentasMap.get(mov.cuentaId) || 'S/C'}"`;
                conceptoNombre = `"${conceptosMap.get(mov.conceptoId) || 'S/C'}"`;
            }

            csvRows.push([fecha, cuentaNombre, conceptoNombre, importeStr, descripcion].join(';'));
        }

        const csvString = csvRows.join('\r\n');
        const blob = new Blob([`\uFEFF${csvString}`], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `diario_filtrado_${new Date().toISOString().slice(0,10)}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast("Exportación CSV completada.", "info");

    } catch (error) {
        console.error("Error al exportar CSV filtrado:", error);
        showToast("Error durante la exportación.", "danger");
    } finally {
        setButtonLoading(btn, false);
    }
};

	import { addDays, addWeeks, addMonths, addYears, subDays, subWeeks, subMonths, subYears } from 'https://cdn.jsdelivr.net/npm/date-fns@2.29.3/+esm'
        
        const firebaseConfig = { apiKey: "AIzaSyAp-t-2qmbvSX-QEBW9B1aAJHBESqnXy9M", authDomain: "cuentas-aidanai.firebaseapp.com", projectId: "cuentas-aidanai", storageBucket: "cuentas-aidanai.appspot.com", messagingSenderId: "58244686591", appId: "1:58244686591:web:85c87256c2287d350322ca" };
        const PAGE_IDS = {
    INICIO: 'inicio-page',
    DIARIO: 'diario-page',
    INVERSIONES: 'inversiones-page',
    OTROS: 'otros-page', // <-- AÑADIDO
    CONFIGURACION: 'configuracion-page',
};
	const AIDANAI_HELP_CONTENT = {
    [PAGE_IDS.INICIO]: {
        title: "Tu Torre de Control Financiera",
        content: "¡Bienvenido al Panel! Esta es tu vista de pájaro. De un solo vistazo, tienes el pulso de tu situación. <strong>Consejo PRO:</strong> Los 'Widgets' son tus asesores personales. Puedes personalizarlos, reordenarlos y hacer clic en casi todo para ver más detalles. ¡Toca una barra del gráfico para ver la magia!"
    },
    [PAGE_IDS.DIARIO]: {
        title: "El Libro de la Verdad",
        content: "Aquí está cada céntimo registrado. Es tu historial completo, la verdad absoluta de tus finanzas. <strong>Superpoder secreto:</strong> Desliza cualquier movimiento hacia la <strong>derecha para duplicarlo</strong> (ideal para gastos repetidos) o hacia la <strong>izquierda para borrarlo</strong>. ¡Ahorrarás muchísimo tiempo!"
    },
    [PAGE_IDS.INVERSIONES]: {
        title: "Tu Centro de Mando Patrimonial",
        content: "Esta es la joya de la corona, donde tus activos crecen. Sigue el rendimiento de tu portafolio con métricas clave como la <strong>Rentabilidad (P&L)</strong> y la <strong>TIR anualizada</strong>, la métrica que usan los profesionales para saber si una inversión de verdad merece la pena."
    },
    [PAGE_IDS.OTROS]: { // <-- NUEVA ENTRADA
        title: "Herramientas y Utilidades",
        content: "Esta sección agrupa funciones importantes que no usas a diario. Gestiona tus <strong>movimientos recurrentes</strong> para automatizar tu vida y genera <strong>extractos de cuenta</strong> detallados para cualquier cuenta."
    },
    [PAGE_IDS.CONFIGURACION]: {
        title: "La Sala de Máquinas",
        content: "Aquí ajustas la app a tu gusto. No olvides la función más potente: la <strong>Contabilidad Dual (A/B)</strong>. Úsala para separar tus finanzas personales de un proyecto, un negocio, la comunidad de vecinos, ¡o lo que se te ocurra! Es como tener dos apps en una."
    },
    'default': {
        title: "¡Hola! Soy aiDANaI, tu copiloto",
        content: "Mi misión es que tomes el control de tu universo financiero. Haz clic en mi icono en cualquier pantalla para obtener consejos útiles como este, adaptados a donde estés."
    }
};
	const THEMES = {
    'default': { name: 'Ciber-Neón', icon: 'dark_mode' },
    'prismatic-glass': { name: 'Prismático', icon: 'light_mode' }
};
	        
// CÓDIGO CORRECTO Y ÚNICO QUE DEBE QUEDAR EN TU ARCHIVO
// PEGA ESTE BLOQUE ÚNICO Y CORRECTO EN SU LUGAR
	const AVAILABLE_WIDGETS = {
    'super-centro-operaciones': { title: 'Centro de Operaciones', description: 'Visión completa con filtros, KPIs y análisis de conceptos.', icon: 'query_stats' },
    'net-worth-trend': { title: 'Evolución del Patrimonio', description: 'Gráfico histórico de la variación de tu patrimonio neto.', icon: 'show_chart' },
    'patrimonio-structure': { title: 'Patrimonio', description: 'Gráfico interactivo y listado de todas tus cuentas y su peso.', icon: 'account_balance' },
    'action-center': { title: 'Centro de Acciones', description: 'Alertas y tareas pendientes.', icon: 'notifications_active' },
};
 const DEFAULT_DASHBOARD_WIDGETS = [
    'super-centro-operaciones', // <-- El widget principal y más completo
    'net-worth-trend',          // Evolución del Patrimonio
    'patrimonio-structure',     // Desglose del Patrimonio
    'action-center'             // Centro de Acciones (Recurrentes pendientes)
];

const getRecurrentsForDate = (dateString) => {
    const targetDate = parseDateStringAsUTC(dateString);
    if (!targetDate || !db.recurrentes) return [];

    const results = [];
    const targetTime = targetDate.getTime();
    
    db.recurrentes.forEach(r => {
        const nextDate = parseDateStringAsUTC(r.nextDate);
        if (!nextDate) return;

        // Descartamos si el evento ya ha finalizado
        if (r.endDate) {
            const endDate = parseDateStringAsUTC(r.endDate);
            if (targetTime > endDate.getTime()) {
                return;
            }
        }
        
        // La nueva lógica infalible
        let cursorDate = new Date(nextDate);

        if (targetTime === cursorDate.getTime()) {
            results.push(r); // Coincidencia directa
            return;
        }

        // Si la fecha objetivo es POSTERIOR a la próxima fecha, avanzamos
        if (targetTime > cursorDate.getTime()) {
            // Límite de seguridad para evitar bucles infinitos
            const limit = new Date(cursorDate);
            limit.setUTCFullYear(limit.getUTCFullYear() + 10);

            while (cursorDate.getTime() < targetTime && cursorDate.getTime() < limit.getTime()) {
                cursorDate = calculateNextDueDate(cursorDate.toISOString().slice(0, 10), r.frequency);
            }
            if (cursorDate.getTime() === targetTime) {
                results.push(r);
            }
        } 
        // Si la fecha objetivo es ANTERIOR, retrocedemos
        else {
            // Límite de seguridad
            const limit = new Date(cursorDate);
            limit.setUTCFullYear(limit.getUTCFullYear() - 10);
            
            while (cursorDate.getTime() > targetTime && cursorDate.getTime() > limit.getTime()) {
                cursorDate = calculatePreviousDueDate(cursorDate.toISOString().slice(0, 10), r.frequency);
            }
            if (cursorDate.getTime() === targetTime) {
                results.push(r);
            }
        }
    });

    return results;
};

const getInitialDb = () => ({
    cuentas: [], 
    conceptos: [], 
    movimientos: [], 
    recurrentes: [],
    inversiones_historial: [],
    inversion_cashflows: [],
    config: { 
        skipIntro: false,
        dashboardWidgets: DEFAULT_DASHBOARD_WIDGETS,
       
    } 
});
		// ▼▼▼ PEGA ESTE BLOQUE DE CÓDIGO JS ▼▼▼

// Variable global para guardar los filtros activos
let diarioActiveFilters = null;
let allDiarioMovementsCache = []; // Caché para guardar TODOS los movimientos una vez cargados

// Función para abrir y preparar el modal de filtros
const showDiarioFiltersModal = () => {
    showModal('diario-filters-modal');

    // Rellenamos los selectores múltiples de Cuentas y Conceptos
    const populateMultiSelect = (id, data, nameKey, valKey = 'id') => {
        const selectEl = select(id);
        if (!selectEl) return;
        selectEl.innerHTML = [...data]
            .sort((a, b) => (a[nameKey] || "").localeCompare(b[nameKey] || ""))
            .map(item => `<option value="${item[valKey]}">${item[nameKey]}</option>`)
            .join('');
    };
    
    populateMultiSelect('filter-diario-cuentas', getVisibleAccounts(), 'nombre');
    populateMultiSelect('filter-diario-conceptos', db.conceptos, 'nombre');

    // Rellenamos el formulario con los filtros que ya estaban activos (si los hay)
    if (diarioActiveFilters) {
        select('filter-diario-start-date').value = diarioActiveFilters.startDate || '';
        select('filter-diario-end-date').value = diarioActiveFilters.endDate || '';
        select('filter-diario-description').value = diarioActiveFilters.description || '';
        select('filter-diario-min-amount').value = diarioActiveFilters.minAmount || '';
        select('filter-diario-max-amount').value = diarioActiveFilters.maxAmount || '';
        // Reseleccionamos las opciones en los selectores múltiples
        Array.from(select('filter-diario-cuentas').options).forEach(opt => {
            opt.selected = diarioActiveFilters.cuentas?.includes(opt.value);
        });
        Array.from(select('filter-diario-conceptos').options).forEach(opt => {
            opt.selected = diarioActiveFilters.conceptos?.includes(opt.value);
        });
    }
};

// La función que se ejecuta al pulsar "Aplicar Filtros"
const applyDiarioFilters = async () => {
    // Guardamos los valores del formulario en nuestra variable global
    diarioActiveFilters = {
        startDate: select('filter-diario-start-date').value,
        endDate: select('filter-diario-end-date').value,
        description: select('filter-diario-description').value.toLowerCase(),
        minAmount: select('filter-diario-min-amount').value,
        maxAmount: select('filter-diario-max-amount').value,
        cuentas: Array.from(select('filter-diario-cuentas').selectedOptions).map(opt => opt.value),
        conceptos: Array.from(select('filter-diario-conceptos').selectedOptions).map(opt => opt.value)
    };
    
    hideModal('diario-filters-modal');
    hapticFeedback('success');
    showToast('Filtros aplicados. Mostrando resultados.', 'info');
    
    // Volvemos a renderizar la página del Diario para que aplique los filtros
    await renderDiarioPage();
};

// La función que se ejecuta al pulsar "Limpiar Filtros"
const clearDiarioFilters = async () => {
    diarioActiveFilters = null;
    select('diario-filters-form').reset();
    hideModal('diario-filters-modal');
    showToast('Filtros eliminados.', 'info');
    await renderDiarioPage();
};

// ▲▲▲ FIN DEL BLOQUE A PEGAR ▲▲▲
        let currentUser = null, unsubscribeListeners = [], db = getInitialDb(), deselectedAccountTypesFilter = new Set();
		let ptrState = {
			startY: 0,
			isPulling: false,
			distance: 0,
			threshold: 80 // Distancia en píxeles que hay que arrastrar para que se active
		};
		let calculatorKeyboardHandler = null;
		let deselectedInvestmentTypesFilter = new Set();
		let selectedInvestmentTypeFilter = null;
		let intelligentIndex = new Map();
		let syncState = 'synced'; 
		let isOffBalanceMode = false;
        let descriptionIndex = {};
		let globalSearchDebounceTimer = null;
		let newMovementIdToHighlight = null;
		let unsubscribeRecientesListener = null
        const originalButtonTexts = new Map();
        let conceptosChart = null, liquidAssetsChart = null, detailInvestmentChart = null, informesChart = null, assetAllocationChart = null, budgetTrendChart = null, netWorthChart = null;
        let lastScrollTop = null;
        let pageScrollPositions = {};
        let jsonWizardState = {
            file: null,
            data: null,
            preview: {
                counts: {},
                meta: {}
            }
        };
        let isInitialLoadComplete = false;
        let dataLoaded = {
            presupuestos: false,
            recurrentes: false,
            inversiones: false
        };
        
		const MOVEMENTS_PAGE_SIZE = 200;
        let lastVisibleMovementDoc = null; 
        let isLoadingMoreMovements = false; 
        let allMovementsLoaded = false; 
        
        let runningBalancesCache = null;
		let recentMovementsCache = []; // <-- AÑADIR: Caché para los movimientos recientes del dashboard
		        
        const vList = {
			scrollerEl: null, sizerEl: null, contentEl: null, items: [], itemMap: [], 
			heights: {}, 
			renderBuffer: 10, lastRenderedRange: { start: -1, end: -1 }, isScrolling: null
		};
        
       // ▼▼▼ COPIA Y PEGA ESTE BLOQUE ÚNICO EN LUGAR DEL CÓDIGO DE LA CALCULADORA QUE TENGAS ▼▼▼

        let calculatorState = {
            displayValue: '0',
            operand1: null,
            operator: null,
            waitingForNewValue: true,
            targetInput: null,
            isVisible: false, 
            isResultDisplayed: false,
            historyValue: '', // <-- ¡NUEVA PROPIEDAD para guardar la "chuleta"!
        };
        
        // Actualiza el display del historial
        const updateCalculatorHistoryDisplay = () => {
            const historyDisplay = select('calculator-history-display');
            if (historyDisplay) {
                historyDisplay.textContent = calculatorState.historyValue;
            }
        };

        // Mapea las claves a los símbolos visuales
        const getOperatorSymbol = (key) => {
            switch(key) {
                case 'add': return '+';
                case 'subtract': return '−'; // Usamos un guion más estilizado
                case 'multiply': return '×';
                case 'divide': return '÷';
                default: return '';
            }
        };

        // Gestiona qué botón de operador se ve activo
        const updateActiveOperatorButton = () => {
            // Primero, quitamos la clase activa de todos
            selectAll('.calculator-btn.btn-operator').forEach(btn => {
                btn.classList.remove('btn-operator--active');
            });
            
            // Luego, si hay un operador activo, se la añadimos al botón correspondiente
            if (calculatorState.operator) {
                const activeBtn = document.querySelector(`.calculator-btn[data-key="${calculatorState.operator}"]`);
                if (activeBtn) {
                    activeBtn.classList.add('btn-operator--active');
                }
            }
        };      

        const handleCalculatorInput = (key) => {
            hapticFeedback('light');
            let { displayValue, waitingForNewValue, operand1, operator, isResultDisplayed, historyValue } = calculatorState;
            
            if (isResultDisplayed && !['add', 'subtract', 'multiply', 'divide', 'sign'].includes(key)) {
                displayValue = '0';
                isResultDisplayed = false;
                historyValue = ''; // Limpiamos historial al empezar un nuevo cálculo
            }

            const isOperator = ['add', 'subtract', 'multiply', 'divide'].includes(key);

            if (isOperator) {
                if (operand1 !== null && operator !== null && !waitingForNewValue) {
                    calculate();
                    displayValue = calculatorState.displayValue; 
                }
                operand1 = parseFloat(displayValue.replace(',', '.'));
                operator = key;
                historyValue = `${displayValue} ${getOperatorSymbol(operator)}`; // Actualizamos el historial
                waitingForNewValue = true;
                isResultDisplayed = false;
            } else {
                switch(key) {
                    case 'done':
                        hapticFeedback('medium');
                        if (operand1 !== null && operator !== null && !waitingForNewValue) {
                            calculate();
                            displayValue = calculatorState.displayValue;
                        }
                        
                        if (calculatorState.targetInput) {
                            const finalValue = parseFloat(displayValue.replace(',', '.')) || 0;
                            
                            calculatorState.targetInput.value = finalValue.toLocaleString('es-ES', { 
                                useGrouping: false, 
                                minimumFractionDigits: 2, 
                                maximumFractionDigits: 2 
                            });

                            calculatorState.targetInput.dispatchEvent(new Event('input', { bubbles: true }));
                            calculatorState.targetInput.dispatchEvent(new Event('blur')); 
                        }
                        historyValue = '';
                        hideCalculator();
                        select('movimiento-descripcion').focus();
                        return;

                    case 'comma':
                        if (waitingForNewValue) {
                            displayValue = '0,';
                            waitingForNewValue = false;
                        } else if (!displayValue.includes(',')) {
                            displayValue += ',';
                        }
                        isResultDisplayed = false;
                        break;
                    
                    case 'clear': 
                        displayValue = '0'; 
                        waitingForNewValue = true; 
                        operand1 = null; 
                        operator = null; 
                        isResultDisplayed = false; 
                        historyValue = ''; // Limpiamos historial
                        break;

                    case 'backspace': 
                        if (displayValue.length > 1) {
                            displayValue = displayValue.slice(0, -1);
                        } else {
                            displayValue = '0';
                            waitingForNewValue = true;
                        }
                        isResultDisplayed = false;
                        break;

                    case 'sign': 
                        if (displayValue !== '0') { 
                            displayValue = displayValue.startsWith('-') ? displayValue.slice(1) : `-${displayValue}`; 
                        }
                        break;
                        
                    default: // Dígitos
                        if (waitingForNewValue || displayValue === '0') {
                            displayValue = key;
                            waitingForNewValue = false;
                        } else {
                            displayValue += key;
                        }
                        isResultDisplayed = false;
                        break;
                }
            }
            
            // Guardamos todos los cambios en el estado global
            calculatorState.displayValue = displayValue;
            calculatorState.waitingForNewValue = waitingForNewValue;
            calculatorState.operand1 = operand1;
            calculatorState.operator = operator;
            calculatorState.isResultDisplayed = isResultDisplayed;
            calculatorState.historyValue = historyValue;
            
            // Actualizamos toda la interfaz de la calculadora
            updateCalculatorDisplay();
            updateCalculatorHistoryDisplay(); // <-- Llamamos a la nueva función
            updateActiveOperatorButton(); // <-- Y a esta para el estilo
        };

        const calculate = () => {
            const val1 = calculatorState.operand1;
            const val2 = parseFloat(calculatorState.displayValue.replace(',', '.'));
            if (isNaN(val1) || isNaN(val2) || !calculatorState.operator) return;

            let result = 0;
            switch (calculatorState.operator) {
                case 'add': result = val1 + val2; break;
                case 'subtract': result = val1 - val2; break;
                case 'multiply': result = val1 * val2; break;
                case 'divide':
                    if (val2 === 0) {
                        showToast("No se puede dividir por cero.", "danger");
                        result = 0;
                    } else {
                        result = val1 / val2;
                    }
                    break;
            }

            const resultString = parseFloat(result.toPrecision(12)).toString().replace('.', ',');
            
            calculatorState.displayValue = resultString;
            calculatorState.operand1 = null;
            calculatorState.operator = null;
            calculatorState.waitingForNewValue = true;
            calculatorState.isResultDisplayed = true;
        };

// ▲▲▲ FIN DEL BLOQUE ▲▲▲

        let descriptionSuggestionDebounceTimer = null; 
        const DESCRIPTION_SUGGESTION_LIMIT = 5;
        
                    

		let isDashboardRendering = false;
		let dashboardUpdateDebounceTimer = null;
		let diarioViewMode = 'list'; // 'list' o 'calendar'
		let diarioCalendarDate = new Date();
		

async function hashPin(pin) {
    const encoder = new TextEncoder();
    const data = encoder.encode(pin);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function verifyPin(pin, storedHash) {
    const pinHash = await hashPin(pin);
    return pinHash === storedHash;
}

const updateSyncStatusIcon = () => {
    const iconEl = select('sync-status-icon');
    if (!iconEl) return;

    let iconName = '';
    let iconTitle = '';
    let iconClass = '';

    switch (syncState) {
        case 'syncing':
            iconName = `<span class="sync-icon-spinner">sync</span>`;
            iconTitle = 'Sincronizando datos con la nube...';
            iconClass = 'sync-status--syncing';
            break;
        case 'error':
            iconName = 'cloud_off';
            iconTitle = 'Error de conexión. Tus cambios se guardan localmente y se sincronizarán al recuperar la conexión.';
            iconClass = 'sync-status--error';
            break;
        case 'synced':
        default:
            iconName = 'cloud_done';
            iconTitle = 'Todos los datos están guardados y sincronizados en la nube.';
            iconClass = 'sync-status--synced';
            break;
    }
    
    iconEl.innerHTML = iconName;
    iconEl.title = iconTitle;
    iconEl.className = `material-icons ${iconClass}`;
};
                const buildDescriptionIndex = () => {
            descriptionIndex = {};
            if (!db.movimientos || db.movimientos.length === 0) return;

            const movementsToIndex = db.movimientos.slice(0, 500); 

            movementsToIndex.forEach(mov => {
                const desc = mov.descripcion.trim().toLowerCase();
                if (desc.length > 3) {
                    if (!descriptionIndex[desc]) {
                        descriptionIndex[desc] = {
                            conceptoId: mov.conceptoId,
                            count: 0
                        };
                    }
                    descriptionIndex[desc].count++;
                }
            });
        };
               
    
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        fbAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
        const fbDb = firebase.firestore();
        
        fbDb.enablePersistence({synchronizeTabs: true}).catch(err => {
            if (err.code == 'failed-precondition') showToast('Modo offline no disponible (múltiples pestañas).', 'warning');
            else if (err.code == 'unimplemented') showToast('Navegador no soporta modo offline.', 'warning');
        });
        
async function saveDoc(collectionName, docId, data, btn = null) {
    if (!currentUser) { showToast("Error: No hay usuario.", "danger"); return; }
    if (btn) setButtonLoading(btn, true);

    syncState = 'syncing';
    updateSyncStatusIcon();

    try {
        const docRef = fbDb.collection('users').doc(currentUser.uid).collection(collectionName).doc(docId);
        await docRef.set(data, { merge: true });
        
        await fbDb.waitForPendingWrites();

        syncState = 'synced';
        
    } catch (error) {
        console.error(`Error guardando en ${collectionName}:`, error);
        showToast("Error al guardar.", "danger");
        syncState = 'error';
    } finally {
        if (btn) setButtonLoading(btn, false);
        updateSyncStatusIcon();
    }
}


        async function updateAccountBalance(cuentaId, amountInCents) {
            if (!currentUser || !cuentaId || typeof amountInCents !== 'number') {
                console.error("Argumentos inválidos para updateAccountBalance");
                return;
            }

            try {
                const accountRef = fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(cuentaId);
                await accountRef.update({
                    saldo: firebase.firestore.FieldValue.increment(amountInCents)
                });
            } catch (error) {
                console.error(`Error al actualizar saldo de la cuenta ${cuentaId}:`, error);
                showToast("Error crítico: no se pudo actualizar el saldo.", "danger");
            }
        }
        
                
        async function deleteDoc(collectionName, docId) {
    if (!currentUser) { showToast("Error: No hay usuario.", "danger"); return; }
    
    syncState = 'syncing';
    updateSyncStatusIcon();

    try {
        await fbDb.collection('users').doc(currentUser.uid).collection(collectionName).doc(docId).delete();
        await fbDb.waitForPendingWrites();
        syncState = 'synced';
    } catch (error) {
        console.error(`Error borrando de ${collectionName}:`, error);
        showToast("Error al borrar.", "danger");
        syncState = 'error';
    } finally {
        updateSyncStatusIcon();
    }
}
        
 // REEMPLAZA tu función loadCoreData por esta versión actualizada
async function loadCoreData(uid) {
    unsubscribeListeners.forEach(unsub => unsub());
    unsubscribeListeners = [];
    
    const userRef = fbDb.collection('users').doc(uid);

    const collectionsToLoadInitially = ['cuentas', 'conceptos', 'recurrentes'];

    collectionsToLoadInitially.forEach(collectionName => {
        const unsubscribe = userRef.collection(collectionName).onSnapshot(snapshot => {
            db[collectionName] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            if (collectionName === 'recurrentes') {
                dataLoaded.recurrentes = true;
                const activePage = document.querySelector('.view--active');
                if (activePage && (activePage.id === PAGE_IDS.DIARIO)) renderDiarioPage();
                if (activePage && (activePage.id === PAGE_IDS.OTROS)) renderOtrosPage();
            }
            
            populateAllDropdowns();
            
            if (select(PAGE_IDS.INICIO)?.classList.contains('view--active')) scheduleDashboardUpdate();
            
        }, error => console.error(`Error escuchando ${collectionName}: `, error));
        unsubscribeListeners.push(unsubscribe);
    });

    const unsubConfig = userRef.onSnapshot(doc => {
        db.config = doc.exists && doc.data().config ? doc.data().config : getInitialDb().config;
        localStorage.setItem('skipIntro', (db.config && db.config.skipIntro) || 'false');
        loadConfig();
    }, error => console.error("Error escuchando la configuración del usuario: ", error));
    unsubscribeListeners.push(unsubConfig);

    // =====================================================================
    // === INICIO: LÓGICA DE CARGA INTELIGENTE PARA EL DASHBOARD (EL MANANTIAL) ===
    // =====================================================================
    // Desconectamos cualquier listener anterior para evitar duplicados al iniciar sesión de nuevo.
    if (unsubscribeRecientesListener) unsubscribeRecientesListener();

    // Creamos una consulta para los últimos 3 meses de movimientos. Esto es suficiente
    // para los cálculos de "vs mes anterior" y "vs año anterior" del dashboard.
    const threeMonthsAgo = new Date();
    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
    
    // Este listener mantendrá nuestra caché `recentMovementsCache` siempre actualizada en tiempo real.
    unsubscribeRecientesListener = userRef.collection('movimientos')
        .where('fecha', '>=', threeMonthsAgo.toISOString())
        .onSnapshot(snapshot => {
            console.log("Listener de recientes: Datos actualizados en la caché.");
            // Actualizamos la caché con los datos más frescos.
            recentMovementsCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // Si el usuario está en la página de Inicio, la actualizamos inmediatamente.
            const activePage = document.querySelector('.view--active');
            if (activePage && activePage.id === PAGE_IDS.INICIO) {
                scheduleDashboardUpdate();
            }
        }, error => console.error("Error escuchando movimientos recientes: ", error));
    // ===================================================================
    // === FIN: LÓGICA DE CARGA INTELIGENTE ==============================
    // ===================================================================
                        
    buildDescriptionIndex();
    startMainApp();
};

 
        async function loadInversiones() {
    if (dataLoaded.inversiones || !currentUser) return Promise.resolve();

    console.log("Lazy loading: Cargando datos de inversión (y esperando)...");

    const coleccionesInversion = ['inversiones_historial', 'inversion_cashflows'];
    
    const promises = coleccionesInversion.map(collectionName => {
        return new Promise((resolve, reject) => {
            let firstLoad = true;
            const unsub = fbDb.collection('users').doc(currentUser.uid).collection(collectionName).onSnapshot(snapshot => {
                db[collectionName] = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                if (firstLoad) {
                    firstLoad = false;
                    resolve(); // ¡Promesa cumplida para este tipo de dato!
                }
            }, err => {
                console.error(`Error al cargar ${collectionName}:`, err);
                reject(err);
            });
            unsubscribeListeners.push(unsub);
        });
    });

    await Promise.all(promises);

    dataLoaded.inversiones = true;

    }
    const checkAuthState = () => {
            fbAuth.onAuthStateChanged((user) => {
                if (user) {
                    const storedPinHash = localStorage.getItem('pinUserHash');
                    const storedPinEmail = localStorage.getItem('pinUserEmail');

                    if (storedPinHash && storedPinEmail === user.email) {
                        showPinScreen(user);
                    } else {
                        currentUser = user;
                        loadCoreData(user.uid);
                    }
                } else {
                    currentUser = null;
                    unsubscribeListeners.forEach(unsub => unsub());
                    unsubscribeListeners = [];
                    db = getInitialDb();
                    showLoginScreen();
                }
            });
        };

        const calculateNextDueDate = (currentDueDate, frequency) => {
            const d = new Date(currentDueDate);
            d.setHours(12, 0, 0, 0); 
        
            switch (frequency) {
                case 'daily': return addDays(d, 1);
                case 'weekly': return addWeeks(d, 1);
                case 'monthly': return addMonths(d, 1);
                case 'yearly': return addYears(d, 1);
                default: return d;
            }
        };
        
		const select = (id) => document.getElementById(id);
		const selectAll = (s) => document.querySelectorAll(s);
		const selectOne = (s) => document.querySelector(s);
        const isMobileDevice = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
		const chunkArray = (array, size) => {
			const chunks = [];
			for (let i = 0; i < array.length; i += size) {
				chunks.push(array.slice(i, i + size));
			}
			return chunks;
		};
		const measureListItemHeights = () => {
    // Ya no medimos nada. Usamos valores fijos basados en el CSS.
    // Es un "contrato" entre nuestro estilo y nuestro código.
    vList.heights = {
        transaction: 64, // Coincide con el min-height que pusimos en el CSS
        transfer: 76,    // Valor estimado para traspasos, puedes ajustarlo
        header: 40,      // Valor estimado para cabeceras
        pendingHeader: 40, // Valor estimado
        pendingItem: 72    // Valor estimado
    };
    
    console.log('Alturas de elementos definidas (Robusto):', vList.heights);
};
        const hapticFeedback = (type = 'light') => {
            if ('vibrate' in navigator) {
                try {
                    let pattern;
                    switch (type) {
                        case 'light':   pattern = 10; break;
                        case 'medium':  pattern = 25; break;
                        case 'success': pattern = [15, 60, 15]; break;
                        case 'warning': pattern = [30, 40, 30]; break;
                        case 'error':   pattern = [50, 50, 50]; break;
                        default:        pattern = 10;
                    }
                    navigator.vibrate(pattern);
                } catch (e) {}
            }
        };

        const parseDateStringAsUTC = (dateString) => {
            if (!dateString) return null;
            return new Date(dateString + 'T12:00:00Z');
        };
		const generateReportFilterControls = (reportId, defaultPeriod = 'año-actual') => {
    return `
        <div class="report-filters" data-report-id="${reportId}" style="margin-bottom: var(--sp-4); padding: var(--sp-3); background-color: var(--c-surface-variant); border-radius: var(--border-radius-md);">
            <div class="form-group" style="margin-bottom: var(--sp-2);">
                <label for="filter-periodo-${reportId}" class="form-label" style="margin-bottom: var(--sp-1);">Seleccionar Periodo</label>
                <select id="filter-periodo-${reportId}" class="form-select report-period-selector">
                    <option value="mes-actual" ${defaultPeriod === 'mes-actual' ? 'selected' : ''}>Este Mes</option>
                    <option value="año-actual" ${defaultPeriod === 'año-actual' ? 'selected' : ''}>Este Año</option>
                    <option value="ultimo-año" ${defaultPeriod === 'ultimo-año' ? 'selected' : ''}>Últimos 12 Meses</option>
                    <option value="custom">Personalizado</option>
                </select>
            </div>
            <div id="custom-date-filters-${reportId}" class="form-grid hidden" style="grid-template-columns: 1fr 1fr; gap: var(--sp-2);">
                <div class="form-group" style="margin-bottom: 0;">
                    <label for="filter-fecha-inicio-${reportId}" class="form-label" style="font-size: var(--fs-xs);">Desde</label>
                    <input type="date" id="filter-fecha-inicio-${reportId}" class="form-input">
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label for="filter-fecha-fin-${reportId}" class="form-label" style="font-size: var(--fs-xs);">Hasta</label>
                    <input type="date" id="filter-fecha-fin-${reportId}" class="form-input">
                </div>
            </div>
        </div>`;
};

	/**
 * Obtiene las fechas de inicio y fin basadas en un selector de periodo de informe.
 * @param {string} reportId - El ID del informe.
 * @returns {{sDate: Date, eDate: Date}} Un objeto con las fechas de inicio y fin.
 */
const getDatesFromReportFilter = (reportId) => {
    const periodSelector = select(`filter-periodo-${reportId}`);
    if (!periodSelector) return { sDate: null, eDate: null };

    const p = periodSelector.value;
    let sDate, eDate;
    const now = new Date();
    now.setHours(0, 0, 0, 0);

    switch (p) {
        case 'mes-actual':
            sDate = new Date(now.getFullYear(), now.getMonth(), 1);
            eDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
            break;
        case 'año-actual':
            sDate = new Date(now.getFullYear(), 0, 1);
            eDate = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999);
            break;
        case 'ultimo-año':
            eDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
            sDate = new Date(now);
            sDate.setFullYear(sDate.getFullYear() - 1);
            sDate.setDate(sDate.getDate() + 1);
            sDate.setHours(0,0,0,0);
            break;
        case 'custom':
            const startInput = select(`filter-fecha-inicio-${reportId}`);
            const endInput = select(`filter-fecha-fin-${reportId}`);
            sDate = startInput?.value ? parseDateStringAsUTC(startInput.value) : null;
            eDate = endInput?.value ? parseDateStringAsUTC(endInput.value) : null;
            if (eDate) eDate.setUTCHours(23, 59, 59, 999);
            break;
    }
    return { sDate, eDate };
};


/**
 * REVISADO: Calcula el impacto real de un movimiento en el flujo de caja,
 * asegurándose de que la cuenta del movimiento está visible.
 * @param {object} mov - El objeto de movimiento.
 * @param {Set<string>} visibleAccountIds - Un Set con los IDs de las cuentas visibles.
 * @returns {number} La cantidad en céntimos del impacto del movimiento.
 */
const calculateMovementAmount = (mov, visibleAccountIds) => {
    let amount = 0;
    if (mov.tipo === 'movimiento') {
        // CORRECCIÓN CLAVE: Solo se suma si la cuenta del movimiento pertenece a la contabilidad visible.
        if (visibleAccountIds.has(mov.cuentaId)) {
            amount = mov.cantidad;
        }
    } else if (mov.tipo === 'traspaso') {
        const origenVisible = visibleAccountIds.has(mov.cuentaOrigenId);
        const destinoVisible = visibleAccountIds.has(mov.cuentaDestinoId);
        // Si el traspaso es entre contabilidades, solo contamos la parte que entra o sale.
        if (origenVisible && !destinoVisible) amount = -mov.cantidad; // Sale dinero
        else if (!origenVisible && destinoVisible) amount = mov.cantidad; // Entra dinero
        // Si es un traspaso interno (ambas visibles) o externo (ninguna visible), el impacto es 0.
    }
    return amount;
};

/**
 * REVISADO: Función central para calcular totales de ingresos/gastos/neto.
 * Ahora utiliza la función 'calculateMovementAmount' corregida.
 * @param {Array<object>} movs - Array de movimientos a procesar.
 * @param {Set<string>} visibleAccountIds - Set de IDs de cuentas visibles.
 * @returns {{ingresos: number, gastos: number, saldoNeto: number}}
 */
const calculateTotals = (movs, visibleAccountIds) => {
    return movs.reduce((acc, mov) => {
        const amount = calculateMovementAmount(mov, visibleAccountIds);
        if (amount > 0) acc.ingresos += amount;
        else acc.gastos += amount;
        acc.saldoNeto += amount;
        return acc;
    }, { ingresos: 0, gastos: 0, saldoNeto: 0 });
};
// --- ACTUALIZAR EL EVENT LISTENER ---
// Añadir un nuevo listener para el evento 'change' en los selectores de los informes
document.body.addEventListener('change', e => {
    if (e.target.classList.contains('report-period-selector')) {
        const reportId = e.target.closest('.report-filters').dataset.reportId;
        const customFilters = select(`custom-date-filters-${reportId}`);
        if (customFilters) customFilters.classList.toggle('hidden', e.target.value !== 'custom');
        
        // Si no es personalizado, se regenera el informe inmediatamente
        if (e.target.value !== 'custom') {
            renderInformeDetallado(reportId);
        }
    }
    // Añadir un listener para los inputs de fecha personalizados
    if (e.target.type === 'date' && e.target.id.startsWith('filter-fecha-')) {
        const reportId = e.target.closest('.report-filters').dataset.reportId;
        const startDate = select(`filter-fecha-inicio-${reportId}`).value;
        const endDate = select(`filter-fecha-fin-${reportId}`).value;
        if(startDate && endDate) {
             renderInformeDetallado(reportId);
        }
    }
});


        const generateId = () => fbDb.collection('users').doc().id;
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        const formatCurrency = (numInCents) => {
    const number = (numInCents || 0) / 100;
    return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(number);
};

// ▼▼▼ PÉGALA AQUÍ ▼▼▼
const showToast = (message, type = 'info', duration = 3000) => {
    const container = select('toast-container');
    if (!container) return;

    const toast = document.createElement('div');
    toast.className = `toast toast--${type}`;
    toast.textContent = message;
    toast.setAttribute('role', 'alert');
    
    requestAnimationFrame(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateY(0)';
    });
    
    container.appendChild(toast);

    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(10px)';
        toast.addEventListener('transitionend', () => toast.remove());
    }, duration);
};
// ▲▲▲ AQUÍ TERMINA LA FUNCIÓN PEGADA ▲▲▲
// ▼▼▼ PEGA ESTE BLOQUE DE CÓDIGO JS EN TU SCRIPT ▼▼▼
   // Variable global para guardar a nuestro "asistente"
let widgetObserver = null;

/**
 * Esta es la función que se llamará cuando un esqueleto entre en la pantalla.
 * Es como la orden que le damos al asistente: "¡Enciende esta luz!".
 */
const lazyLoadWidget = async (widgetElement) => {
    const widgetType = widgetElement.dataset.widgetType;
    if (!widgetType) return;

    // Marcamos el widget como "cargando" para evitar que se cargue dos veces
    widgetElement.dataset.widgetType = 'loading';
    
    // Le ponemos un spinner para que el usuario vea que algo pasa
    widgetElement.classList.add('widget--loading');
    const spinner = document.createElement('div');
    spinner.className = 'widget-spinner';
    spinner.innerHTML = '<span class="spinner" style="width: 28px; height: 28px;"></span>';
    widgetElement.prepend(spinner);

    // Dependiendo de la "etiqueta" del widget, llamamos a la función de carga correcta.
    // Usaremos la función 'updateDashboardData' que ya tienes, que es muy potente.
    try {
        await updateDashboardData(); // Esta función ya sabe cómo rellenar todos los widgets
    } catch(error) {
        console.error(`Error al cargar el widget ${widgetType}:`, error);
        widgetElement.innerHTML = `<div class="empty-state text-danger"><p>Error al cargar este widget.</p></div>`;
    } finally {
        // Una vez cargado, quitamos el spinner y la clase de carga.
        widgetElement.classList.remove('widget--loading');
        spinner.remove();
    }
};

/**
 * Esta función crea y activa a nuestro "asistente".
 * Le dice qué elementos tiene que vigilar.
 */
const initWidgetObserver = () => {
    // Si ya teníamos un asistente, lo despedimos para contratar uno nuevo y limpio.
    if (widgetObserver) {
        widgetObserver.disconnect();
    }

    const options = {
        root: selectOne('.app-layout__main'), // Observa el scroll dentro del contenedor principal
        rootMargin: '150px', // Empieza a cargar el widget cuando esté a 150px de entrar en pantalla
        threshold: 0.01 // Se activa en cuanto un 1% del widget sea visible
    };

    // Creamos el asistente y le decimos qué hacer cuando vea algo.
    widgetObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            // Si el elemento que estamos vigilando (entry.target) está ahora visible...
            if (entry.isIntersecting) {
                const widgetElement = entry.target;
                
                // Le damos la orden de cargar su contenido.
                lazyLoadWidget(widgetElement);
                
                // Le decimos al asistente que deje de vigilar este elemento, ¡su trabajo aquí ha terminado!
                observer.unobserve(widgetElement);
            }
        });
    }, options);

    // Finalmente, le damos al asistente la lista de todos los esqueletos que tiene que vigilar.
    const widgetsToLoad = document.querySelectorAll('[data-widget-type]');
    widgetsToLoad.forEach(widget => {
        widgetObserver.observe(widget);
    });
};

// ▲▲▲ FIN DEL BLOQUE A PEGAR ▲▲▲
        const toSentenceCase = (str) => {
			if (!str || typeof str !== 'string') return '';
			return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
		};

        const setButtonLoading = (btn, isLoading, text = 'Cargando...') => {
            if (!btn) return;
            if (isLoading) { if (!originalButtonTexts.has(btn)) originalButtonTexts.set(btn, btn.innerHTML); btn.setAttribute('disabled', 'true'); btn.classList.add('btn--loading'); btn.innerHTML = `<span class="spinner"></span> <span>${text}</span>`;
            } else { btn.removeAttribute('disabled'); btn.classList.remove('btn--loading'); if (originalButtonTexts.has(btn)) { btn.innerHTML = originalButtonTexts.get(btn); originalButtonTexts.delete(btn); } }
        };
		// --- PEGA ESTA NUEVA FUNCIÓN COMPLETA EN TU JAVASCRIPT ---

/**
 * Dispara una animación de una "burbuja" que viaja desde un elemento
 * hasta la parte superior de la lista de movimientos.
 * @param {HTMLElement} fromElement - El elemento desde donde empieza la animación (ej. el botón Guardar).
 * @param {string} color - 'green' para ingresos, 'red' para gastos.
 */
const triggerSaveAnimation = (fromElement, color) => {
    if (!fromElement) return;

    // 1. Encuentra el punto de partida y el de llegada.
    const startRect = fromElement.getBoundingClientRect();
    const listElement = select('movimientos-list-container') || select('diario-page');
    const endRect = listElement.getBoundingClientRect();

    // 2. Calcula las coordenadas iniciales (el centro del botón).
    const startX = startRect.left + startRect.width / 2;
    const startY = startRect.top + startRect.height / 2;

    // 3. Calcula las coordenadas finales (el centro superior de la lista).
    const endX = endRect.left + endRect.width / 2;
    const endY = endRect.top;

    // 4. Crea el elemento "burbuja" en el DOM.
    const bubble = document.createElement('div');
    bubble.className = 'save-animation-bubble';
    
    // 5. Le da el color y la posición inicial.
    const bubbleColor = color === 'green' ? 'var(--c-success)' : 'var(--c-danger)';
    bubble.style.backgroundColor = bubbleColor;
    bubble.style.left = `${startX - 10}px`; // Restamos la mitad de su tamaño (20px / 2)
    bubble.style.top = `${startY - 10}px`;

    document.body.appendChild(bubble);

    // 6. ¡LA MAGIA! Forzamos un 'reflow' para que el navegador aplique el estado inicial antes de animar.
    void bubble.offsetWidth; 

    // La animación durará 0.7 segundos y se moverá a las coordenadas finales.
    bubble.style.animation = `fly-to-list 0.7s cubic-bezier(0.5, 0, 1, 0.5) forwards`;
    bubble.style.transform = `translate(${endX - startX}px, ${endY - startY}px) scale(0)`;
    
    // 7. Limpieza: Cuando la animación termina, eliminamos la burbuja del DOM.
    bubble.addEventListener('animationend', () => {
        bubble.remove();
    }, { once: true });
};
        const displayError = (id, msg) => { const err = select(`${id}-error`); if (err) { err.textContent = msg; err.setAttribute('role', 'alert'); } const inp = select(id); if (inp) inp.classList.add('form-input--invalid'); };
        const clearError = (id) => { const err = select(`${id}-error`); if (err) { err.textContent = ''; err.removeAttribute('role'); } const inp = select(id); if (inp) inp.classList.remove('form-input--invalid'); };
        const clearAllErrors = (formId) => { const f = select(formId); if (!f) return; f.querySelectorAll('.form-error').forEach((e) => e.textContent = ''); f.querySelectorAll('.form-input--invalid').forEach(e => e.classList.remove('form-input--invalid')); };
        const animateCountUp = (el, end, duration = 700, formatAsCurrency = true, prefix = '', suffix = '') => {
            if (!el) return;
            const start = parseFloat(el.dataset.currentValue || '0');
            const endValue = end / 100;
            if (start === endValue || !el.offsetParent) { el.textContent = formatAsCurrency ? formatCurrency(end) : `${prefix}${end}${suffix}`; el.dataset.currentValue = String(endValue); return; }
            el.dataset.currentValue = String(endValue); let startTime = null;
            const step = (timestamp) => { if (!startTime) startTime = timestamp; const p = Math.min((timestamp - startTime) / duration, 1); const current = p * (end - start*100) + start*100; el.textContent = formatAsCurrency ? formatCurrency(current) : `${prefix}${current.toFixed(2)}${suffix}`; if (p < 1) requestAnimationFrame(step); else el.textContent = formatAsCurrency ? formatCurrency(end) : `${prefix}${end/100}${suffix}`; };
            requestAnimationFrame(step);
        };
        const escapeHTML = str => (str || '').replace(/[&<>"']/g, match => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[match]);
        
        const parseCurrencyString = (str) => {
            if (typeof str !== 'string' || !str.trim()) return NaN;
            
            let cleanStr = str.replace(/[€$£\s]/g, '');

            const hasComma = cleanStr.includes(',');
            const hasPeriod = cleanStr.includes('.');

            if (hasComma && hasPeriod) {
                if (cleanStr.lastIndexOf(',') > cleanStr.lastIndexOf('.')) {
                    cleanStr = cleanStr.replace(/\./g, '').replace(',', '.');
                } else {
                    cleanStr = cleanStr.replace(/,/g, '');
                }
            } else if (hasComma) {
                cleanStr = cleanStr.replace(',', '.');
            }
            
            return parseFloat(cleanStr);
        };
		const formatAsCurrencyInput = (num) => {
    if (isNaN(num)) return '';
    // Usamos Intl.NumberFormat que es la forma moderna y correcta de hacerlo.
    return new Intl.NumberFormat('es-ES', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
        useGrouping: true // ¡Esta es la opción clave!
    }).format(num);
};
		const showPinScreen = (user) => {
            currentUser = user;
            const pinScreen = select('pin-login-screen');
            const loginScreen = select('login-screen');
            const appRoot = select('app-root');

            if (appRoot) appRoot.classList.remove('app-layout--visible');
            if (loginScreen) loginScreen.classList.remove('login-view--visible');
            if (pinScreen) pinScreen.classList.add('login-view--visible');
            
            const pinInputs = selectAll('#pin-inputs-container .pin-input');
            pinInputs.forEach(input => input.value = '');
            (select('pin-error')).textContent = '';
            if (pinInputs.length > 0) pinInputs[0].focus();
        };

        const handlePinSubmit = async () => {
            const pinInputs = selectAll('#pin-inputs-container .pin-input');
            const pin = Array.from(pinInputs).map(input => input.value).join('');
            const errorEl = select('pin-error');
            
            if (pin.length !== 4) {
                errorEl.textContent = 'El PIN debe tener 4 dígitos.';
                return;
            }

            const storedHash = localStorage.getItem('pinUserHash');
            const isValid = await verifyPin(pin, storedHash);

            if (isValid) {
                hapticFeedback('success');
                loadCoreData(currentUser.uid);
            } else {
                hapticFeedback('error');
                errorEl.textContent = 'PIN incorrecto. Inténtalo de nuevo.';
                pinInputs.forEach(input => input.value = '');
                pinInputs[0].focus();
            }
        };
    const handleKpiDrilldown = async (kpiButton) => {
    const type = kpiButton.dataset.type;
    if (!type) return;

    hapticFeedback('light');
    showGenericModal('Cargando detalles...', `<div style="text-align:center; padding: var(--sp-5);"><span class="spinner"></span></div>`);

    const { current } = await getFilteredMovements(false);
    
    let movementsToShow = [];
    let modalTitle = '';

    switch (type) {
        case 'ingresos':
            modalTitle = 'Ingresos del Periodo';
            movementsToShow = current.filter(m => calculateMovementAmount(m, new Set(getVisibleAccounts().map(c => c.id))) > 0);
            break;
        case 'gastos':
            modalTitle = 'Gastos del Periodo';
            movementsToShow = current.filter(m => calculateMovementAmount(m, new Set(getVisibleAccounts().map(c => c.id))) < 0);
            break;
        case 'saldoNeto':
            modalTitle = 'Todos los Movimientos del Periodo';
            movementsToShow = current;
            break;
        default:
            hideModal('generic-modal');
            return;
    }

    // ¡USAMOS NUESTRA FUNCIÓN MAESTRA OTRA VEZ!
    if (movementsToShow.length > 0) {
        recalculateAndApplyRunningBalances(movementsToShow, db.cuentas);
    }

    // Y ahora llamamos a la función que muestra la lista.
    showDrillDownModal(modalTitle, movementsToShow);
};
        const handlePinInputInteraction = () => {
            const inputs = Array.from(selectAll('#pin-inputs-container .pin-input'));
            inputs.forEach((input, index) => {
                input.addEventListener('keydown', (e) => {
                    if (e.key >= 0 && e.key <= 9) {
                        inputs[index].value = '';
                        setTimeout(() => {
                           if (index < inputs.length - 1) {
                                inputs[index + 1].focus();
                           } else {
                               handlePinSubmit();
                           }
                        }, 10);
                    } else if (e.key === 'Backspace') {
                        if (index > 0) {
                            setTimeout(() => inputs[index - 1].focus(), 10);
                        }
                    }
                });
            });
        };
    const initApp = async () => {
    // Esta es la función que realmente carga el resto de la aplicación.
    const procederConCargaDeApp = () => {
        document.documentElement.lang = 'es';
        setupTheme();
        const savedTheme = localStorage.getItem('appTheme') || 'default';
        document.body.dataset.theme = savedTheme;
        updateThemeIcon();
        attachEventListeners();
        checkAuthState(); // ¡La llamada clave está aquí!
    };

    // LLAMAMOS DIRECTAMENTE A LA CARGA DE LA APP, IGNORANDO EL VÍDEO
    procederConCargaDeApp();
};

		window.addEventListener('online', () => {
    console.log("Conexión recuperada. Sincronizando...");
    syncState = 'syncing';
    updateSyncStatusIcon();
    setTimeout(() => {
        syncState = 'synced';
        updateSyncStatusIcon();
    }, 2500);
});

window.addEventListener('offline', () => {
    console.log("Se ha perdido la conexión.");
    syncState = 'error';
    updateSyncStatusIcon();
});
    const startMainApp = async () => {
            const loginScreen = select('login-screen');
            const pinLoginScreen = select('pin-login-screen');
            const appRoot = select('app-root');

            if (loginScreen) loginScreen.classList.remove('login-view--visible');
            if (pinLoginScreen) pinLoginScreen.classList.remove('login-view--visible');
            if (appRoot) appRoot.classList.add('app-layout--visible');
            
            populateAllDropdowns();
            loadConfig();
            
            measureListItemHeights();
            
            updateSyncStatusIcon();
            buildIntelligentIndex();
			navigateTo(PAGE_IDS.INICIO, true);
            updateThemeIcon(localStorage.getItem('appTheme') || 'default');
            isInitialLoadComplete = true;
			};

        
    const showLoginScreen = () => {
        const loginScreen = select('login-screen');
        const pinLoginScreen = select('pin-login-screen');
        const appRoot = select('app-root');
        if (appRoot) appRoot.classList.remove('app-layout--visible');
        if (pinLoginScreen) pinLoginScreen.classList.remove('login-view--visible');
        if (loginScreen) loginScreen.classList.add('login-view--visible');
    };
	
    const showPasswordFallback = () => {
    hapticFeedback('light');
    const pinScreen = select('pin-login-screen');
    if (!pinScreen) return;

    pinScreen.querySelector('.pin-inputs').classList.add('hidden');
    pinScreen.querySelector('[data-action="use-password-instead"]').parentElement.classList.add('hidden');
    
    pinScreen.querySelector('.login-view__tagline').textContent = 'Introduce tu contraseña para continuar.';
    
    const form = pinScreen.querySelector('form');
    const passwordContainer = document.createElement('div');
    passwordContainer.innerHTML = `
        <div class="form-group form-group--with-icon" style="margin-top: 1.5rem;">
            <span class="material-icons">lock</span>
            <input type="password" id="pin-fallback-password" class="form-input" placeholder="Contraseña" required>
        </div>
        <button type="submit" class="btn btn--primary btn--full" style="margin-top: 1rem;">Verificar</button>
    `;
    form.appendChild(passwordContainer);
    select('pin-fallback-password').focus();

    form.onsubmit = async (e) => {
        e.preventDefault();
        const btn = e.target.querySelector('button[type="submit"]');
        setButtonLoading(btn, true);

        const password = select('pin-fallback-password').value;
        const errorEl = select('pin-error');
        errorEl.textContent = '';

        try {
            const credential = firebase.auth.EmailAuthProvider.credential(currentUser.email, password);
            await currentUser.reauthenticateWithCredential(credential);
            
            startMainApp(); 

        } catch (error) {
            errorEl.textContent = 'Contraseña incorrecta.';
            hapticFeedback('error');
        } finally {
            setButtonLoading(btn, false);
        }
    };
};
         
        const handleLogin = (btn) => {
            const email = (select('login-email')).value.trim(), password = (select('login-password')).value, errEl = select('login-error'); clearAllErrors('login-form'); if(errEl) errEl.textContent = ''; let v = true;
            if (!email) { displayError('login-email', 'El correo es obligatorio.'); v = false; }
            if (!password) { displayError('login-password', 'La contraseña es obligatoria.'); v = false; }
            if (!v) return; setButtonLoading(btn, true, 'Iniciando...');
            fbAuth.signInWithEmailAndPassword(email, password).then(() => showToast(`¡Bienvenido/a de nuevo!`)).catch((err) => { setButtonLoading(btn, false); if (['auth/wrong-password', 'auth/user-not-found', 'auth/invalid-credential'].includes(err.code)) (errEl).textContent = 'Error: Credenciales incorrectas.'; else if (err.code === 'auth/invalid-email') displayError('login-email', 'Formato de correo no válido.'); else (errEl).textContent = 'Error al iniciar sesión.'; });
        };
        const handleRegister = (btn) => {
            const email = (select('login-email')).value.trim(), password = (select('login-password')).value, errEl = select('login-error'); clearAllErrors('login-form'); if(errEl) errEl.textContent = ''; let v = true;
            if (!email) { displayError('login-email', 'El correo es obligatorio.'); v = false; }
            if (password.length < 6) { displayError('login-password', 'La contraseña debe tener al menos 6 caracteres.'); v = false; }
            if (!v) return; setButtonLoading(btn, true, 'Registrando...');
            fbAuth.createUserWithEmailAndPassword(email, password).then(() => showToast(`¡Registro completado!`)).catch((err) => { setButtonLoading(btn, false); if (err.code == 'auth/weak-password') displayError('login-password', 'La contraseña debe tener al menos 6 caracteres.'); else if (err.code == 'auth/email-already-in-use') displayError('login-email', 'El correo ya está registrado.'); else if (err.code === 'auth/invalid-email') displayError('login-email', 'Formato de correo no válido.'); else (errEl).textContent = 'Error en el registro.'; });
        };
        const handleExitApp = () => {
            const exitScreen = select('exit-screen');
            const appRoot = select('app-root');

            if (exitScreen) {
                exitScreen.style.display = 'flex';
                setTimeout(() => exitScreen.style.opacity = '1', 50);

                if (isInitialLoadComplete && appRoot) {
                    appRoot.classList.add('app-layout--transformed-by-modal');
                }
            }
        };
        const destroyAllCharts = () => {
    const charts = [
    conceptosChart, liquidAssetsChart, detailInvestmentChart,
    assetAllocationChart, budgetTrendChart, netWorthChart, informeActivoChart
];

    for (let i = 0; i < charts.length; i++) {
        if (charts[i]) {
            charts[i].destroy();
            // Sobrescribimos la variable global para asegurarnos de que se limpia.
            switch (i) {
                case 0: conceptosChart = null; break;
                case 1: liquidAssetsChart = null; break;
                case 2: detailInvestmentChart = null; break;
                case 3: informesChart = null; break;
                case 4: assetAllocationChart = null; break;
                case 5: budgetTrendChart = null; break;
                case 6: netWorthChart = null; break;
                case 7: informeActivoChart = null; break;
                
            }
        }
    }
};
// ▼▼▼ REEMPLAZA tu función navigateTo POR COMPLETO CON ESTA VERSIÓN ▼▼▼

const navigateTo = async (pageId, isInitial = false) => {
    const oldView = document.querySelector('.view--active');
    const newView = select(pageId);
	const mainScroller = selectOne('.app-layout__main');
	if (oldView && mainScroller) {
    pageScrollPositions[oldView.id] = mainScroller.scrollTop;
	}
    if (!newView || (oldView && oldView.id === pageId)) return;

    destroyAllCharts();
    if (!isInitial) hapticFeedback('light');
	if (!isInitial && window.history.state?.page !== pageId) {
        history.pushState({ page: pageId }, '', `#${pageId}`);
    }
    // Lógica para determinar la dirección de la animación (adelante o atrás)
    const navItems = Array.from(selectAll('.bottom-nav__item'));
    const oldIndex = oldView ? navItems.findIndex(item => item.dataset.page === oldView.id) : -1;
    const newIndex = navItems.findIndex(item => item.dataset.page === newView.id);
    const isForward = newIndex > oldIndex;

    // ----- Carga de datos y renderizado de la nueva vista (lógica existente) -----
    const actionsEl = select('top-bar-actions'), leftEl = select('top-bar-left-button'), fab = select('fab-add-movimiento');
    
    // =========================================================================================
    // === ¡AQUÍ ESTÁ LA LÍNEA CLAVE CORREGIDA! Fíjate al final de la línea. ===
    // =========================================================================================
    const standardActions = `
<button data-action="toggle-theme" class="icon-btn" title="Cambiar Tema" aria-label="Cambiar Tema">
    <span class="material-icons">palette</span>
</button>
<button data-action="global-search" class="icon-btn" title="Búsqueda Global (Cmd/Ctrl+K)" aria-label="Búsqueda Global">
    <span class="material-icons">search</span>
</button>
<button data-action="show-main-menu" class="icon-btn" title="Más opciones" aria-label="Mostrar más opciones">
    <span class="material-icons">more_vert</span>
</button>
`;
    
    if (pageId === PAGE_IDS.INICIO) {
    await loadInversiones();
    }
    const pageRenderers = {
    [PAGE_IDS.INICIO]: { title: 'Inicio', render: renderInicioPage , actions: standardActions },
    [PAGE_IDS.DIARIO]: { title: 'Diario', render: renderDiarioPage, actions: standardActions },
    [PAGE_IDS.INVERSIONES]: { title: 'Inversiones', render: renderInversionesView, actions: standardActions },
    [PAGE_IDS.OTROS]: { title: 'Otros', render: renderOtrosPage, actions: standardActions }, // <-- AÑADIDO
	[PAGE_IDS.CONFIGURACION]: { title: 'Ajustes', render: loadConfig, actions: standardActions },
};
     if (pageRenderers[pageId]) { 
        if (leftEl) {
            let leftSideHTML = `<button id="ledger-toggle-btn" class="btn btn--secondary" data-action="toggle-ledger" title="Cambiar a Contabilidad ${isOffBalanceMode ? 'A' : 'B'}"> ${isOffBalanceMode ? 'B' : 'A'}</button><span id="page-title-display">${pageRenderers[pageId].title}</span>`;
            if (pageId === PAGE_IDS.INICIO) leftSideHTML += `<button data-action="configure-dashboard" class="icon-btn" title="Personalizar qué se ve en el Panel" style="margin-left: 8px;"><span class="material-icons">dashboard_customize</span></button>`;
            if (pageId === PAGE_IDS.DIARIO) {
    leftSideHTML += `
        <button data-action="show-diario-filters" class="icon-btn" title="Filtrar y Buscar" style="margin-left: 8px;">
            <span class="material-icons">filter_list</span>
        </button>
        <button data-action="toggle-diario-view" class="icon-btn" title="Cambiar Vista">
            <span class="material-icons">${diarioViewMode === 'list' ? 'calendar_month' : 'list'}</span>
        </button>
    `;
}
            leftEl.innerHTML = leftSideHTML;
        }
        if (actionsEl) actionsEl.innerHTML = pageRenderers[pageId].actions;
        pageRenderers[pageId].render();
    }
    selectAll('.bottom-nav__item').forEach(b => b.classList.toggle('bottom-nav__item--active', b.dataset.page === pageId));
    if (fab) fab.classList.toggle('fab--visible', true);
    updateThemeIcon();
    // ----- Fin de la lógica existente -----


    // ----- INICIO DE LA NUEVA LÓGICA DE TRANSICIÓN -----
    
    // 1. Preparamos la nueva vista para que entre, pero aún no es la activa.
    newView.classList.add('view--active'); // La hacemos visible con display:flex
    
    if (oldView && !isInitial) {
        const outClass = isForward ? 'view-transition-out-forward' : 'view-transition-out-backward';
        const inClass = isForward ? 'view-transition-in-forward' : 'view-transition-in-backward';

        newView.classList.add(inClass);
        oldView.classList.add(outClass);

        // 2. Escuchamos el final de la animación de la vista que SALE.
        oldView.addEventListener('animationend', () => {
            oldView.classList.remove('view--active', outClass);
            newView.classList.remove(inClass);
        }, { once: true });

    } else if (oldView) {
        // Para la carga inicial, simplemente reemplazamos la vista sin animación.
        oldView.classList.remove('view--active');
    }

    if (mainScroller) {
    // Si hay una posición guardada para esta página, la usamos. Si no, vamos arriba.
    mainScroller.scrollTop = pageScrollPositions[pageId] || 0;
}

    if (pageId === PAGE_IDS.INICIO) {
        setTimeout(scheduleDashboardUpdate, 50);
    }
};
        
        const setupTheme = () => { 
    const gridColor = 'rgba(255, 255, 255, 0.1)';
    const textColor = '#FFFFFF';
    Chart.defaults.color = textColor; 
    Chart.defaults.borderColor = gridColor;
    Chart.register(ChartDataLabels);
};
        
    const buildIntelligentIndex = (movementsSource = db.movimientos) => {
    intelligentIndex.clear(); 
    if (!movementsSource || movementsSource.length === 0) return;

    const visibleAccounts = getVisibleAccounts().map(c => c.id);
    const tempIndex = new Map();

    const movementsToIndex = [...movementsSource]
        .filter(mov => mov.tipo === 'movimiento' && visibleAccounts.includes(mov.cuentaId)) // Filtramos solo por el ledger activo
        .sort((a, b) => new Date(a.fecha) - new Date(b.fecha)); // Ordenamos por fecha

    for (const mov of movementsToIndex) {
        const desc = mov.descripcion.trim().toLowerCase();
        if (desc.length > 3) {
            const key = desc;
            if (!tempIndex.has(key)) {
                tempIndex.set(key, {
                    conceptoId: mov.conceptoId,
                    cuentaId: mov.cuentaId,
                    count: 0, // Reiniciamos el contador
                    lastUsed: 0
                });
            }
            const entry = tempIndex.get(key);
            entry.conceptoId = mov.conceptoId; 
            entry.cuentaId = mov.cuentaId;
            entry.count++; 
            entry.lastUsed = new Date(mov.fecha).getTime();
        }
    }
    
    intelligentIndex = tempIndex;
    console.log(`Índice inteligente MEJORADO con ${intelligentIndex.size} entradas.`);
};
		
		
// =================================================================
// === BLOQUE DE FUNCIONES DE CUENTAS (CORREGIDO Y UNIFICADO) ===
// =================================================================

/**
 * REVISADO Y ÚNICO: Obtiene únicamente las cuentas activas para la contabilidad actual (A o B).
 * Esta es la función MÁS IMPORTANTE para el filtrado.
 */
const getVisibleAccounts = () => (db.cuentas || []).filter(c => !!c.offBalance === isOffBalanceMode);

/**
 * Obtiene las cuentas líquidas de la contabilidad visible actual.
 */
const getLiquidAccounts = () => getVisibleAccounts().filter((c) => !['PROPIEDAD', 'PRÉSTAMO'].includes((c.tipo || '').trim().toUpperCase()));

/**
 * Obtiene los saldos de TODAS las cuentas, sin importar la contabilidad.
 * Es usado por el sistema de cálculo de saldos acumulados.
 */
const getAllSaldos = () => {
    const saldos = {};
    (db.cuentas || []).forEach(cuenta => {
        saldos[cuenta.id] = cuenta.saldo || 0;
    });
    return saldos;
};
        async function fetchAllMovementsForBalances() {
            if (!currentUser) return [];
            const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos').get();
            return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        }
        const fetchAllMovementsForSearch = async () => {
            if (!currentUser) return [];
            try {
                const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos').get();
                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            } catch (error) {
                console.error("Error al obtener todos los movimientos para la búsqueda:", error);
                showToast("Error al realizar la búsqueda en la base de datos.", "danger");
                return [];
            }
        };
        const getSaldos = async () => {
            const visibleAccounts = getVisibleAccounts();
            const saldos = {};
            visibleAccounts.forEach(cuenta => {
                saldos[cuenta.id] = cuenta.saldo || 0;
            });
            return saldos;
        };
		
	const fetchAllMovementsForHistory = async () => {
    if (!currentUser) return [];
    try {
        const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos').get();
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    } catch (error) {
        console.error("Error al obtener el historial completo de movimientos:", error);
        showToast("Error al cargar el historial para el gráfico de patrimonio.", "danger");
        return [];
    }
};
		
        
const getFilteredMovements = async (forComparison = false) => {
    // 1. OBTENER FECHAS DEL FILTRO (esto no cambia)
    const filterPeriodo = select('filter-periodo');
    const p = filterPeriodo ? filterPeriodo.value : 'mes-actual';
    let sDate, eDate, prevSDate, prevEDate;
    const now = new Date();
    now.setHours(0, 0, 0, 0);

    switch (p) {
        case 'mes-actual':
            sDate = new Date(now.getFullYear(), now.getMonth(), 1);
            eDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999);
            prevSDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            prevEDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59, 999);
            break;
        case 'año-actual':
            sDate = new Date(now.getFullYear(), 0, 1);
            eDate = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999);
            prevSDate = new Date(now.getFullYear() - 1, 0, 1);
            prevEDate = new Date(now.getFullYear() - 1, 11, 31, 23, 59, 59, 999);
            break;
        case 'custom':
            const filterFechaInicio = select('filter-fecha-inicio');
            const filterFechaFin = select('filter-fecha-fin');
            sDate = filterFechaInicio?.value ? parseDateStringAsUTC(filterFechaInicio.value) : null;
            eDate = filterFechaFin?.value ? parseDateStringAsUTC(filterFechaFin.value) : null;
            if(eDate) eDate.setUTCHours(23, 59, 59, 999);
            // Para el modo 'custom', no calculamos periodo previo.
            prevSDate = null; prevEDate = null; 
            break;
        default:
            return { current: [], previous: [], label: '' };
    }

    if (!sDate || !eDate) return { current: [], previous: [], label: '' };

    // 2. ¡LA MAGIA! CONSULTAR A LA BASE DE DATOS DIRECTAMENTE
    const fetchMovementsForRange = async (start, end) => {
        if (!start || !end) return [];

        const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos')
            .where('fecha', '>=', start.toISOString())
            .where('fecha', '<=', end.toISOString())
            .get();
        return snapshot.docs.map(doc => doc.data());
    };

    // 3. OBTENER Y FILTRAR LOS MOVIMIENTOS
    const visibleAccountIds = new Set(getVisibleAccounts().map(c => c.id));
    
    // Función interna para filtrar por contabilidad (A o B)
    const filterByLedger = (movs) => movs.filter(m => {
        if (m.tipo === 'traspaso') {
            return visibleAccountIds.has(m.cuentaOrigenId) || visibleAccountIds.has(m.cuentaDestinoId);
        }
        return visibleAccountIds.has(m.cuentaId);
    });

    const currentMovsRaw = await fetchMovementsForRange(sDate, eDate);
    const currentMovs = filterByLedger(currentMovsRaw);

    if (!forComparison) return { current: currentMovs, previous: [], label: '' };
    
    const prevMovsRaw = await fetchMovementsForRange(prevSDate, prevEDate);
    const prevMovs = filterByLedger(prevMovsRaw);

    const comparisonLabel = p === 'mes-actual' ? 'vs mes ant.' : (p === 'año-actual' ? 'vs año ant.' : '');
    
    return { current: currentMovs, previous: prevMovs, label: comparisonLabel };
};
        
        const calculateIRR = (cashflows) => {
            if (cashflows.length < 2) return 0;
            const sortedCashflows = [...cashflows].sort((a, b) => a.date.getTime() - b.date.getTime());
            const firstDate = sortedCashflows[0].date;
            const npv = (rate) => { let total = 0; for (const flow of sortedCashflows) { const years = (flow.date.getTime() - firstDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000); total += flow.amount / Math.pow(1 + rate, years); } return total; };
            const derivative = (rate) => { let total = 0; for (const flow of sortedCashflows) { const years = (flow.date.getTime() - firstDate.getTime()) / (365.25 * 24 * 60 * 60 * 1000); if (years > 0) { total -= years * flow.amount / Math.pow(1 + rate, years + 1); } } return total; };
            let guess = 0.1; const maxIterations = 100; const tolerance = 1e-7;
            for (let i = 0; i < maxIterations; i++) {
                const npvValue = npv(guess); const derivativeValue = derivative(guess); if (Math.abs(derivativeValue) < tolerance) break; const newGuess = guess - npvValue / derivativeValue; if (Math.abs(newGuess - guess) <= tolerance) { return newGuess; } guess = newGuess; }
            return 0;
        };
		
// =========================================================================================
// === VERSIÓN FINAL: P&L basado en Saldo Contable y TIR basada en CADA movimiento        ===
// =========================================================================================
const calculatePortfolioPerformance = async (cuentaId = null) => {
    if (!dataLoaded.inversiones) await loadInversiones();

    const allInvestmentAccounts = getVisibleAccounts().filter(c => c.esInversion);
    const investmentAccounts = cuentaId ? allInvestmentAccounts.filter(c => c.id === cuentaId) : allInvestmentAccounts;
    
    if (investmentAccounts.length === 0) {
        return { valorActual: 0, capitalInvertido: 0, pnlAbsoluto: 0, pnlPorcentual: 0, irr: 0 };
    }

    const allMovements = await fetchAllMovementsForHistory();

    let totalValorActual = 0;
    let totalCapitalInvertido_para_PNL = 0;
    let allIrrCashflows = [];

    for (const cuenta of investmentAccounts) {
        // --- PARTE 1: LÓGICA PARA P&L (BASADO EN SALDO CONTABLE) ---

        // 1. Obtenemos el valor de mercado actual desde la valoración manual.
        const valoraciones = (db.inversiones_historial || [])
            .filter(v => v.cuentaId === cuenta.id)
            .sort((a, b) => new Date(b.fecha).getTime() - new Date(a.fecha).getTime());
        const valorActual = valoraciones.length > 0 ? valoraciones[0].valor : 0;
        
        // 2. PREMISA DEL USUARIO: El "Capital Aportado" es exactamente el saldo contable.
        const capitalInvertido_para_PNL = cuenta.saldo || 0;
        
        totalValorActual += valorActual;
        totalCapitalInvertido_para_PNL += capitalInvertido_para_PNL;

        // --- PARTE 2: LÓGICA PARA TIR (BASADA EN CADA MOVIMIENTO INDIVIDUAL) ---
        
        const accountMovements = allMovements.filter(m => 
            (m.tipo === 'movimiento' && m.cuentaId === cuenta.id) ||
            (m.tipo === 'traspaso' && (m.cuentaDestinoId === cuenta.id || m.cuentaOrigenId === cuenta.id))
        );

        // 3. PREMISA DEL USUARIO: Convertimos CADA movimiento en un flujo de caja para la TIR.
        const irrCashflows = accountMovements
            .map(mov => {
                let effectOnAccount = 0;

                // Determinamos el efecto real del movimiento sobre el saldo de ESTA cuenta.
                if (mov.tipo === 'movimiento') {
                    effectOnAccount = mov.cantidad;
                } else if (mov.tipo === 'traspaso') {
                    if (mov.cuentaDestinoId === cuenta.id) {
                        effectOnAccount = mov.cantidad; // Entra dinero a la cuenta
                    } else if (mov.cuentaOrigenId === cuenta.id) {
                        effectOnAccount = -mov.cantidad; // Sale dinero de la cuenta
                    }
                }
                
                // Si el movimiento afectó a la cuenta, lo convertimos en un flujo de caja.
                if (effectOnAccount !== 0) {
                    // PREMISA DEL USUARIO:
                    // - Si es una entrada (effectOnAccount > 0), es una "aportación" -> Flujo de caja NEGATIVO.
                    // - Si es una salida (effectOnAccount < 0), es una "retirada" -> Flujo de caja POSITIVO.
                    // Esto es matemáticamente equivalente a invertir el signo del efecto.
                    return { amount: -effectOnAccount, date: new Date(mov.fecha) };
                }
                
                return null; // Si no afectó, no es un flujo de caja.
            })
            .filter(cf => cf !== null); // Limpiamos los nulos

        // 4. El valor actual se añade como el último flujo de caja positivo (retirada final ficticia).
        if (valorActual !== 0) {
            irrCashflows.push({ amount: valorActual, date: new Date() });
        }
        allIrrCashflows.push(...irrCashflows);
    }

    // --- PARTE 3: CÁLCULOS FINALES ---

    // El P&L se calcula con tu lógica: Valoración - Saldo Contable.
    const pnlAbsoluto = totalValorActual - totalCapitalInvertido_para_PNL;
    const pnlPorcentual = totalCapitalInvertido_para_PNL !== 0 ? (pnlAbsoluto / totalCapitalInvertido_para_PNL) * 100 : 0;
    
    // La TIR se calcula con la lógica de flujos de caja que definiste.
    const irr = calculateIRR(allIrrCashflows);

    return { 
        valorActual: totalValorActual, 
        capitalInvertido: totalCapitalInvertido_para_PNL,
        pnlAbsoluto, 
        pnlPorcentual, 
        irr 
    };
};

    const recalculateAndApplyRunningBalances = (movements, allAccountsDb) => {
    // 1. Agrupamos los movimientos por cada cuenta afectada.
    const movementsByAccount = {};
    movements.forEach(mov => {
        if (mov.tipo === 'traspaso') {
            if (!movementsByAccount[mov.cuentaOrigenId]) movementsByAccount[mov.cuentaOrigenId] = [];
            if (!movementsByAccount[mov.cuentaDestinoId]) movementsByAccount[mov.cuentaDestinoId] = [];
            movementsByAccount[mov.cuentaOrigenId].push(mov);
            movementsByAccount[mov.cuentaDestinoId].push(mov);
        } else {
            if (!movementsByAccount[mov.cuentaId]) movementsByAccount[mov.cuentaId] = [];
            movementsByAccount[mov.cuentaId].push(mov);
        }
    });

    // 2. Para cada cuenta, calculamos su historial de saldos.
    for (const cuentaId in movementsByAccount) {
        const cuenta = allAccountsDb.find(c => c.id === cuentaId);
        if (!cuenta) continue; // Si la cuenta no existe, la ignoramos.

        // Nuestra "Verdad Absoluta": el saldo real y actual de la cuenta.
        let runningBalance = cuenta.saldo || 0;

        const accountMovements = movementsByAccount[cuentaId];
        
        // La ordenación infalible: primero por fecha/hora, luego por ID. El más reciente, primero.
        accountMovements.sort((a, b) => {
            const dateComparison = new Date(b.fecha).getTime() - new Date(a.fecha).getTime();
            if (dateComparison !== 0) return dateComparison;
            return b.id.localeCompare(a.id);
        });

        // 3. Recorremos los movimientos HACIA ATRÁS en el tiempo.
        for (const mov of accountMovements) {
            // Asignamos el saldo actual a la propiedad correcta.
            if (mov.tipo === 'traspaso') {
                if (mov.cuentaOrigenId === cuentaId) mov.runningBalanceOrigen = runningBalance;
                if (mov.cuentaDestinoId === cuentaId) mov.runningBalanceDestino = runningBalance;
            } else {
                mov.runningBalance = runningBalance;
            }

            // "Deshacemos" la operación para calcular el saldo ANTERIOR.
            if (mov.tipo === 'traspaso') {
                if (mov.cuentaOrigenId === cuentaId) runningBalance += mov.cantidad;
                if (mov.cuentaDestinoId === cuentaId) runningBalance -= mov.cantidad;
            } else {
                runningBalance -= mov.cantidad;
            }
        }
    }
};
             const processMovementsForRunningBalance = async (movements, forceRecalculate = false) => {
            if (!runningBalancesCache || forceRecalculate) {
                runningBalancesCache = getAllSaldos();
            }

            const sortedMovements = [...movements].sort((a, b) => {
        const dateComparison = new Date(b.fecha).getTime() - new Date(a.fecha).getTime();
        if (dateComparison !== 0) return dateComparison;
        // El ID del documento como desempate final garantiza el orden.
        return b.id.localeCompare(a.id); 
    });

            for (const mov of sortedMovements) {
                if (mov.tipo === 'traspaso') {
                    if (!runningBalancesCache.hasOwnProperty(mov.cuentaOrigenId)) {
                        runningBalancesCache[mov.cuentaOrigenId] = 0;
                    }
                    if (!runningBalancesCache.hasOwnProperty(mov.cuentaDestinoId)) {
                        runningBalancesCache[mov.cuentaDestinoId] = 0;
                    }

                    mov.runningBalanceOrigen = runningBalancesCache[mov.cuentaOrigenId];
                    mov.runningBalanceDestino = runningBalancesCache[mov.cuentaDestinoId];

                    runningBalancesCache[mov.cuentaOrigenId] += mov.cantidad;
                    runningBalancesCache[mov.cuentaDestinoId] -= mov.cantidad;

                } else {
                    if (!runningBalancesCache.hasOwnProperty(mov.cuentaId)) {
                        runningBalancesCache[mov.cuentaId] = 0;
                    }

                    mov.runningBalance = runningBalancesCache[mov.cuentaId];
                    runningBalancesCache[mov.cuentaId] -= mov.cantidad;
                }
            }
        };
        
        const populateAllDropdowns = () => {
            const visibleAccounts = getVisibleAccounts();
            const populate = (id, data, nameKey, valKey='id', all=false, none=false) => {
                const el = select(id); if (!el) return; const currentVal = el.value;
                let opts = all ? '<option value="">Todos</option>' : ''; if (none) opts += '<option value="">Ninguno</option>';
                [...data].sort((a,b) => (a[nameKey]||"").localeCompare(b[nameKey]||"")).forEach(i => opts += `<option value="${i[valKey]}">${i[nameKey]}</option>`);
                el.innerHTML = opts; 
                const optionsArray = Array.from(el.options);
                el.value = optionsArray.some(o=>o.value===currentVal) ? currentVal : (optionsArray.length > 0 ? optionsArray[0].value : "");
            };
            populate('movimiento-cuenta', visibleAccounts, 'nombre', 'id', false, true);
            
            populateTraspasoDropdowns();
            
            populate('filter-cuenta', visibleAccounts, 'nombre', 'id', true); 
            populate('movimiento-concepto', db.conceptos, 'nombre', 'id', false, true); 
            populate('filter-concepto', db.conceptos, 'nombre', 'id', true);
            const budgetYearSelect = select('budget-year-selector'); if(budgetYearSelect) { const currentVal = budgetYearSelect.value; const currentYear = new Date().getFullYear(); let years = new Set([currentYear]); (db.presupuestos || []).forEach((p) => years.add(p.ano)); budgetYearSelect.innerHTML = [...years].sort((a,b) => b-a).map(y => `<option value="${y}">${y}</option>`).join(''); if(currentVal && [...years].some(y => y == parseInt(currentVal))) budgetYearSelect.value = currentVal; else budgetYearSelect.value = String(currentYear); }
        };

        const populateTraspasoDropdowns = () => {
            const traspasoToggle = select('traspaso-show-all-accounts-toggle');
            const showAll = traspasoToggle ? traspasoToggle.checked : false;
            const accountsToList = showAll ? (db.cuentas || []) : getVisibleAccounts();
            
            const populate = (id, data, none = false) => {
                const el = select(id); if (!el) return;
                const currentVal = el.value;
                let opts = none ? '<option value="">Ninguno</option>' : '';
                data.sort((a,b) => a.nombre.localeCompare(b.nombre)).forEach(i => opts += `<option value="${i.id}">${i.nombre}</option>`);
                el.innerHTML = opts;
                const optionsArray = Array.from(el.options);
                if (optionsArray.some(o => o.value === currentVal)) {
                    el.value = currentVal;
                } else {
                    el.value = optionsArray.length > 0 ? optionsArray[0].value : "";
                }
            };

            populate('movimiento-cuenta-origen', accountsToList, true);
            populate('movimiento-cuenta-destino', accountsToList, true);
        };
         
    

	const handleToggleInvestmentTypeFilter = (type) => {
    hapticFeedback('light');
    if (deselectedInvestmentTypesFilter.has(type)) {
        deselectedInvestmentTypesFilter.delete(type);
    } else {
        deselectedInvestmentTypesFilter.add(type);
    }

    // LA SOLUCIÓN:
    // Ya no buscamos el contenedor, simplemente llamamos a la función de
    // renderizado con el ID correcto para la pestaña de Inversiones.
    renderInversionesView();
};

// ====================================================================================
// === PASO 2: REEMPLAZA ESTA FUNCIÓN COMPLETA - VERSIÓN CON ETIQUETAS CLARAS ===
// ====================================================================================

let investmentChartMode = 'valorado';

const renderPortfolioMainContent = async (targetContainerId) => {
    const container = select(targetContainerId);
    if (!container) return;

    const investmentAccounts = getVisibleAccounts().filter((c) => c.esInversion);
    const CHART_COLORS = ['#007AFF', '#30D158', '#FFD60A', '#FF3B30', '#C084FC', '#4ECDC4', '#EF626C', '#A8D58A'];

    if (investmentAccounts.length === 0) {
        container.innerHTML = `<div id="empty-investments" class="empty-state" style="margin-top: 0; border: none; background: transparent;">
                <span class="material-icons">rocket_launch</span>
                <h3>Tu Portafolio empieza aquí</h3>
                <p>Ve a 'Ajustes' > 'Cuentas' y marca una cuenta como 'de inversión' para empezar el seguimiento.</p>
                <button class="btn btn--primary" data-action="manage-investment-accounts" style="margin-top: var(--sp-4);">
                    <span class="material-icons" style="font-size: 16px;">checklist</span>
                    <span>Gestionar Activos</span>
                </button>
            </div>`;
        return;
    }

    const performanceData = await Promise.all(
        investmentAccounts.map(async (cuenta) => {
            const performance = await calculatePortfolioPerformance(cuenta.id);
            return { ...cuenta, ...performance };
        })
    );

    const allInvestmentTypes = [...new Set(performanceData.map(asset => toSentenceCase(asset.tipo || 'S/T')))].sort();
    const colorMap = {};
    allInvestmentTypes.forEach((label, index) => { colorMap[label] = CHART_COLORS[index % CHART_COLORS.length]; });

    const pillsHTML = allInvestmentTypes.map(t => {
        const isActive = !deselectedInvestmentTypesFilter.has(t);
        const color = colorMap[t];
        let style = isActive ? `style="background-color: ${color}; border-color: ${color}; color: #FFFFFF;"` : '';
        return `<button class="filter-pill ${isActive ? 'filter-pill--active' : ''}" data-action="toggle-investment-type-filter" data-type="${t}" ${style}>${t}</button>`;
    }).join('');

    const displayAssetsData = performanceData.filter(asset => !deselectedInvestmentTypesFilter.has(toSentenceCase(asset.tipo || 'S/T')));

    const portfolioTotalValorado = displayAssetsData.reduce((sum, cuenta) => sum + cuenta.valorActual, 0);
    const portfolioTotalInvertido = displayAssetsData.reduce((sum, cuenta) => sum + cuenta.capitalInvertido, 0);
    const rentabilidadTotalAbsoluta = portfolioTotalValorado - portfolioTotalInvertido;
    const rentabilidadTotalPorcentual = portfolioTotalInvertido !== 0 ? (rentabilidadTotalAbsoluta / portfolioTotalInvertido) * 100 : 0;
    const rentabilidadClass = rentabilidadTotalAbsoluta >= 0 ? 'text-positive' : 'text-negative';

    container.innerHTML = `
        <div class="card" style="margin-bottom: var(--sp-4);">
            <div class="card__content" style="display: flex; justify-content: space-around; text-align: center; padding: var(--sp-3);">
                <div>
                    <h4 class="kpi-item__label">Capital Aportado</h4>
                    <strong class="kpi-item__value" style="font-size: var(--fs-lg);">${formatCurrency(portfolioTotalInvertido)}</strong>
                </div>
                <div>
                    <h4 class="kpi-item__label">Valor de Mercado</h4>
                    <strong class="kpi-item__value" style="font-size: var(--fs-lg);">${formatCurrency(portfolioTotalValorado)}</strong>
                </div>
                <div>
                    <h4 class="kpi-item__label">Ganancia / Pérdida</h4>
                    <strong class="kpi-item__value ${rentabilidadClass}" style="font-size: var(--fs-lg);">${formatCurrency(rentabilidadTotalAbsoluta)}</strong>
                    <div class="kpi-item__comparison ${rentabilidadClass}" style="font-weight: 600;">(${rentabilidadTotalPorcentual.toFixed(1)}%)</div>
                </div>
            </div>
        </div>

        <details class="accordion" open style="margin-bottom: var(--sp-4);">
            <summary><h3 class="card__title" style="margin:0; padding: 0; color: var(--c-on-surface);"><span class="material-icons">pie_chart</span>Asignación y Filtros</h3><span class="material-icons accordion__icon">expand_more</span></summary>
            <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                <div class="filter-pills" style="margin-bottom: var(--sp-2);">${pillsHTML}</div>
                <div class="filter-pills" style="justify-content: center; margin-bottom: var(--sp-4);">
                    <button class="filter-pill ${investmentChartMode === 'valorado' ? 'filter-pill--active' : ''}" data-action="set-investment-chart-mode" data-mode="valorado">Por Valor de Mercado</button>
                    <button class="filter-pill ${investmentChartMode === 'invertido' ? 'filter-pill--active' : ''}" data-action="set-investment-chart-mode" data-mode="invertido">Por Capital Aportado</button>
                </div>
                <div class="chart-container" style="height: 250px; margin-bottom: 0;"><canvas id="asset-allocation-chart"></canvas></div>
            </div>
        </details>
        <div id="investment-assets-list"></div>
        <div class="card card--no-bg" style="padding:0; margin-top: var(--sp-4);">
            <button class="btn btn--secondary btn--full" data-action="manage-investment-accounts"><span class="material-icons" style="font-size: 16px;">checklist</span>Gestionar Activos</button>
        </div>`;
    
    setTimeout(() => {
        const chartCtx = select('asset-allocation-chart')?.getContext('2d');
        if (chartCtx) {
            if (assetAllocationChart) assetAllocationChart.destroy();
            const keyToSum = investmentChartMode === 'valorado' ? 'valorActual' : 'capitalInvertido';
            const treeData = [];
            displayAssetsData.forEach(asset => {
                const valor = asset[keyToSum] / 100;
                if (valor > 0) treeData.push({ tipo: toSentenceCase(asset.tipo || 'S/T'), nombre: asset.nombre, valor: valor });
            });
            if (treeData.length > 0) {
                assetAllocationChart = new Chart(chartCtx, {
                    type: 'treemap',
                    data: {
                        datasets: [{
                            tree: treeData,
                            key: 'valor',
                            groups: ['tipo', 'nombre'],
                            spacing: 0.5,
                            borderWidth: 1.5,
                            borderColor: getComputedStyle(document.body).getPropertyValue('--c-background'),
                            backgroundColor: (ctx) => {
                                return ctx.type === 'data' ? colorMap[ctx.raw._data.tipo] || 'grey' : 'transparent';
                            },
                            labels: {
                                display: true,
                                color: '#FFFFFF',
                                font: { size: 11, weight: '600' },
                                align: 'center',
                                position: 'middle',
                                formatter: (ctx) => {
                                    return ctx.raw.g.includes(ctx.raw._data.nombre) ? ctx.raw._data.nombre.split(' ') : null;
                                }
                            }
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            tooltip: { callbacks: { label: (ctx) => `${ctx.raw._data.nombre}: ${formatCurrency(ctx.raw.v * 100)}` } },
                            datalabels: { display: false }
                        }
                    }
                });
            } else {
                 select('asset-allocation-chart').closest('.chart-container').innerHTML = `<div class="empty-state" style="padding:16px 0; background:transparent; border:none;"><p>No hay activos con valor para mostrar.</p></div>`;
            }
        }
        const listContainer = select('investment-assets-list');
        if (listContainer) {
            const listHtml = displayAssetsData.sort((a,b) => b.valorActual - a.valorActual).map(cuenta => {
                    const pnlClass = cuenta.pnlAbsoluto >= 0 ? 'text-positive' : 'text-negative';
                    return `<div class="modal__list-item" data-action="view-account-details" data-id="${cuenta.id}" style="cursor: pointer; padding: var(--sp-3); display: block; border-bottom: 1px solid var(--c-outline);">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; width: 100%; margin-bottom: var(--sp-1);">
                            <strong style="font-size: var(--fs-base);">${escapeHTML(cuenta.nombre)}</strong><strong style="font-size: var(--fs-base);">${formatCurrency(cuenta.valorActual)}</strong>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: var(--sp-2); font-size: var(--fs-xs);">
                            <span class="${pnlClass}" style="font-weight: 600;">P&L: ${formatCurrency(cuenta.pnlAbsoluto)} (${cuenta.pnlPorcentual.toFixed(1)}%)</span>
                            <span style="color:var(--c-info); font-weight:600;">TIR: ${!isNaN(cuenta.irr) ? (cuenta.irr * 100).toFixed(1) + '%' : 'N/A'}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <span style="color:var(--c-on-surface-secondary); font-size: var(--fs-xs);">Aportado: ${formatCurrency(cuenta.capitalInvertido)}</span>
                            <button class="btn btn--secondary" data-action="update-asset-value" data-id="${cuenta.id}" style="padding: 4px 10px; font-size: 0.75rem;"><span class="material-icons" style="font-size: 14px;">add_chart</span>Valoración</button>
                        </div>
                    </div>`;
                }).join('');
            listContainer.innerHTML = listHtml ? `<div class="card"><div class="card__content" style="padding: 0;">${listHtml}</div></div>` : '';
        }
    }, 50);
};

        const renderVirtualListItem = (item) => {
			if (item.type === 'month-header') {
    const monthName = item.date.toLocaleDateString('es-ES', { month: 'long', year: 'numeric', timeZone: 'UTC' });
    return `
        <div class="movimiento-month-header">
            <h3 class="movimiento-month-header__title">${monthName}</h3>
            <div class="movimiento-month-header__summary">
                <p class="text-positive">${formatCurrency(item.income)}</p>
                <p class="text-negative">${formatCurrency(item.expense)}</p>
                <p class="${item.net >= 0 ? 'text-positive' : 'text-negative'}" style="border-top: 1px solid var(--c-outline); margin-top: 2px; padding-top: 2px;">
                    ${formatCurrency(item.net)}
                </p>
            </div>
        </div>
    `;
    }
            if (item.type === 'pending-header') {
                return `
                    <div class="movimiento-date-header" style="background-color: var(--c-warning); color: var(--c-black); font-weight: 800; letter-spacing: 0.5px;">
                        <span>
                            <span class="material-icons" style="font-size: 16px; vertical-align: bottom; margin-right: 4px;">update</span>
                            RECURRENTES PENDIENTES (${item.count})
                        </span>
                    </div>`;
            }

            if (item.type === 'pending-item') {
				const r = item.recurrent;
				const nextDate = new Date(r.nextDate + 'T12:00:00Z');
				const formattedDate = nextDate.toLocaleDateString('es-ES', { day: '2-digit', month: 'short' });
				const amountClass = r.cantidad >= 0 ? 'text-positive' : 'text-negative';

    return `
    <div class="transaction-card" id="pending-recurrente-${r.id}" style="background-color: color-mix(in srgb, var(--c-warning) 10%, transparent);">
        <div class="transaction-card__indicator transaction-card__indicator--recurrent"></div>
        <div class="transaction-card__content">
            <div class="transaction-card__details">
                <div class="transaction-card__row-1">${escapeHTML(r.descripcion)}</div>
                <div class="transaction-card__row-2" style="font-weight: 600; color: var(--c-warning);">Pendiente desde: ${formattedDate}</div>
                
                <!-- NUEVO: Ahora las acciones están mejor organizadas y con el botón Editar -->
                <div class="acciones-recurrentes-corregidas">
                    <button class="btn btn--secondary" data-action="edit-recurrente-from-pending" data-id="${r.id}" title="Editar antes de añadir" style="padding: 4px 8px; font-size: 0.7rem;">
                        <span class="material-icons" style="font-size: 14px;">edit</span>
                        <span>Editar</span>
                    </button>
                    <button class="btn btn--secondary" data-action="skip-recurrent" data-id="${r.id}" title="Omitir esta vez" style="padding: 4px 8px; font-size: 0.7rem;">
                        <span class="material-icons" style="font-size: 14px;">skip_next</span>
                        <span>No añadir</span>
                    </button>
                    <button class="btn btn--primary" data-action="confirm-recurrent" data-id="${r.id}" title="Crear el movimiento ahora" style="padding: 4px 8px; font-size: 0.7rem;">
                        <span class="material-icons" style="font-size: 14px;">check</span>
                        <span>Añadir Ahora</span>
                    </button>
                </div>
            </div>
            <div class="transaction-card__figures">
                <strong class="transaction-card__amount ${amountClass}">${formatCurrency(r.cantidad)}</strong>
            </div>
        </div>
    </div>`;
}
            if (item.type === 'date-header') {
                const dateObj = new Date(item.date + 'T12:00:00Z');
                const day = dateObj.toLocaleDateString('es-ES', { weekday: 'short' }).toUpperCase().replace('.', '');
                const dateStr = dateObj.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' });

                return `
                    <div class="movimiento-date-header">
                        <span>${day} ${dateStr}</span>
                        <span>${formatCurrency(item.total)}</span>
                    </div>
                `;
            }
			if (item.type === 'transaction') {
        return TransactionCardComponent(item.movement, { cuentas: db.cuentas, conceptos: db.conceptos });
		}
        
        };
        
        const renderVisibleItems = () => {
            if (!vList.scrollerEl || !vList.contentEl) return; 
            const scrollTop = vList.scrollerEl.scrollTop;
            const containerHeight = vList.scrollerEl.clientHeight;
            let startIndex = -1, endIndex = -1;
            
            for (let i = 0; i < vList.itemMap.length; i++) {
                const item = vList.itemMap[i];
                if (startIndex === -1 && item.offset + item.height > scrollTop) {
                    startIndex = Math.max(0, i - vList.renderBuffer);
                }
                if (endIndex === -1 && item.offset + item.height > scrollTop + containerHeight) {
                    endIndex = Math.min(vList.itemMap.length - 1, i + vList.renderBuffer);
                    break;
                }
            }
            if (startIndex === -1 && vList.items.length > 0) startIndex = 0;
            if (endIndex === -1) endIndex = vList.itemMap.length - 1;
            
            if (startIndex === vList.lastRenderedRange.start && endIndex === vList.lastRenderedRange.end) return;
            
            let visibleHtml = ''; 
            for (let i = startIndex; i <= endIndex; i++) {
                if (vList.items[i]) visibleHtml += renderVirtualListItem(vList.items[i]);
            }
            vList.contentEl.innerHTML = visibleHtml; 
			const renderedItems = vList.contentEl.querySelectorAll('.list-item-animate');
renderedItems.forEach((item, index) => {
    // Aplicamos la clase que dispara la animación con un pequeño retraso
    // para cada elemento, creando el efecto cascada.
    setTimeout(() => {
        item.classList.add('item-enter-active');
    }, index * 40); // 40 milisegundos de retraso entre cada item
});
            const offsetY = vList.itemMap[startIndex] ? vList.itemMap[startIndex].offset : 0; 
            vList.contentEl.style.transform = `translateY(${offsetY}px)`; 
            vList.lastRenderedRange = { start: startIndex, end: endIndex };
        };
// =================================================================
// === INICIO: NUEVA FUNCIÓN AYUDANTE PARA REFRESCOS RÁPIDOS     ===
// =================================================================
const updateLocalDataAndRefreshUI = async () => {
    // 1. Recalcula los saldos con la lista de movimientos actualizada que tenemos en memoria.
    await processMovementsForRunningBalance(db.movimientos, true);
    
    // 2. Le dice a la lista virtual que se redibuje con los nuevos datos.
    updateVirtualListUI();

    // 3. (Opcional pero recomendado) Actualiza el índice de autocompletado.
    buildIntelligentIndex();
};
// =================================================================
// === FIN: NUEVA FUNCIÓN AYUDANTE                               ===
// ================================================================= 
 
// ▼▼▼ REEMPLAZA TU FUNCIÓN updateVirtualListUI POR COMPLETO CON ESTA VERSIÓN CORREGIDA ▼▼▼

const updateVirtualListUI = () => {
    if (!vList.sizerEl) return;

    vList.items = [];
    vList.itemMap = [];
    let currentHeight = 0;
    
    // 1. Lógica para los recurrentes pendientes (esto no cambia)
    const now = new Date();
    const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    const pendingRecurrents = (db.recurrentes || [])
        .filter(r => {
            const nextDate = parseDateStringAsUTC(r.nextDate);
            return nextDate && new Date(Date.UTC(nextDate.getUTCFullYear(), nextDate.getUTCMonth(), nextDate.getUTCDate())) <= today;
        })
        .sort((a, b) => new Date(a.nextDate) - new Date(b.nextDate));

    if (pendingRecurrents.length > 0) {
        vList.items.push({ type: 'pending-header', count: pendingRecurrents.length });
        vList.itemMap.push({ height: vList.heights.pendingHeader, offset: currentHeight });
        currentHeight += vList.heights.pendingHeader;
        pendingRecurrents.forEach(recurrent => {
            vList.items.push({ type: 'pending-item', recurrent: recurrent });
            vList.itemMap.push({ height: vList.heights.pendingItem, offset: currentHeight });
            currentHeight += vList.heights.pendingItem;
        });
    }

   // 2. Agrupación de movimientos por mes y día
    const groupedByMonth = {};
    const visibleAccountIds = new Set(getVisibleAccounts().map(c => c.id));

    (db.movimientos || []).forEach(mov => {
        let isVisibleInLedger = false;
        let amountForTotals = 0;

        // ✅ INICIO DE LA LÓGICA CORREGIDA PARA VISIBILIDAD Y TOTALES ✅
        if (mov.tipo === 'traspaso') {
            const origenVisible = visibleAccountIds.has(mov.cuentaOrigenId);
            const destinoVisible = visibleAccountIds.has(mov.cuentaDestinoId);
            
            // Un traspaso es VISIBLE si al menos una de sus cuentas está en la contabilidad actual.
            isVisibleInLedger = origenVisible || destinoVisible;

            // Su IMPACTO en los totales solo se cuenta si es un traspaso entre contabilidades.
            if (origenVisible && !destinoVisible) amountForTotals = -mov.cantidad;
            else if (!origenVisible && destinoVisible) amountForTotals = mov.cantidad;

        } else { // Es un movimiento normal (ingreso/gasto)
            isVisibleInLedger = visibleAccountIds.has(mov.cuentaId);
            if (isVisibleInLedger) {
                amountForTotals = mov.cantidad;
            }
        }

        // Si el movimiento es visible, lo procesamos para mostrarlo.
        if (isVisibleInLedger) {
            const date = new Date(mov.fecha);
            const monthKey = `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}`;
            const dateKey = mov.fecha.slice(0, 10);
            
            if (!groupedByMonth[monthKey]) { groupedByMonth[monthKey] = { days: {}, monthNet: 0, monthIncome: 0, monthExpense: 0 }; }
            if (!groupedByMonth[monthKey].days[dateKey]) { groupedByMonth[monthKey].days[dateKey] = { movements: [], total: 0 }; }
            
            // Añadimos el movimiento a la lista de ESE DÍA.
            groupedByMonth[monthKey].days[dateKey].movements.push(mov);

            // Actualizamos los totales SÓLO con el impacto real en la contabilidad.
            groupedByMonth[monthKey].days[dateKey].total += amountForTotals;
            groupedByMonth[monthKey].monthNet += amountForTotals;
            if (amountForTotals > 0) groupedByMonth[monthKey].monthIncome += amountForTotals;
            else groupedByMonth[monthKey].monthExpense += amountForTotals;
        }
        // ✅ FIN DE LA LÓGICA CORREGIDA ✅
    });

    // 3. Construcción de la lista para la interfaz (esta parte ya era correcta)
    const sortedMonths = Object.keys(groupedByMonth).sort((a, b) => b.localeCompare(a));

    for (const monthKey of sortedMonths) {
        const monthData = groupedByMonth[monthKey];
        const monthDate = new Date(monthKey + '-02T12:00:00Z');

        vList.items.push({ type: 'month-header', date: monthDate, net: monthData.monthNet, income: monthData.monthIncome, expense: monthData.monthExpense });
        vList.itemMap.push({ height: 70, offset: currentHeight });
        currentHeight += 70;

        const sortedDates = Object.keys(monthData.days).sort((a, b) => b.localeCompare(a));
        for (const dateKey of sortedDates) {
            const group = monthData.days[dateKey];
            
            if (group.movements && group.movements.length > 0) {
                vList.items.push({ type: 'date-header', date: dateKey, total: group.total });
                vList.itemMap.push({ height: vList.heights.header, offset: currentHeight });
                currentHeight += vList.heights.header;
                group.movements.sort((a, b) => new Date(b.fecha) - new Date(a.fecha) || b.id.localeCompare(a.id));
                for (const mov of group.movements) {
                    const itemHeight = mov.tipo === 'traspaso' ? vList.heights.transfer : vList.heights.transaction;
                    vList.items.push({ type: 'transaction', movement: mov });
                    vList.itemMap.push({ height: itemHeight, offset: currentHeight });
                    currentHeight += itemHeight;
                }
            }
        }
    }
    
    // 4. Renderizar y actualizar (sin cambios)
    vList.sizerEl.style.height = `${currentHeight}px`;
    vList.lastRenderedRange = { start: -1, end: -1 }; 
    renderVisibleItems();
    const loadMoreContainer = select('load-more-container');
    const emptyContainer = select('empty-movimientos');
    const listContainer = select('movimientos-list-container');
    if (vList.items.length === 0) {
        listContainer?.classList.add('hidden');
        loadMoreContainer?.classList.add('hidden');
        emptyContainer?.classList.remove('hidden');
    } else {
        listContainer?.classList.remove('hidden');
        emptyContainer?.classList.add('hidden');
        loadMoreContainer?.classList.toggle('hidden', allMovementsLoaded);
    }
};

// Paso B: La función que carga los datos. Ahora es más simple y se llama
// tanto al inicio como al pulsar el botón.
// =============================================================
// === INICIO: FUNCIÓN `fetchMovementsPage` (CORRECCIÓN CRÍTICA)
// =============================================================

// Esta función es la que se comunica directamente con Firestore para traer los lotes de movimientos.
// Es ESENCIAL que esté presente en el código.

async function fetchMovementsPage(startAfterDoc = null) {
    if (!currentUser) return [];
    try {
        let query = fbDb.collection('users').doc(currentUser.uid).collection('movimientos')
            .orderBy('fecha', 'desc').orderBy(firebase.firestore.FieldPath.documentId(), 'desc');

        if (startAfterDoc) {
            query = query.startAfter(startAfterDoc);
        }

        query = query.limit(MOVEMENTS_PAGE_SIZE);
        const snapshot = await query.get();

        if (snapshot.empty) {
            allMovementsLoaded = true;
            return [];
        }

        lastVisibleMovementDoc = snapshot.docs[snapshot.docs.length - 1];

        if (snapshot.docs.length < MOVEMENTS_PAGE_SIZE) {
            allMovementsLoaded = true;
        }
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    } catch (error) {
        console.error("Error al obtener los movimientos:", error);
        showToast("Error al cargar los movimientos.", "danger");
        return [];
    }
}
// ===========================================================
// === FIN: FUNCIÓN `fetchMovementsPage`
// ===========================================================

// =================================================================
// === INICIO: CÓDIGO A AÑADIR (ÚNICA VERSIÓN CORRECTA)
// =================================================================

const filterMovementsByLedger = (movements) => {
    const visibleAccountIds = new Set(getVisibleAccounts().map(c => c.id));
    if (visibleAccountIds.size === 0) return [];
    
    return movements.filter(m => {
        if (m.tipo === 'traspaso') {
            return visibleAccountIds.has(m.cuentaOrigenId) || visibleAccountIds.has(m.cuentaDestinoId);
        } else {
            return visibleAccountIds.has(m.cuentaId);
        }
    });
};

// ===============================================================
// === FIN: CÓDIGO A AÑADIR
// ===============================================================

const loadMoreMovements = async (isInitial = false) => {
    if (isLoadingMoreMovements || allMovementsLoaded) return;

    isLoadingMoreMovements = true;
    const loadMoreBtn = select('load-more-btn');
    if (isInitial) {
        // En la carga inicial, usamos un esqueleto.
        let skeletonHTML = '';
for (let i = 0; i < 5; i++) {
    skeletonHTML += `
        <div class="skeleton-card">
            <div class="skeleton skeleton-card__indicator"></div>
            <div class="skeleton-card__content">
                <div>
                    <div class="skeleton skeleton-card__line skeleton-card__line--sm"></div>
                    <div class="skeleton skeleton-card__line skeleton-card__line--xs"></div>
                </div>
                <div class="skeleton skeleton-card__amount"></div>
            </div>
        </div>`;
}
select('virtual-list-content').innerHTML = skeletonHTML;
    } else if (loadMoreBtn) {
        // En las cargas subsecuentes, ponemos el botón en estado de carga.
        setButtonLoading(loadMoreBtn, true, 'Cargando...');
    }

    try {
        let newMovementsChunk = [];
        let fetchedFilteredCount = 0;

        // El bucle para obtener suficientes movimientos VISIBLES sigue siendo una excelente idea.
        while (fetchedFilteredCount < 50 && !allMovementsLoaded) {
            const rawMovsFromDB = await fetchMovementsPage(lastVisibleMovementDoc);
            if (rawMovsFromDB.length === 0) break;
            const filteredBatch = filterMovementsByLedger(rawMovsFromDB);
            newMovementsChunk.push(...filteredBatch);
            fetchedFilteredCount += filteredBatch.length;
        }
        
        // Añadimos los nuevos movimientos a la caché local.
        if (newMovementsChunk.length > 0) {
            db.movimientos.push(...newMovementsChunk);
            // Volvemos a procesar los balances acumulados sobre la lista completa
            await processMovementsForRunningBalance(db.movimientos, true);
        }

        // ¡LLAMADA ÚNICA! Una vez tenemos la lista completa (antiguos + nuevos),
        // llamamos a la función de renderizado para que reconstruya la UI.
        updateVirtualListUI();

    } catch (error) {
        console.error("Error al cargar más movimientos:", error);
        showToast("No se pudieron cargar más movimientos.", "danger");
    } finally {
        isLoadingMoreMovements = false;
        if (loadMoreBtn) {
            setButtonLoading(loadMoreBtn, false); // Restaura el botón
        }
    }
};

// =========================================================================
// === INICIO: REEMPLAZO COMPLETO Y MEJORADO DE loadInitialMovements     ===
// =========================================================================

        let movementsObserver = null; // Variable global para el observador
		const initMovementsObserver = () => {
    // Si ya existía un vigilante, lo reiniciamos
    if (movementsObserver) {
        movementsObserver.disconnect();
    }

    const trigger = select('infinite-scroll-trigger');
    if (!trigger) return;

    // Configuramos el vigilante para que actúe cuando el "activador" esté a punto de verse
    const options = {
        root: selectOne('.app-layout__main'), // Vigila el scroll dentro de la ventana principal
        rootMargin: '200px', // Empieza a cargar 200px antes de que llegue al final
        threshold: 0.01
    };

    movementsObserver = new IntersectionObserver((entries) => {
        // Si el vigilante ve nuestro activador...
        if (entries[0].isIntersecting) {
            // ...llama a la función para cargar más movimientos automáticamente.
            loadMoreMovements();
        }
    }, options);

    // Le decimos al vigilante que empiece a observar nuestro activador invisible.
    movementsObserver.observe(trigger);
};

// ▼▼▼ REEMPLAZA TU FUNCIÓN renderDiarioPage POR COMPLETO CON ESTA VERSIÓN ▼▼▼
const renderDiarioPage = async () => {
    const container = select('diario-page');
    if (!container.querySelector('#diario-view-container')) {
        container.innerHTML = '<div id="diario-view-container"></div>';
    }
    
    const viewContainer = select('diario-view-container');
    if (!viewContainer) return;

    if (diarioViewMode === 'calendar') {
        if (movementsObserver) movementsObserver.disconnect();
        await renderDiarioCalendar();
        return;
    }

    viewContainer.innerHTML = `
        <div id="diario-filter-active-indicator" class="hidden">
            <p>Mostrando resultados filtrados.</p>
            <div>
                <button data-action="export-filtered-csv" class="btn btn--secondary" style="padding: 4px 10px; font-size: 0.75rem;">
                    <span class="material-icons" style="font-size: 14px;">download</span>
                    Exportar
                </button>
                <button data-action="clear-diario-filters" class="btn btn--secondary" style="padding: 4px 10px; font-size: 0.75rem;">Limpiar</button>
            </div>
        </div>
        <div id="movimientos-list-container">
            <div id="virtual-list-sizer"><div id="virtual-list-content"></div></div>
        </div>
        <div id="infinite-scroll-trigger" style="height: 50px;"></div> 
        <div id="empty-movimientos" class="empty-state hidden" style="margin: 0 var(--sp-4);">
            <span class="material-icons">search_off</span><h3>Sin Resultados</h3><p>No se encontraron movimientos que coincidan con tus filtros.</p>
        </div>`;

    vList.scrollerEl = selectOne('.app-layout__main');
    vList.sizerEl = select('virtual-list-sizer');
    vList.contentEl = select('virtual-list-content');

    let skeletonHTML = '';
    for (let i = 0; i < 7; i++) {
        skeletonHTML += `<div class="skeleton-card"><div class="skeleton skeleton-card__indicator"></div><div class="skeleton-card__content"><div><div class="skeleton skeleton-card__line skeleton-card__line--sm"></div><div class="skeleton skeleton-card__line skeleton-card__line--xs"></div></div><div class="skeleton skeleton-card__amount"></div></div></div>`;
    }
    select('virtual-list-content').innerHTML = skeletonHTML;
    
    // ---- INICIO DE LA LÓGICA CORREGIDA ----
    const scrollTrigger = select('infinite-scroll-trigger');

    if (diarioActiveFilters) {
        // MODO FILTRADO: Ocultamos el scroll infinito y filtramos los datos cacheados.
        if (scrollTrigger) scrollTrigger.classList.add('hidden'); // Oculta el activador
        if (movementsObserver) movementsObserver.disconnect(); // Detiene el observador

        select('diario-filter-active-indicator').classList.remove('hidden');
        
        if (allDiarioMovementsCache.length === 0) {
            allDiarioMovementsCache = await fetchAllMovementsForHistory();
        }

        const { startDate, endDate, description, minAmount, maxAmount, cuentas, conceptos } = diarioActiveFilters;
        const movementsToDisplay = allDiarioMovementsCache.filter(m => {
            if (startDate && m.fecha < startDate) return false;
            if (endDate && m.fecha > endDate) return false;
            if (description && !m.descripcion.toLowerCase().includes(description)) return false;
            const cantidadEuros = m.cantidad / 100;
            if (minAmount && cantidadEuros < parseFloat(minAmount)) return false;
            if (maxAmount && cantidadEuros > parseFloat(maxAmount)) return false;
            if (cuentas.length > 0) {
                if (m.tipo === 'traspaso' && !cuentas.includes(m.cuentaOrigenId) && !cuentas.includes(m.cuentaDestinoId)) return false;
                if (m.tipo === 'movimiento' && !cuentas.includes(m.cuentaId)) return false;
            }
            if (conceptos.length > 0 && m.tipo === 'movimiento' && !conceptos.includes(m.conceptoId)) return false;
            return true;
        });
        
        db.movimientos = movementsToDisplay;

    } else {
        // MODO SIN FILTRO: Mostramos el scroll infinito y reiniciamos la carga paginada.
        if (scrollTrigger) scrollTrigger.classList.remove('hidden');
        select('diario-filter-active-indicator').classList.add('hidden');
        
        db.movimientos = [];
        lastVisibleMovementDoc = null;
        allMovementsLoaded = false;
        isLoadingMoreMovements = false;
        
        await loadMoreMovements(true); // Carga la primera página
        initMovementsObserver(); // Activa el observador del scroll infinito
        return; // Salimos aquí porque loadMoreMovements ya actualiza la UI
    }
    // ---- FIN DE LA LÓGICA CORREGIDA ----

    await processMovementsForRunningBalance(db.movimientos, true);
    updateVirtualListUI();

    if (db.movimientos.length === 0) {
        const emptyState = select('empty-movimientos');
        if (diarioActiveFilters) {
            emptyState.querySelector('h3').textContent = 'Sin Resultados';
            emptyState.querySelector('p').textContent = 'No se encontraron movimientos que coincidan con tus filtros.';
        } else {
            emptyState.querySelector('h3').textContent = 'Tu historial empieza aquí';
            emptyState.querySelector('p').textContent = 'Pulsa el botón `+` para añadir tu primer ingreso o gasto.';
        }
    }
};
		
	
// =============================================================
// === INICIO: FUNCIÓN RESTAURADA PARA EL WIDGET DE PATRIMONIO ===
// =============================================================
const renderPatrimonioPage = async () => {
    const container = select('patrimonio-completo-container');
    if (!container) return;

    const visibleAccounts = getVisibleAccounts();
    const saldos = await getSaldos();
    const BASE_COLORS = ['#007AFF', '#30D158', '#FFD60A', '#FF3B30', '#C084FC', '#4ECDC4', '#EF626C', '#A8D58A'];

    const allAccountTypes = [...new Set(visibleAccounts.map((c) => toSentenceCase(c.tipo || 'S/T')))].sort();
    const filteredAccountTypes = new Set(allAccountTypes.filter(t => !deselectedAccountTypesFilter.has(t)));

    const colorMap = {};
    allAccountTypes.forEach((tipo, index) => {
        colorMap[tipo] = BASE_COLORS[index % BASE_COLORS.length];
    });

    const pillsHTML = allAccountTypes.map(t => {
        const isActive = !deselectedAccountTypesFilter.has(t);
        const color = colorMap[t];
        let style = '';
        if (isActive && color) {
            style = `style="background-color: ${color}; border-color: ${color}; color: #FFFFFF; box-shadow: 0 0 8px ${color}70;"`;
        }
        return `<button class="filter-pill ${isActive ? 'filter-pill--active' : ''}" data-action="toggle-account-type-filter" data-type="${t}" ${style}>${t}</button>`;
    }).join('') || `<p style="font-size:var(--fs-xs); color:var(--c-on-surface-secondary)">No hay cuentas en esta vista.</p>`;
    
    const filteredAccounts = visibleAccounts.filter(c => {
        const tipo = toSentenceCase(c.tipo || 'S/T');
        return filteredAccountTypes.has(tipo);
    });

    const totalFiltrado = filteredAccounts.reduce((sum, c) => sum + (saldos[c.id] || 0), 0);
    
    const treeData = [];
    filteredAccounts.forEach(c => {
        const saldo = saldos[c.id] || 0;
        if (saldo > 0) {
            treeData.push({ tipo: toSentenceCase(c.tipo || 'S/T'), nombre: c.nombre, saldo: saldo / 100 });
        }
    });

    container.innerHTML = `
        <h3 class="card__title"><span class="material-icons">account_balance</span>Patrimonio</h3>
        <div class="card__content" style="padding-top:0;">
            <div class="patrimonio-header-grid__kpi" style="margin-bottom: var(--sp-4);">
                <h4 class="kpi-item__label">Patrimonio Neto (Seleccionado)</h4>
                <strong id="patrimonio-total-balance" class="kpi-item__value" style="font-size: 2rem; line-height: 1.1;">${formatCurrency(totalFiltrado)}</strong>
            </div>
            <div class="patrimonio-header-grid__filters" style="margin-bottom: var(--sp-4);">
                <h4 class="kpi-item__label">Filtros por tipo de activo</h4>
                <div id="filter-account-types-pills" class="filter-pills" style="margin-bottom: 0;">${pillsHTML}</div>
            </div>
            <div id="liquid-assets-chart-container" class="chart-container" style="height: 250px; margin-bottom: var(--sp-4);"><canvas id="liquid-assets-chart"></canvas></div>
            <div id="patrimonio-cuentas-lista"></div>
        </div>`;

    setTimeout(() => {
        const chartCtx = select('liquid-assets-chart')?.getContext('2d');
        if (chartCtx) {
            if (liquidAssetsChart) liquidAssetsChart.destroy();
            if (treeData.length > 0) {
                liquidAssetsChart = new Chart(chartCtx, { type: 'treemap', data: { datasets: [{ tree: treeData, key: 'saldo', groups: ['tipo', 'nombre'], spacing: 0.5, borderWidth: 1.5, borderColor: getComputedStyle(document.body).getPropertyValue('--c-background'), backgroundColor: (ctx) => (ctx.type === 'data' ? colorMap[ctx.raw._data.tipo] || 'grey' : 'transparent'), labels: { display: true, color: '#FFFFFF', font: { size: 11, weight: '600' }, align: 'center', position: 'middle', formatter: (ctx) => (ctx.raw.g.includes(ctx.raw._data.nombre) ? ctx.raw._data.nombre.split(' ') : null) } }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (ctx) => `${ctx.raw._data.nombre}: ${formatCurrency(ctx.raw.v * 100)}` } }, datalabels: { display: false }}} });
            } else {
                select('liquid-assets-chart-container').innerHTML = `<div class="empty-state" style="padding:16px 0; background:transparent; border:none;"><p>No hay activos con saldo positivo para mostrar.</p></div>`;
            }
        }
        const listaContainer = select('patrimonio-cuentas-lista');
        if (listaContainer) {
            const accountsByType = filteredAccounts.reduce((acc, c) => { const tipo = toSentenceCase(c.tipo || 'S/T'); if (!acc[tipo]) acc[tipo] = []; acc[tipo].push(c); return acc; }, {});
            listaContainer.innerHTML = Object.keys(accountsByType).sort().map(tipo => {
                const accountsInType = accountsByType[tipo];
                const typeBalance = accountsInType.reduce((sum, acc) => sum + (saldos[acc.id] || 0), 0);
                const porcentajeGlobal = totalFiltrado > 0 ? (typeBalance / totalFiltrado) * 100 : 0;
                const accountsHtml = accountsInType.sort((a,b) => a.nombre.localeCompare(b.nombre)).map(c => `<div class="modal__list-item" data-action="view-account-details" data-id="${c.id}" style="cursor: pointer; padding: var(--sp-2) 0;"><div><span style="display: block;">${c.nombre}</span><small style="color: var(--c-on-surface-secondary);">${((saldos[c.id] || 0) / typeBalance * 100).toFixed(1)}% de ${tipo}</small></div><div style="display: flex; align-items: center; gap: var(--sp-2);">${formatCurrency(saldos[c.id] || 0)}<span class="material-icons" style="font-size: 18px;">chevron_right</span></div></div>`).join('');
                if (!accountsHtml) return '';
                return `<details class="accordion" style="margin-bottom: var(--sp-2);"><summary><span class="account-group__name">${tipo}</span><div style="display:flex; align-items:center; gap:var(--sp-2);"><small style="color: var(--c-on-surface-tertiary); margin-right: var(--sp-2);">${porcentajeGlobal.toFixed(1)}%</small><span class="account-group__balance">${formatCurrency(typeBalance)}</span><span class="material-icons accordion__icon">expand_more</span></div></summary><div class="accordion__content" style="padding: 0 var(--sp-3);">${accountsHtml}</div></details>`;
            }).join('');
        }
    }, 50);
};
                
        
        const loadConfig = () => { 
            const userEmailEl = select('config-user-email'); 
            if (userEmailEl && currentUser) userEmailEl.textContent = currentUser.email;
            
            			
        };
    const renderInicioPage  = () => {
    const container = select(PAGE_IDS.INICIO);
    if (!container) return;

    // --- ¡LA CORRECCIÓN CLAVE ESTÁ AQUÍ! ---
    // Antes, esta función borraba todo el HTML del panel.
    // Ahora, ya NO borra nada. Simplemente se asegura de que los widgets
    // se rendericen dentro del contenedor que ya existe en el HTML.
    
    populateAllDropdowns();
    renderInicioResumenView();
};
 
// =====================================================================
// === INICIO: PASO 1 - REEMPLAZA ESTA FUNCIÓN POR COMPLETO          ===
// =====================================================================
/**
 * Genera el HTML para una tarjeta de movimiento o traspaso con sus acciones de swipe.
 * @param {object} m - El objeto del movimiento.
 * @param {object} dbData - Objeto con acceso a `db.cuentas` y `db.conceptos`.
 * @returns {string} El string HTML del componente completo.
 */
const TransactionCardComponent = (m, dbData) => {
    const { cuentas, conceptos } = dbData;
    const highlightClass = (m.id === newMovementIdToHighlight) ? 'list-item-animate' : '';

    const formattedDate = new Date(m.fecha).toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' });
    let cardContentHTML = '';

    if (m.tipo === 'traspaso') {
        const origen = cuentas.find(c => c.id === m.cuentaOrigenId);
        const destino = cuentas.find(c => c.id === m.cuentaDestinoId);
        cardContentHTML = `
            <div class="transaction-card__indicator transaction-card__indicator--transfer"></div>
            <div class="transaction-card__content">
                <div class="transaction-card__details">
                    <div class="transaction-card__concept">${escapeHTML(m.descripcion) || 'Traspaso'}</div>
                    <div class="transaction-card__description">${formattedDate}</div>
                    <div class="transaction-card__transfer-details">
                        <div class="transaction-card__transfer-row">
                            <span><span class="material-icons">arrow_upward</span> ${(origen?.nombre) || '?'}</span>
                            <span class="transaction-card__balance">${formatCurrency(m.runningBalanceOrigen)}</span>
                        </div>
                        <div class="transaction-card__transfer-row">
                            <span><span class="material-icons">arrow_downward</span> ${(destino?.nombre) || '?'}</span>
                            <span class="transaction-card__balance">${formatCurrency(m.runningBalanceDestino)}</span>
                        </div>
                    </div>
                </div>
                <div class="transaction-card__figures">
                    <div class="transaction-card__amount text-info">${formatCurrency(m.cantidad)}</div>
                </div>
            </div>`;
    } else {
        const cuenta = cuentas.find(c => c.id === m.cuentaId);
        const concept = conceptos.find(c => c.id === m.conceptoId);
        const amountClass = m.cantidad >= 0 ? 'text-positive' : 'text-negative';
        const indicatorClass = m.cantidad >= 0 ? 'transaction-card__indicator--income' : 'transaction-card__indicator--expense';
        cardContentHTML = `
            <div class="transaction-card__indicator ${indicatorClass}"></div>
            <div class="transaction-card__content">
                <div class="transaction-card__details">
                    <div class="transaction-card__row-1">${toSentenceCase(concept?.nombre || 'S/C')}</div>
                    <div class="transaction-card__row-2">${formattedDate} • ${escapeHTML(m.descripcion)}</div>
                </div>
                <div class="transaction-card__figures">
                    <div class="transaction-card__amount ${amountClass}">${formatCurrency(m.cantidad)}</div>
                    <div class="transaction-card__balance">${formatCurrency(m.runningBalance)}</div>
                    <div class="transaction-card__row-2" style="text-align: right;">${escapeHTML(cuenta?.nombre || 'S/C')}</div>
                </div>
            </div>`;
    }
    
 // Envolvemos el contenido de la tarjeta con el contenedor de swipe y sus acciones
    return `
    <div class="swipe-container list-item-animate">
        <div class="swipe-actions-container left">
            <button class="swipe-action-btn duplicate" data-action="swipe-duplicate-movement" data-id="${m.id}">
                <span class="material-icons">content_copy</span>
                <span>Duplicar</span>
            </button>
        </div>
        <div class="swipe-actions-container right">
            <button class="swipe-action-btn delete" data-action="swipe-delete-movement" data-id="${m.id}" data-is-recurrent="false">
                <span class="material-icons">delete</span>
                <span>Borrar</span>
            </button>
        </div>
        <div class="transaction-card ${highlightClass}" data-id="${m.id}" data-action="edit-movement-from-list">
            ${cardContentHTML}
        </div>
    </div>`;
};
// ▼▼▼ REEMPLAZA TU FUNCIÓN renderPortfolioEvolutionChart CON ESTA VERSIÓN ESPECTACULAR ▼▼▼

/**
 * Renderiza un gráfico de área apilado que muestra la evolución del capital aportado y las ganancias/pérdidas.
 * @param {string} targetContainerId - El ID del contenedor donde se dibujará el gráfico.
 */
async function renderPortfolioEvolutionChart(targetContainerId) {
    const container = select(targetContainerId);
    if (!container) return;

    container.innerHTML = `<div class="chart-container skeleton" style="height: 220px; border-radius: var(--border-radius-lg);"><canvas id="portfolio-evolution-chart"></canvas></div>`;

    await loadInversiones();
    const allMovements = await fetchAllMovementsForHistory();

    const filteredInvestmentAccounts = getVisibleAccounts().filter(account => {
        const accountType = toSentenceCase(account.tipo || 'S/T');
        return !deselectedInvestmentTypesFilter.has(accountType) && account.esInversion;
    });
    const filteredAccountIds = new Set(filteredInvestmentAccounts.map(c => c.id));

    if (filteredInvestmentAccounts.length === 0) {
        container.innerHTML = `<div class="empty-state" style="padding:16px 0; background:transparent; border:none;"><p>No hay activos seleccionados para mostrar la evolución.</p></div>`;
        return;
    }

    // 1. Recopilamos todos los eventos (esta parte no cambia)
    const timeline = [];
    const history = (db.inversiones_historial || []).filter(h => filteredAccountIds.has(h.cuentaId));
    history.forEach(v => timeline.push({ date: v.fecha.slice(0, 10), type: 'valuation', value: v.valor, accountId: v.cuentaId }));

    const cashFlowMovements = allMovements.filter(m => {
        return (m.tipo === 'movimiento' && filteredAccountIds.has(m.cuentaId)) ||
               (m.tipo === 'traspaso' && (filteredAccountIds.has(m.cuentaOrigenId) || filteredAccountIds.has(m.cuentaDestinoId)));
    });
    cashFlowMovements.forEach(m => {
        let amount = 0;
        if (m.tipo === 'movimiento') amount = m.cantidad;
        else if (m.tipo === 'traspaso') {
            if (filteredAccountIds.has(m.cuentaDestinoId) && !filteredAccountIds.has(m.cuentaOrigenId)) amount = m.cantidad;
            if (filteredAccountIds.has(m.cuentaOrigenId) && !filteredAccountIds.has(m.cuentaDestinoId)) amount = -m.cantidad;
        }
        if (amount !== 0) timeline.push({ date: m.fecha.slice(0, 10), type: 'cashflow', value: amount });
    });
    
    if (timeline.length < 1) {
         container.innerHTML = `<div class="empty-state" style="padding:16px 0; background:transparent; border:none;"><p>No hay datos suficientes para mostrar la evolución.</p></div>`;
         return;
    }
    timeline.sort((a, b) => new Date(a.date) - new Date(b.date));

    // 2. Procesamos la línea de tiempo (esta parte no cambia)
    const dailyData = new Map();
    let runningCapital = 0;
    const lastKnownValues = new Map();

    timeline.forEach(event => {
        if (!dailyData.has(event.date)) {
            const prevDate = new Date(event.date); prevDate.setDate(prevDate.getDate() - 1);
            const prevDateKey = prevDate.toISOString().slice(0, 10);
            dailyData.set(event.date, dailyData.has(prevDateKey) ? { ...dailyData.get(prevDateKey) } : { capital: runningCapital, value: 0 });
        }
        const day = dailyData.get(event.date);
        if (event.type === 'cashflow') {
            runningCapital += event.value;
            day.capital = runningCapital;
        } else if (event.type === 'valuation') {
            lastKnownValues.set(event.accountId, event.value);
        }
        let totalValue = 0;
        for(const id of filteredAccountIds) totalValue += lastKnownValues.get(id) || 0;
        day.value = totalValue;
    });

    // 3. Preparamos datos para Chart.js (esta parte no cambia)
    const sortedDates = [...dailyData.keys()].sort();
    const chartLabels = sortedDates;
    const capitalData = sortedDates.map(date => dailyData.get(date).capital / 100);
    const totalValueData = sortedDates.map(date => dailyData.get(date).value / 100);

    // --- ¡AQUÍ EMPIEZA LA NUEVA MAGIA VISUAL! ---
    const chartCanvas = select('portfolio-evolution-chart');
    const chartCtx = chartCanvas ? chartCanvas.getContext('2d') : null;
    if (!chartCtx) return;

    if (Chart.getChart(chartCanvas)) Chart.getChart(chartCanvas).destroy();
    chartCanvas.closest('.chart-container').classList.remove('skeleton');

    // Creamos el gradiente para el área
    const primaryColor = getComputedStyle(document.body).getPropertyValue('--c-primary').trim();
    const gradient = chartCtx.createLinearGradient(0, 0, 0, 220);
    gradient.addColorStop(0, primaryColor.replace(')', ', 0.6)'));
    gradient.addColorStop(1, primaryColor.replace(')', ', 0.05)'));
    
    new Chart(chartCtx, {
        type: 'line',
        data: {
            labels: chartLabels,
            datasets: [
                {
                    label: 'Valor Total',
					data: totalValueData,
					borderColor: primaryColor,      // Mantenemos el color principal para la línea
					backgroundColor: gradient,      // El gradiente para el área se queda igual
					
					tension: 0.4,
					pointRadius: 0,
					borderWidth: 2.5,               // Un grosor de 2.5px para que la línea se vea bien definida
		},
                {
                    label: 'Capital Aportado',
                    data: capitalData,
                    borderColor: getComputedStyle(document.body).getPropertyValue('--c-info').trim(),
                    fill: false,
                    pointRadius: 0,
                    borderWidth: 2,
                    borderDash: [5, 5], // <-- Línea punteada para que sea una referencia
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: false,
                    ticks: { callback: value => formatCurrency(value * 100) }
                },
                x: {
                    type: 'time',
                    time: { unit: 'month', tooltipFormat: 'dd MMM yyyy' },
                    grid: { display: false }
                }
            },
            plugins: {
                legend: { position: 'bottom', labels: { usePointStyle: true } },
                datalabels: { display: false },
                // Tooltip mejorado para mostrar el P&L calculado al momento
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        label: (context) => {
                            const label = context.dataset.label || '';
                            const value = context.parsed.y;
                            return `${label}: ${formatCurrency(value * 100)}`;
                        },
                        footer: (tooltipItems) => {
                            const total = tooltipItems.find(i => i.dataset.label === 'Valor Total')?.parsed.y || 0;
                            const capital = tooltipItems.find(i => i.dataset.label === 'Capital Aportado')?.parsed.y || 0;
                            const pnl = total - capital;
                            const pnlFormatted = formatCurrency(pnl * 100);
                            // Le damos un color al P&L en el tooltip
                            return `P&L: ${pnlFormatted}`;
                        }
                    }
                }
            },
            interaction: { mode: 'index', intersect: false }
        }
    });
}
 
// =================================================================
// === INICIO: NUEVO MOTOR DE RENDERIZADO DE INFORMES (v2.0) ===
// =================================================================

// Esta variable global evitará errores de "Canvas en uso"
let informeActivoChart = null;



/**
 * Función "router" que llama al renderizador de informe correcto cuando se abre un acordeón.
 * @param {string} informeId - El ID del informe a mostrar.
 */
async function renderInformeDetallado(informeId) {
    const container = select(`informe-content-${informeId}`);
    if (!container) return;

    if (informeActivoChart) {
        informeActivoChart.destroy();
        informeActivoChart = null;
    }
    
    container.innerHTML = `<div class="skeleton" style="height: 200px; border-radius: var(--border-radius-lg);"></div>`;

    try {
        const reportRenderers = {
            'extracto_cuenta': () => { // El extracto tiene una lógica de formulario diferente
                const content = `
                    <form id="informe-cuenta-form" novalidate>
                        <div class="form-group">
                            <label for="informe-cuenta-select" class="form-label">Selecciona una cuenta para ver su historial completo:</label>
                            <select id="informe-cuenta-select" class="form-select" required></select>
                        </div>
                        <button type="submit" class="btn btn--primary btn--full">Generar Extracto</button>
                    </form>
                    <div id="informe-resultado-container" style="margin-top: var(--sp-4);"></div>`;
                container.innerHTML = content;
                const populate = (id, data, nameKey, valKey='id') => {
                    const el = select(id); if (!el) return;
                    let opts = '<option value="">Seleccionar cuenta...</option>';
                    [...data].sort((a,b) => (a[nameKey]||"").localeCompare(b[nameKey]||"")).forEach(i => opts += `<option value="${i[valKey]}">${i[nameKey]}</option>`);
                    el.innerHTML = opts;
                };
                populate('informe-cuenta-select', getVisibleAccounts(), 'nombre', 'id');
            },
            
            // Aquí puedes añadir más informes en el futuro
        };

        if (reportRenderers[informeId]) {
            await reportRenderers[informeId](container);
        } else {
            container.innerHTML = `<div class="empty-state"><p>Informe no disponible.</p></div>`;
        }
    } catch (error) {
        console.error(`Error al renderizar el informe '${informeId}':`, error);
        container.innerHTML = `<div class="empty-state text-danger"><p>Error al generar el informe.</p></div>`;
    }
}

   
const renderDashboardActionCenter = () => {
    return `
    <div class="card" id="action-center-widget">
        <h3 class="card__title">
            <span class="material-icons text-warning">notifications_active</span>
            <span>Centro de Acciones</span>
        </h3>
        <div class="card__content" id="action-center-content" style="padding-top: 0; padding-bottom: var(--sp-2);">
            <div class="skeleton" style="height: 70px; border-radius: var(--border-radius-md);"></div>
        </div>
    </div>`;
};

/**
 * Renderiza el esqueleto del nuevo widget "Evolución del Patrimonio".
 */
const renderDashboardNetWorthTrend = () => {
    return `
    <div class="card" id="net-worth-trend-widget">
        <h3 class="card__title"><span class="material-icons">show_chart</span>Evolución del Patrimonio Neto</h3>
        <div class="card__content">
            <div class="chart-container skeleton" style="height: 220px; border-radius: var(--border-radius-lg);">
                <canvas id="net-worth-chart"></canvas>
            </div>
        </div>
    </div>`;
};


/**
 * Dibuja un gráfico de tipo "gauge" (velocímetro) para la Tasa de Ahorro.
 * @param {string} canvasId - El ID del elemento canvas.
 * @param {number} percentage - El porcentaje de ahorro a mostrar.
 */
const renderSavingsRateGauge = (canvasId, percentage) => {
    const canvas = select(canvasId);
    const ctx = canvas ? canvas.getContext('2d') : null;
    if (!ctx) return;

    if (Chart.getChart(canvasId)) {
        Chart.getChart(canvasId).destroy();
    }

    let color;
    if (percentage < 0) color = 'var(--c-danger)';
    else if (percentage < 10) color = 'var(--c-warning)';
    else color = 'var(--c-success)';
    
    const value = Math.max(0, Math.min(100, percentage)); // Aseguramos que el valor esté entre 0 y 100 para el gráfico

    new Chart(ctx, {
        type: 'doughnut',
        data: {
            datasets: [{
                data: [value, 100 - value],
                backgroundColor: [getComputedStyle(document.body).getPropertyValue(color).trim(), getComputedStyle(document.body).getPropertyValue('--c-surface-variant').trim()],
                borderColor: 'transparent',
                borderWidth: 0,
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            rotation: -90,
            circumference: 180,
            cutout: '65%',
            plugins: {
                legend: { display: false },
                tooltip: { enabled: false },
                datalabels: { display: false }
            }
        }
    });
};

const renderDashboardKpiSummary = () => {
   // ¡Simplemente eliminamos el atributo style!
   return `<div class="kpi-grid" id="kpi-container">
            <div class="kpi-item">
                <h4 class="kpi-item__label">Ingresos</h4>
                <strong id="kpi-ingresos-value" class="kpi-item__value text-positive skeleton" data-current-value="0">+0,00 €</strong> 
                <div id="kpi-ingresos-comparison" class="kpi-item__comparison"></div>
            </div>
            <div class="kpi-item">
                <h4 class="kpi-item__label">Gastos</h4>
                <strong id="kpi-gastos-value" class="kpi-item__value text-negative skeleton" data-current-value="0">0,00 €</strong>
                <div id="kpi-gastos-comparison" class="kpi-item__comparison"></div>
            </div>
            <div class="kpi-item">
                <h4 class="kpi-item__label">Saldo Neto Periodo</h4>
                <strong id="kpi-saldo-neto-value" class="kpi-item__value skeleton" data-current-value="0">0,00 €</strong>
                <div id="kpi-saldo-neto-comparison" class="kpi-item__comparison"></div>
            </div>
        </div>`;
};
// ▼▼▼ REEMPLAZA TU FUNCIÓN renderDashboardSuperCentroOperaciones CON ESTA VERSIÓN REORDENADA ▼▼▼

const renderDashboardSuperCentroOperaciones = () => {
    const skeletonRows = Array(3).fill('<div class="skeleton" style="height: 48px; margin-bottom: var(--sp-2); border-radius: 8px;"></div>').join('');
    
    return `
    <div class="card card--no-bg" id="super-centro-operaciones-widget">
        <div class="accordion-wrapper">
            <details class="accordion" open>
                <summary>
                    <h3 class="card__title" style="margin: 0; padding: 0; color: var(--c-on-surface);">
                        <span class="material-icons">query_stats</span>
                        Centro de Operaciones
                    </h3>
                    <span class="material-icons accordion__icon">expand_more</span>
                </summary>

                <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                    
                    <div class="kpi-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
                        <div class="kpi-item">
                            <h4 class="kpi-item__label" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                <span>Patrimonio Neto Total</span>
                                <button class="icon-btn" data-action="show-help-topic" data-topic="patrimonio-neto" style="width: 20px; height: 20px;">
                                    <span class="material-icons" style="font-size: 16px;">help_outline</span>
                                </button>
                            </h4>
                            <strong id="kpi-patrimonio-neto-value" class="kpi-item__value skeleton" data-current-value="0">0,00 €</strong>
                            <div class="kpi-item__comparison">Vista global actual</div>
                        </div>
                        <div class="kpi-item">
                            <h4 class="kpi-item__label" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                <span>Tasa de Ahorro</span>
                                <button class="icon-btn" data-action="show-help-topic" data-topic="tasa-ahorro" style="width: 20px; height: 20px;">
                                    <span class="material-icons" style="font-size: 16px;">help_outline</span>
                                </button>
                            </h4>
                            <div style="position: relative; height: 60px; margin: auto;">
                                 <canvas id="kpi-savings-rate-chart"></canvas>
                                 <div id="kpi-tasa-ahorro-value" class="kpi-item__value skeleton" style="position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);">0%</div>
                            </div>
                            <div id="kpi-tasa-ahorro-comparison" class="kpi-item__comparison"></div>
                        </div>
                        <div class="kpi-item">
                            <h4 class="kpi-item__label" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                                <span>P&L Portafolio Inversión</span>
                                 <button class="icon-btn" data-action="show-help-topic" data-topic="pnl-inversion" style="width: 20px; height: 20px;">
                                    <span class="material-icons" style="font-size: 16px;">help_outline</span>
                                </button>
                            </h4>
                            <strong id="kpi-pnl-inversion-value" class="kpi-item__value skeleton" data-current-value="0">0,00 €</strong>
                            <div id="kpi-pnl-inversion-comparison" class="kpi-item__comparison">Rentabilidad total</div>
                        </div>
                    </div>

                    <hr style="border-color: var(--c-outline); opacity: 0.5; margin: var(--sp-5) 0;">

                    <div class="kpi-grid" id="kpi-container" style="margin-bottom: var(--sp-5);">
                        <button class="kpi-item" data-action="show-kpi-drilldown" data-type="ingresos">
                            <h4 class="kpi-item__label">Ingresos</h4>
                            <strong id="kpi-ingresos-value" class="kpi-item__value text-positive skeleton" data-current-value="0">+0,00 €</strong> 
                            <div id="kpi-ingresos-comparison" class="kpi-item__comparison"></div>
                        </button>
                        <button class="kpi-item" data-action="show-kpi-drilldown" data-type="gastos">
                            <h4 class="kpi-item__label">Gastos</h4>
                            <strong id="kpi-gastos-value" class="kpi-item__value text-negative skeleton" data-current-value="0">0,00 €</strong>
                            <div id="kpi-gastos-comparison" class="kpi-item__comparison"></div>
                        </button>
                        <button class="kpi-item" data-action="show-kpi-drilldown" data-type="saldoNeto">
                            <h4 class="kpi-item__label">Saldo Neto Periodo</h4>
                            <strong id="kpi-saldo-neto-value" class="kpi-item__value skeleton" data-current-value="0">0,00 €</strong>
                            <div id="kpi-saldo-neto-comparison" class="kpi-item__comparison"></div>
                        </button>
                    </div>
                    
                    <hr style="border-color: var(--c-outline); opacity: 0.5; margin: var(--sp-5) 0;">

                    <h3 class="card__title" style="padding: 0 0 var(--sp-3) 0;"><span class="material-icons">category</span>Totales por Concepto</h3>
                    <div class="chart-container skeleton" style="height: 240px; margin-bottom: var(--sp-2); border-radius: var(--border-radius-lg);">
                        <canvas id="conceptos-chart"></canvas>
                    </div>
                    <div id="concepto-totals-list">${skeletonRows}</div>

                </div>
            </details>
        </div>
    </div>`;
};

const renderDashboardExpandedKpiSummary = () => {
    return `
    <div class="card" id="kpi-ampliado-widget">
        <h3 class="card__title"><span class="material-icons">query_stats</span>Centro de Operaciones</h3>
        <div class="card__content">
            <div class="kpi-grid" style="grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));">
                
                <div class="kpi-item">
                    <h4 class="kpi-item__label" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                        <span>Tasa de Ahorro</span>
                        <button class="icon-btn" data-action="show-help-topic" data-topic="tasa-ahorro" style="width: 20px; height: 20px;">
                            <span class="material-icons" style="font-size: 16px;">help_outline</span>
                        </button>
                    </h4>
                    <div style="position: relative; height: 60px; margin: auto;">
                         <canvas id="kpi-savings-rate-chart"></canvas>
                         <div id="kpi-tasa-ahorro-value" class="kpi-item__value skeleton" style="position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);">0%</div>
                    </div>
                    <div id="kpi-tasa-ahorro-comparison" class="kpi-item__comparison"></div>
                </div>

                <div class="kpi-item">
                    <h4 class="kpi-item__label" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                        <span>Patrimonio Neto Total</span>
                        <button class="icon-btn" data-action="show-help-topic" data-topic="patrimonio-neto" style="width: 20px; height: 20px;">
                            <span class="material-icons" style="font-size: 16px;">help_outline</span>
                        </button>
                    </h4>
                    <strong id="kpi-patrimonio-neto-value" class="kpi-item__value skeleton" data-current-value="0">0,00 €</strong>
                    <div class="kpi-item__comparison">Vista global actual</div>
                </div>
                
                <div class="kpi-item">
                    <h4 class="kpi-item__label" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                        <span>P&L Portafolio Inversión</span>
                         <button class="icon-btn" data-action="show-help-topic" data-topic="pnl-inversion" style="width: 20px; height: 20px;">
                            <span class="material-icons" style="font-size: 16px;">help_outline</span>
                        </button>
                    </h4>
                    <strong id="kpi-pnl-inversion-value" class="kpi-item__value skeleton" data-current-value="0">0,00 €</strong>
                    <div id="kpi-pnl-inversion-comparison" class="kpi-item__comparison">Rentabilidad total</div>
                </div>

                <div class="kpi-item" style="grid-column: 1 / -1;">
                     <h4 class="kpi-item__label" style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                        <span>Progreso Presupuesto (Gastos del Periodo)</span>
                        <button class="icon-btn" data-action="show-help-topic" data-topic="progreso-presupuesto" style="width: 20px; height: 20px;">
                            <span class="material-icons" style="font-size: 16px;">help_outline</span>
                        </button>
                    </h4>
                    <div class="budget-item__progress" style="margin: 8px 0;">
                        <progress id="kpi-presupuesto-progress" max="100" value="0" style="width: 100%; height: 8px;" class="budget-item__progress"></progress>
                    </div>
                    <div id="kpi-presupuesto-text" class="kpi-item__comparison skeleton" style="height: auto; min-height: 14px;">Calculando...</div>
                </div>

            </div>
        </div>
    </div>`;
};
           const renderDashboardConceptTotals = () => {
            // Generamos 3 filas de esqueleto para la lista
            const skeletonRows = Array(3).fill('<div class="skeleton" style="height: 48px; margin-bottom: var(--sp-2); border-radius: 8px;"></div>').join('');
            
            return `
                <div class="card card--no-bg" id="concept-totals-widget">
                    <div class="accordion-wrapper">
                        <details class="accordion" open>
                            <summary>
                                <h3 class="card__title" style="margin: 0; padding: 0; color: var(--c-on-surface);"><span class="material-icons">category</span>Totales por Concepto</h3>
                                <span class="material-icons accordion__icon">expand_more</span>
                            </summary>
                            <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                                <div class="chart-container skeleton" style="height: 240px; margin-bottom: var(--sp-2); border-radius: var(--border-radius-lg);">
                                    <canvas id="conceptos-chart"></canvas>
                                </div>
                                <div id="concepto-totals-list">${skeletonRows}</div>
                            </div>
                        </details>
                    </div>
                </div>`;
        };

/// ▼▼▼ REEMPLAZA TU FUNCIÓN renderInicioResumenView POR COMPLETO CON ESTA VERSIÓN ▼▼▼
const renderInicioResumenView = () => {
    const resumenContentContainer = select('resumen-content-container');
    if (!resumenContentContainer) return;

    destroyAllCharts();

    const widgetOrder = (db.config && db.config.dashboardWidgets) || DEFAULT_DASHBOARD_WIDGETS;

    // AHORA, esta función solo imprime los esqueletos con una etiqueta especial.
    resumenContentContainer.innerHTML = widgetOrder.map(widgetId => {
        // La etiqueta es 'data-widget-type'
        switch(widgetId) {
            case 'super-centro-operaciones':
                // La función renderDashboardSuperCentroOperaciones() ya devuelve el esqueleto,
                // solo necesitamos añadirle nuestra etiqueta al div principal.
                return `<div data-widget-type="super-centro-operaciones">${renderDashboardSuperCentroOperaciones()}</div>`;
            
            case 'net-worth-trend':
                return `<div data-widget-type="net-worth-trend">${renderDashboardNetWorthTrend()}</div>`;
            
            case 'patrimonio-structure':
               return `<div data-widget-type="patrimonio-structure">
                           <div class="card" id="patrimonio-widget">
                               <div id="patrimonio-completo-container">
                                   <div class="skeleton" style="height:250px;"></div>
                               </div>
                           </div>
                       </div>`;
            
            // Repetimos el patrón para los demás widgets...
            case 'action-center':
                return `<div data-widget-type="action-center">${renderDashboardActionCenter()}</div>`;
            case 'informe-personalizado':
                 return `<div data-widget-type="informe-personalizado">${renderDashboardInformeWidget()}</div>`;
            default:
                return '';
        }
    }).join('<div style="height: var(--sp-4);"></div>');
    
    // ¡IMPORTANTE! Después de dibujar los esqueletos, le decimos a nuestro "asistente" que empiece a observar.
    initWidgetObserver();
};
		
        const _renderRecientesFromCache = async () => {
            const recientesContainer = select('inicio-view-recientes');
            if (!recientesContainer) return;
            
            const movsToDisplay = recentMovementsCache;
            
            if (movsToDisplay.length === 0) {
                recientesContainer.innerHTML = `<div class="empty-state" style="border: none; background: transparent;"><p>No hay movimientos recientes en esta contabilidad.</p></div>`;
                return;
            }

            await processMovementsForRunningBalance(movsToDisplay, true); 

            const grouped = {};
            const visibleAccountIds = new Set(getVisibleAccounts().map(c => c.id));
            movsToDisplay.forEach(mov => {
                const dateKey = mov.fecha.slice(0, 10);
                if (!grouped[dateKey]) {
                    grouped[dateKey] = { movements: [], total: 0 };
                }
                grouped[dateKey].movements.push(mov);
                if (mov.tipo === 'traspaso') {
                    const origenVisible = visibleAccountIds.has(mov.cuentaOrigenId);
                    const destinoVisible = visibleAccountIds.has(mov.cuentaDestinoId);
                    if (origenVisible && !destinoVisible) { grouped[dateKey].total -= mov.cantidad; }
                    else if (!origenVisible && destinoVisible) { grouped[dateKey].total += mov.cantidad; }
                } else {
                    grouped[dateKey].total += mov.cantidad;
                }
            });

            let html = '';
            const sortedDates = Object.keys(grouped).sort((a, b) => b.localeCompare(a));
            for (const dateKey of sortedDates) {
                const group = grouped[dateKey];
                html += renderVirtualListItem({ type: 'date-header', date: dateKey, total: group.total });
                
                group.movements.sort((a, b) => b.id.localeCompare(a.id));

                for (const mov of group.movements) {
                    html += renderVirtualListItem({ type: 'transaction', movement: mov });
                }
            }
            html += `<div style="text-align: center; margin-top: var(--sp-4);"><button class="btn btn--secondary" data-action="navigate" data-page="${PAGE_IDS.DIARIO}">Ver todos los movimientos</button></div>`;
            recientesContainer.innerHTML = html;
        };
		 const renderPendingRecurrents = () => {
    const container = select('pending-recurrents-container');
    if (!container || !db.recurrentes) return;

    const now = new Date();
    const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    
    const pending = db.recurrentes
    .filter(r => {
        // --- ¡ESTA ES LA CORRECCIÓN CLAVE! ---
        // Primero, nos aseguramos de que la fecha existe antes de intentar usarla.
        if (!r.nextDate) return false;

        const nextDate = parseDateStringAsUTC(r.nextDate);
        // Segundo, comprobamos que la fecha se ha podido interpretar correctamente.
        if (!nextDate) return false;

        const normalizedNextDate = new Date(Date.UTC(nextDate.getUTCFullYear(), nextDate.getUTCMonth(), nextDate.getUTCDate()));
        return normalizedNextDate <= today;
    })
    .sort((a, b) => new Date(a.nextDate) - new Date(b.nextDate));

    if (pending.length === 0) {
        container.innerHTML = '';
        return;
    }

    const itemsHTML = pending.map(r => {
        const nextDate = new Date(r.nextDate + 'T12:00:00Z');
        const formattedDate = nextDate.toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric' });
        const amountClass = r.cantidad >= 0 ? 'text-positive' : 'text-negative';
        const dateText = `Pendiente desde: ${formattedDate}`;

        return `
        <div class="transaction-card" id="pending-recurrente-${r.id}" style="background-color: color-mix(in srgb, var(--c-warning) 10%, transparent);">
            <div class="transaction-card__indicator transaction-card__indicator--recurrent"></div>
            <div class="transaction-card__content">
                <div class="transaction-card__details">
                    <div class="transaction-card__row-1">${escapeHTML(r.descripcion)}</div>
                    <div class="transaction-card__row-2" style="font-weight: 600; color: var(--c-warning);">${dateText}</div>
                </div>
                <div class="transaction-card__figures" style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                    <strong class="transaction-card__amount ${amountClass}">${formatCurrency(r.cantidad)}</strong>
                <div style="display: flex; align-items: center; gap: 8px;">
                <div class="transaction-card__recurrent-actions">
    <button class="btn btn--secondary" data-action="skip-recurrent" data-id="${r.id}" title="Omitir esta vez" style="padding: 4px 8px; font-size: 0.7rem;">
<span class="material-icons" style="font-size: 14px;">skip_next</span>No añadir
</button>
<button class="btn btn--primary" data-action="confirm-recurrent" data-id="${r.id}" title="Crear el movimiento ahora" style="padding: 4px 8px; font-size: 0.7rem;">
<span class="material-icons" style="font-size: 14px;">check</span>Añadir Ahora
</button>
</div>
</div>
</div>
`;
}).join('');

            container.innerHTML = `
        <div class="card card--no-bg accordion-wrapper" style="margin-top: var(--sp-4);">
            <details class="accordion" open>
                <summary>
                    <h3 class="card__title" style="margin: 0; padding: 0; color: var(--c-on-surface);">
                        <span class="material-icons">event_repeat</span>
                        Operaciones Recurrentes Pendientes
                    </h3>
                    <span class="material-icons accordion__icon">expand_more</span>
                </summary>
                <div class="accordion__content" style="padding: 0 var(--sp-2) var(--sp-2) var(--sp-2);">
                <div class="contenedor-recurrentes-vertical">
            ${itemsHTML}
        </div>
    </div>
            </details>
        </div>
    `;
};

const renderOtrosPage = () => {
    const container = select(PAGE_IDS.OTROS);
    if(!container) return;

    // Construimos el HTML de la nueva página usando acordeones para organizar el contenido.
    container.innerHTML = `
        <div class="card card--no-bg accordion-wrapper">
            
            <!-- Acordeón para Movimientos Recurrentes -->
            <details class="accordion">
                <summary>
                    <h3 class="card__title" style="margin:0; padding: 0; color: var(--c-on-surface);"><span class="material-icons">event_repeat</span>Movimientos Recurrentes</h3>
                    <span class="material-icons accordion__icon">expand_more</span>
                </summary>
                <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                    <div id="pending-recurrents-container"></div>
                    <p class="form-label" style="margin-bottom: var(--sp-3);">Pulsa en una operación para editarla. Estas son las que se ejecutarán en el futuro.</p>
                    <div id="recurrentes-list-container"></div>
                </div>
            </details>

            <!-- Acordeón para Extracto de Cuenta -->
            <details id="acordeon-extracto_cuenta" class="accordion informe-acordeon">
                <summary>
                    <h3 class="card__title" style="margin:0; padding: 0; color: var(--c-on-surface);">
                        <span class="material-icons">wysiwyg</span>
                        <span>Extracto de Cuenta (Cartilla)</span>
                    </h3>
                    <span class="material-icons accordion__icon">expand_more</span>
                </summary>
                <div class="accordion__content" style="padding: var(--sp-3) var(--sp-4);">
                    <div id="informe-content-extracto_cuenta">
                         <form id="informe-cuenta-form" novalidate>
                            <div class="form-group">
                                <label for="informe-cuenta-select" class="form-label">Selecciona una cuenta:</label>
                                <select id="informe-cuenta-select" class="form-select" required></select>
                            </div>
                            <button type="submit" class="btn btn--primary btn--full">Generar Extracto</button>
                        </form>
                        <div id="informe-resultado-container" style="margin-top: var(--sp-4);"></div>
                    </div>
                </div>
            </details>

        </div>
    `;
    
    // Llamamos a las funciones que rellenan este HTML con datos.
    populateAllDropdowns(); // Para que el selector de cuentas del extracto funcione.
    renderPendingRecurrents();
    renderRecurrentsListOnPage();
};

 const renderInversionesView = () => {
    const container = select(PAGE_IDS.INVERSIONES);
    if (!container) return;

    // Ahora esta función se encarga de TODO: crea el esqueleto y llama a las funciones que lo rellenan.
    container.innerHTML = `
        <div id="inversiones-content-container">
            <!-- Nuevo Acordeón para el Gráfico de Evolución -->
            <details class="accordion" open style="margin-bottom: var(--sp-4);">
                <summary>
                    <h3 class="card__title" style="margin:0; padding: 0; color: var(--c-on-surface);">
                        <span class="material-icons">show_chart</span>
                        Evolución del Portafolio
                    </h3>
                    <span class="material-icons accordion__icon">expand_more</span>
                </summary>
                <div class="accordion__content" id="portfolio-evolution-container" style="padding: var(--sp-3) var(--sp-4);">
                    <!-- Esqueleto de carga para el gráfico de evolución -->
                    <div class="chart-container skeleton" style="height: 220px; border-radius: var(--border-radius-lg);"></div>
                </div>
            </details>

            <!-- El resto de tu HTML de la página de Inversiones se generará después -->
            <div id="portfolio-main-content">
                <!-- Esqueleto de carga para el resto de la página -->
                <div class="skeleton" style="height: 300px; border-radius: var(--border-radius-lg);"></div>
            </div>
        </div>
    `;
	    // Llamamos a las dos funciones que rellenarán cada parte.
    setTimeout(async () => {
        await renderPortfolioEvolutionChart('portfolio-evolution-container');
        await renderPortfolioMainContent('portfolio-main-content');
    }, 50);
};


const renderRecurrentsListOnPage = () => {
    const container = select('recurrentes-list-container');
    if (!container) return;

    const now = new Date();
    const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));

    const upcomingRecurrents = (db.recurrentes || [])
        .filter(r => {
            const nextDate = parseDateStringAsUTC(r.nextDate);
            // Si no hay fecha, no lo mostramos para evitar errores
            if (!nextDate) return false; 
            const normalizedNextDate = new Date(Date.UTC(nextDate.getUTCFullYear(), nextDate.getUTCMonth(), nextDate.getUTCDate()));
            return normalizedNextDate > today;
        })
        .sort((a, b) => new Date(a.nextDate) - new Date(b.nextDate));

    if (upcomingRecurrents.length === 0) {
        container.innerHTML = `<div class="empty-state" style="background: transparent; border: none; padding-top: var(--sp-2);"><p>No tienes operaciones programadas a futuro.</p></div>`;
        return;
    }

    container.innerHTML = upcomingRecurrents.map(r => {
        const nextDate = new Date(r.nextDate).toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric' });
        
        // --- ¡AQUÍ ESTÁ LA CORRECCIÓN IMPORTANTE! ---
        const frequencyMap = { once: 'Única vez', daily: 'Diaria', weekly: 'Semanal', monthly: 'Mensual', yearly: 'Anual' };
        
        const amountClass = r.cantidad >= 0 ? 'text-positive' : 'text-negative';
        const icon = r.cantidad >= 0 ? 'south_west' : 'north_east';
        
        return `
        <div class="modal__list-item" id="page-recurrente-item-${r.id}" data-action="edit-recurrente" data-id="${r.id}" style="cursor: pointer;">
            <div style="display: flex; align-items: center; gap: 12px; flex-grow: 1; min-width: 0;">
                <span class="material-icons ${amountClass}" style="font-size: 20px;">${icon}</span>
                <div style="display: flex; flex-direction: column; min-width: 0;">
                    <span style="font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHTML(r.descripcion)}</span>
                    <small style="color: var(--c-on-surface-secondary); font-size: var(--fs-xs);">Próximo: ${nextDate} (${frequencyMap[r.frequency] || 'N/A'})</small>
                </div>
            </div>
            <strong class="${amountClass}" style="margin-right: var(--sp-2);">${formatCurrency(r.cantidad)}</strong>
        </div>`;
    }).join('');
};

// Define los colores para cada componente del patrimonio
const NET_WORTH_COMPONENT_COLORS = {
    'Líquido': 'rgba(0, 122, 255, 0.7)',      // Azul (var(--c-primary))
    'Inversión': 'rgba(48, 209, 88, 0.7)',   // Verde (var(--c-success))
    'Propiedades': 'rgba(191, 90, 242, 0.7)', // Púrpura (var(--c-info))
    'Deuda': 'rgba(255, 69, 58, 0.7)'         // Rojo (var(--c-danger))
};

/**
 * Clasifica un tipo de cuenta en una de las categorías principales del patrimonio.
 * @param {string} accountType - El tipo de cuenta (ej. "Banco", "Broker").
 * @returns {string} La categoría del componente ('Líquido', 'Inversión', 'Propiedades', 'Deuda').
 */
const getNetWorthComponent = (accountType) => {
    const type = (accountType || '').toUpperCase();
    if (['PRÉSTAMO', 'TARJETA DE CRÉDITO'].includes(type)) return 'Deuda';
    if (['PROPIEDAD', 'INMOBILIARIO'].includes(type)) return 'Propiedades';
    if (['BROKER', 'FONDOS', 'RENTA FIJA', 'PENSIÓN', 'CRIPTO', 'FINTECH'].includes(type) || type.includes('INVERSIÓN')) return 'Inversión';
    return 'Líquido'; // Por defecto, todo lo demás es líquido (Banco, Ahorro, Efectivo, etc.)
};

/**
 * Suaviza los datos diarios a puntos semanales para un gráfico más limpio y rápido.
 * @param {object} dailyData - Objeto con datos diarios.
 * @returns {object} Objeto con datos semanales.
 */
const resampleDataWeekly = (dailyData) => {
    const weeklyData = {};
    const sortedDates = Object.keys(dailyData).sort();

    if (sortedDates.length === 0) return {};

    let lastDate = null;
    sortedDates.forEach(dateStr => {
        const date = new Date(dateStr);
        // Usamos el domingo (día 0) como fin de la semana
        const weekEnd = new Date(date);
        weekEnd.setDate(date.getDate() - date.getDay() + 7);
        const weekKey = weekEnd.toISOString().slice(0, 10);
        
        // Guardamos el último valor registrado de la semana
        weeklyData[weekKey] = dailyData[dateStr];
        lastDate = dateStr;
    });

    // Aseguramos que el último punto de datos siempre esté presente
    const lastWeekKey = new Date(new Date(lastDate).setDate(new Date(lastDate).getDate() - new Date(lastDate).getDay() + 7)).toISOString().slice(0,10);
    weeklyData[lastWeekKey] = dailyData[lastDate];
    
    return weeklyData;
};

const updateNetWorthChart = async (saldos) => {
    const canvasId = 'net-worth-chart';
    const netWorthCanvas = select(canvasId);
    if (!netWorthCanvas) return;
    const chartContainer = netWorthCanvas.closest('.chart-container');

    // AQUÍ ESTÁ LA MAGIA: Consultamos directamente a Chart.js y destruimos CUALQUIER
    // instancia que esté usando este canvas antes de intentar crear una nueva.
    const existingChart = Chart.getChart(canvasId);
    if (existingChart) {
        existingChart.destroy();
    }
    netWorthChart = null; // Limpiamos la referencia global por si acaso.
    
    const allMovements = await fetchAllMovementsForHistory();
    // ... El resto del cuerpo de la función para obtener datos y crear el gráfico
    // se mantiene EXACTAMENTE IGUAL que en la versión que ya tenéis...
    const visibleAccountIds = new Set(Object.keys(saldos));
    const cuentas = db.cuentas.filter(c => visibleAccountIds.has(c.id));

    if (allMovements.length === 0 && cuentas.length === 0) {
        if(chartContainer) {
            chartContainer.classList.remove('skeleton');
            chartContainer.innerHTML = `<div class="empty-state" style="padding:16px 0; background:transparent; border:none;"><p>Aún no hay datos para mostrar la evolución.</p></div>`;
        }
        return;
    }
    if(chartContainer) chartContainer.classList.remove('skeleton');

    const currentComponentTotals = { 'Líquido': 0, 'Inversión': 0, 'Propiedades': 0, 'Deuda': 0 };
    cuentas.forEach(c => {
        const component = getNetWorthComponent(c.tipo);
        const balance = c.saldo || 0;
        if (component === 'Deuda') {
            currentComponentTotals.Deuda += Math.abs(balance);
        } else {
            currentComponentTotals[component] += balance;
        }
    });

    let runningComponentTotals = { ...currentComponentTotals };
    const dailyData = {};
    const todayKey = new Date().toISOString().slice(0, 10);
    dailyData[todayKey] = { ...runningComponentTotals };

    const sortedMovements = allMovements.sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
    
    for (const mov of sortedMovements) {
        let componentChange = null;
        let changeAmount = 0;

        if (mov.tipo === 'movimiento') {
            const cuenta = cuentas.find(c => c.id === mov.cuentaId);
            if (cuenta) {
                componentChange = getNetWorthComponent(cuenta.tipo);
                changeAmount = mov.cantidad;
            }
        } else if (mov.tipo === 'traspaso') {
            const origen = cuentas.find(c => c.id === mov.cuentaOrigenId);
            const destino = cuentas.find(c => c.id === mov.cuentaDestinoId);
            const origenComp = origen ? getNetWorthComponent(origen.tipo) : null;
            const destinoComp = destino ? getNetWorthComponent(destino.tipo) : null;

            if (origen && !destino) {
                componentChange = origenComp;
                changeAmount = -mov.cantidad;
            } else if (!origen && destino) {
                componentChange = destinoComp;
                changeAmount = mov.cantidad;
            } else if (origen && destino && origenComp !== destinoComp) {
                runningComponentTotals[origenComp] += origenComp === 'Deuda' ? -mov.cantidad : mov.cantidad;
                runningComponentTotals[destinoComp] += destinoComp === 'Deuda' ? mov.cantidad : -mov.cantidad;
            }
        }
        
        if (componentChange) {
            runningComponentTotals[componentChange] -= (componentChange === 'Deuda' ? -changeAmount : changeAmount);
        }
        
        const dateKey = mov.fecha.slice(0, 10);
        dailyData[dateKey] = { ...runningComponentTotals };
    }
    
    const weeklyData = resampleDataWeekly(dailyData);
    const sortedDates = Object.keys(weeklyData).sort();

    if(chartContainer) chartContainer.classList.remove('skeleton');

    const datasets = Object.keys(NET_WORTH_COMPONENT_COLORS).map(component => ({
        label: component,
        data: sortedDates.map(date => (weeklyData[date][component] || 0) / 100),
        fill: true,
        backgroundColor: NET_WORTH_COMPONENT_COLORS[component],
        borderColor: NET_WORTH_COMPONENT_COLORS[component].replace('0.7', '1'),
        pointRadius: 0,
        borderWidth: 1.5,
    }));
    
    const ctx = netWorthCanvas.getContext('2d');
    netWorthChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: sortedDates,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    stacked: true,
                    ticks: { callback: v => formatCurrency(v * 100).replace(/\s/g,'') }
                },
                x: {
                    type: 'time',
                    time: { unit: 'month', tooltipFormat: 'dd MMM yyyy', displayFormats: { month: 'MMM yy' } },
                    ticks: { autoSkip: true, maxTicksLimit: 6 },
                    grid: { display: false }
                }
            },
            plugins: {
                datalabels: { display: false },
                legend: {
                    position: 'bottom',
                    labels: { boxWidth: 15, padding: 20 }
                },
                tooltip: {
                    intersect: false,
                    mode: 'index',
                    callbacks: {
                        label: (context) => {
                            const label = context.dataset.label || '';
                            const value = context.parsed.y;
                            return ` ${label}: ${formatCurrency(value * 100)}`;
                        },
                        footer: (tooltipItems) => {
                            let sum = 0;
                            tooltipItems.forEach(function(tooltipItem) {
                                sum += tooltipItem.parsed.y;
                            });
                            return `Total: ${formatCurrency(sum * 100)}`;
                        },
                    }
                }
            },
            interaction: {
                mode: 'index',
                intersect: false,
            },
        }
    });
};

const scheduleDashboardUpdate = () => {
    // El jefe de obra solo trabaja si la página "Inicio" está abierta.
    const activePage = document.querySelector('.view--active');
    if (!activePage || activePage.id !== PAGE_IDS.INICIO) {
        return;
    }
      
    clearTimeout(dashboardUpdateDebounceTimer);
        
    dashboardUpdateDebounceTimer = setTimeout(updateDashboardData, 50);
};

const renderInformesWidgetsData = async () => {
    // Esta función solo se ejecuta si los widgets están en el DOM.
    const fiWidget = select('fi-progress-widget');
    const informeWidget = select('informe-personalizado-widget');

    // Si no encuentra los widgets, no hace nada.
    if (!fiWidget && !informeWidget) { // Modificada: se quita efWidget
        return;
    }

    try {
        // Obtenemos los datos necesarios que antes se calculaban en updateDashboardData
        const saldos = await getSaldos();
        const patrimonioNeto = Object.values(saldos).reduce((sum, s) => sum + s, 0);

        

        // 3. Lógica para el Informe Personalizado
        if (informeWidget) {
            await renderInformeWidgetContent();
        }

    } catch (error) {
        console.error("Error al renderizar los datos de los widgets de informes:", error);
        // En caso de error, muestra un mensaje útil en los widgets.
        if (efWidget) efWidget.innerHTML += '<p class="text-danger">Error al cargar datos.</p>';
        if (fiWidget) fiWidget.innerHTML += '<p class="text-danger">Error al cargar datos.</p>';
        if (informeWidget) informeWidget.innerHTML += '<p class="text-danger">Error al cargar datos.</p>';
    }
};


const updateDashboardData = async () => {
    const activePage = document.querySelector('.view--active');
    if (!activePage || activePage.id !== PAGE_IDS.INICIO) {
        return;
    }

    if (isDashboardRendering) return;
    isDashboardRendering = true;

    
    try {
        const { current, previous, label } = await getFilteredMovements(true);
        const saldos = await getSaldos();
        
        await updateNetWorthChart(saldos);

        const visibleAccountIds = new Set(Object.keys(saldos));
        const investmentAccountIds = new Set(getVisibleAccounts().filter(c => c.esInversion).map(c => c.id));
		
        const calculateTotals = (movs) => {
            let ingresos = 0, gastos = 0, saldoNeto = 0;
            movs.forEach(m => {
                const amount = calculateMovementAmount(m, visibleAccountIds);
                if (amount > 0) ingresos += amount;
                else gastos += amount;
                saldoNeto += amount;
            });
            return { ingresos, gastos, saldoNeto };
        };
		
        const currentTotals = calculateTotals(current);
        const previousTotals = calculateTotals(previous);
        const saldoNetoActual = currentTotals.saldoNeto;
        const saldoNetoAnterior = previousTotals.saldoNeto;
        const tasaAhorroActual = currentTotals.ingresos > 0 ? (saldoNetoActual / currentTotals.ingresos) * 100 : (saldoNetoActual < 0 ? -100 : 0);
        const tasaAhorroAnterior = previousTotals.ingresos > 0 ? (previousTotals.saldoNeto / previousTotals.ingresos) * 100 : 0;
        const patrimonioNeto = Object.values(saldos).reduce((sum, s) => sum + s, 0);
        const portfolioPerformance = await calculatePortfolioPerformance();
        const pnlInversionActual = portfolioPerformance.pnlAbsoluto;
        const now = new Date();
        const expenseBudgets = (db.presupuestos || []).filter(b => b.ano === now.getFullYear() && b.cantidad < 0);
        let totalBudgetedExpense = 0;
        let actualExpenseForBudget = Math.abs(currentTotals.gastos);
        if (expenseBudgets.length > 0) {
            const periodFilterEl = select('filter-periodo');
            const periodFilter = periodFilterEl ? periodFilterEl.value : 'mes-actual';
            const totalAnnualBudget = expenseBudgets.reduce((sum, b) => sum + Math.abs(b.cantidad), 0);
            if (periodFilter === 'mes-actual') totalBudgetedExpense = totalAnnualBudget / 12;
            else if (periodFilter === 'año-actual') totalBudgetedExpense = totalAnnualBudget;
            else {
                const sDateEl = select('filter-fecha-inicio'), eDateEl = select('filter-fecha-fin');
                if (sDateEl?.value && eDateEl?.value) {
                    const diffDays = (new Date(eDateEl.value) - new Date(sDateEl.value)) / 86400000 + 1;
                    totalBudgetedExpense = (totalAnnualBudget / (now.getFullYear() % 4 === 0 ? 366 : 365)) * diffDays;
                }
            }
        }
        
        const getComparisonHTML = (currentVal, prevVal, comparisonLabel, lowerIsBetter = false) => {
            if (!comparisonLabel || prevVal === 0 || Math.abs(prevVal) < 1) return '';
            const isImprovement = lowerIsBetter ? (currentVal < prevVal) : (currentVal > prevVal);
            const diff = (currentVal - prevVal) / Math.abs(prevVal) * 100;
            const diffClass = isImprovement ? 'text-positive' : 'text-negative';
            const icon = isImprovement ? 'arrow_upward' : 'arrow_downward';
            return `<span class="${diffClass}"><span class="material-icons" style="font-size: 12px; vertical-align: middle;">${icon}</span> ${Math.abs(diff).toFixed(0)}%</span> <span style="color:var(--c-on-surface-secondary)">${comparisonLabel}</span>`;
        };
		
        if (select('kpi-ingresos-value')) {
            selectAll('#kpi-container .skeleton').forEach(el => el.classList.remove('skeleton'));
            animateCountUp(select('kpi-ingresos-value'), currentTotals.ingresos);
            select('kpi-ingresos-comparison').innerHTML = getComparisonHTML(currentTotals.ingresos, previousTotals.ingresos, label);
            animateCountUp(select('kpi-gastos-value'), currentTotals.gastos);
            select('kpi-gastos-comparison').innerHTML = getComparisonHTML(Math.abs(currentTotals.gastos), Math.abs(previousTotals.gastos), label, true);
        }
        const saldoNetoEl = select('kpi-saldo-neto-value');
        if (saldoNetoEl) {
            saldoNetoEl.className = `kpi-item__value ${saldoNetoActual >= 0 ? 'text-positive' : 'text-negative'}`;
            animateCountUp(saldoNetoEl, saldoNetoActual);
            select('kpi-saldo-neto-comparison').innerHTML = getComparisonHTML(saldoNetoActual, saldoNetoAnterior, label);
        }

        // --- INICIO DE LA CORRECCIÓN CLAVE ---
        // Ahora el cartero busca directamente los buzones, sin importar en qué edificio estén.
        if (select('kpi-tasa-ahorro-value')) {
            selectAll('#super-centro-operaciones-widget .skeleton').forEach(el => el.classList.remove('skeleton'));
            const kpiTasaAhorroValueEl = select('kpi-tasa-ahorro-value');
            kpiTasaAhorroValueEl.textContent = `${tasaAhorroActual.toFixed(1)}%`;
            kpiTasaAhorroValueEl.className = `kpi-item__value ${tasaAhorroActual >= 0 ? 'text-positive' : 'text-negative'}`;
            renderSavingsRateGauge('kpi-savings-rate-chart', tasaAhorroActual);
            select('kpi-tasa-ahorro-comparison').innerHTML = getComparisonHTML(tasaAhorroActual, tasaAhorroAnterior, label.replace('vs', ''));
            animateCountUp(select('kpi-patrimonio-neto-value'), patrimonioNeto);
            const kpiPnlEl = select('kpi-pnl-inversion-value');
            kpiPnlEl.className = `kpi-item__value ${pnlInversionActual >= 0 ? 'text-positive' : 'text-negative'}`;
            if (investmentAccountIds.size > 0) animateCountUp(kpiPnlEl, pnlInversionActual); else kpiPnlEl.textContent = 'N/A';
            const progressEl = select('kpi-presupuesto-progress'), progressTextEl = select('kpi-presupuesto-text');
			if (progressEl && progressTextEl) { // <--- LÍNEA AÑADIDA
            progressTextEl.classList.remove('skeleton');
            if (totalBudgetedExpense > 0) {
                const percentage = (actualExpenseForBudget / totalBudgetedExpense) * 100;
                if(progressEl) progressEl.value = Math.min(percentage, 100);
                progressTextEl.innerHTML = `Gastado <strong>${formatCurrency(actualExpenseForBudget)}</strong> de un límite de <strong>${formatCurrency(totalBudgetedExpense)}</strong> (${percentage.toFixed(0)}%)`;
                if(progressEl) {
                    progressEl.className = 'budget-item__progress';
                    if (percentage > 100) progressEl.classList.add('budget-item__progress--danger');
                    else if (percentage > 85) progressEl.classList.add('budget-item__progress--warning');
                }
            } else {
                if(progressEl) progressEl.value = 0;
                progressTextEl.textContent = 'No hay presupuestos de gasto definidos para este año.';
            }
			}
        } 
        // --- FIN DE LA CORRECCIÓN CLAVE ---
        
        const actionCenterContainer = select('action-center-content');
        if (actionCenterContainer) {
             let actionItems = []; const now = new Date(); const today = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate())); const nextWeek = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000); const pendingRecurrents = (db.recurrentes || []).filter(r => new Date(r.nextDate) <= today); pendingRecurrents.forEach(r => actionItems.push({ urgency: 3, type: 'pending', data: r, subtitle: `Vencido desde el ${new Date(r.nextDate).toLocaleDateString()}` })); (db.recurrentes || []).filter(r => { const nextDate = new Date(r.nextDate); return nextDate > today && nextDate <= nextWeek; }).slice(0, 3).forEach(r => actionItems.push({ urgency: 2, type: 'upcoming', data: r, subtitle: `Vence el ${new Date(r.nextDate).toLocaleDateString()}` })); actionItems.sort((a, b) => b.urgency - a.urgency || new Date(a.data.nextDate) - new Date(b.data.nextDate)); if (actionItems.length === 0) { actionCenterContainer.innerHTML = `<div class="empty-state" style="padding: var(--sp-2) 0; background: transparent; border: none;"><span class="material-icons text-positive">task_alt</span><p style="color: var(--c-on-surface-secondary);">¡Todo en orden!</p></div>`; } else { actionCenterContainer.innerHTML = actionItems.map(item => { const r = item.data; const amountClass = r.cantidad >= 0 ? 'text-positive' : 'text-negative'; const actionButtons = item.type === 'pending' ? `<div style="display: flex; gap: var(--sp-2);"><button class="btn btn--secondary" data-action="skip-recurrent" data-id="${r.id}" style="padding: 4px 8px; font-size: 0.7rem;">Omitir</button><button class="btn btn--primary" data-action="confirm-recurrent" data-id="${r.id}" style="padding: 4px 8px; font-size: 0.7rem;">Añadir</button></div>` : ''; return `<div class="modal__list-item" style="padding: var(--sp-2) 0;"><div><strong style="font-size: var(--fs-sm);">${r.descripcion}</strong><small style="display: block; color: var(--c-on-surface-secondary);">${item.subtitle}</small></div><div style="text-align: right;"><strong class="${amountClass}" style="font-size: var(--fs-base);">${formatCurrency(r.cantidad)}</strong>${actionButtons}</div></div>`; }).join(''); }
        }
        const conceptListContainer = select('concepto-totals-list');
        const chartCanvas = select('conceptos-chart');
        if (conceptListContainer && chartCanvas) {
    const chartCtx = chartCanvas.getContext('2d');
    const chartContainer = chartCanvas.closest('.chart-container');
    if(chartContainer) chartContainer.classList.remove('skeleton');
    if (conceptosChart) conceptosChart.destroy();
    
    // Misma lógica que ya tienes para calcular los totales por concepto
    const cTots = current.reduce((a, m) => {
        if (m.tipo === 'movimiento' && m.conceptoId) {
            const con = db.conceptos.find((c) => c.id === m.conceptoId);
            if(con){
                if (!a[m.conceptoId]) a[m.conceptoId] = { total: 0, movements: [], icon: con.icon || 'label' };
                a[m.conceptoId].total += m.cantidad;
                a[m.conceptoId].movements.push(m);
            }
        }
        return a;
    }, {});

    const sortedTotals = Object.entries(cTots).sort(([, a], [, b]) => a.total - b.total);

    // Dibuja el gráfico (sin cambios en esta parte)
    const colorSuccess = getComputedStyle(document.body).getPropertyValue('--c-chart-positive').trim();
    const colorDanger = getComputedStyle(document.body).getPropertyValue('--c-danger').trim();
    conceptosChart = new Chart(chartCtx, { type: 'bar', data: { labels: sortedTotals.map(([id]) => toSentenceCase(db.conceptos.find(c => c.id === id)?.nombre || '?')), datasets: [{ data: sortedTotals.map(([, data]) => data.total / 100), backgroundColor: sortedTotals.map(([, data]) => data.total >= 0 ? colorSuccess : colorDanger), borderRadius: 6, }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, datalabels: { display: false }, tooltip: { callbacks: { label: (context) => `Total: ${formatCurrency(context.parsed.y * 100)}` } } }, scales: { y: { ticks: { callback: (value) => `${value.toLocaleString('es-ES')}` } } }, onClick: (event, elements) => { if (elements.length === 0) return; const index = elements[0].index; const [conceptoId, data] = sortedTotals[index]; const concepto = db.conceptos.find(c => c.id === conceptoId); const conceptoNombre = concepto ? toSentenceCase(concepto.nombre) : 'Desconocido'; hapticFeedback('light'); showDrillDownModal(`Movimientos de: ${conceptoNombre}`, data.movements); }, onHover: (event, chartElement) => { event.native.target.style.cursor = chartElement.length ? 'pointer' : 'default'; } } });

    // --- ⭐ NUEVA LÓGICA PARA RENDERIZAR LA LISTA AGRUPADA ---
    
    // 1. Separamos los conceptos en gastos e ingresos
    const gastos = sortedTotals.filter(([, data]) => data.total < 0).sort(([, a], [, b]) => a.total - b.total);
    const ingresos = sortedTotals.filter(([, data]) => data.total > 0).sort(([, a], [, b]) => b.total - a.total);

    let listHtml = '';

    const renderGroup = (title, items, totalPeriodValue) => {
        if (items.length === 0) return '';
        const groupTotal = items.reduce((sum, [, data]) => sum + data.total, 0);

        // La función para renderizar cada fila (la hemos extraído para no repetir código)
        const renderRow = ([id, data]) => {
            const concepto = db.conceptos.find(c => c.id === id);
            const nombreConcepto = (concepto && concepto.nombre) || 'Desconocido';
            const amountClass = data.total >= 0 ? 'text-positive' : 'text-negative';
            const percentage = totalPeriodValue > 0 ? (Math.abs(data.total) / totalPeriodValue) * 100 : 0;
            const progressClass = data.total < 0 ? 'budget-item__progress--danger' : '';

            return `<div class="modal__list-item" style="cursor: pointer; padding: var(--sp-2) var(--sp-1);" data-action="show-concept-drilldown" data-concept-id="${id}" data-concept-name="${escapeHTML(nombreConcepto)}"><div style="flex-grow: 1;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;"><span>${escapeHTML(nombreConcepto)}</span><strong class="${amountClass}">${formatCurrency(data.total)}</strong></div><div class="budget-item__progress"><progress max="100" value="${percentage}" class="budget-item__progress ${progressClass}" style="width: 100%; height: 5px;"></progress></div></div></div>`;
        };

        return `
            <details class="accordion" style="background-color: transparent; border: 1px solid var(--c-outline); border-radius: var(--border-radius-md); margin-bottom: var(--sp-2);">
                <summary>
                    <span style="font-weight: 700;">${title}</span>
                    <strong>${formatCurrency(groupTotal)}</strong>
                </summary>
                <div class="accordion__content" style="padding: 0 var(--sp-2) var(--sp-1) var(--sp-2);">
                    ${items.map(renderRow).join('')}
                </div>
            </details>
        `;
    };

    if (sortedTotals.length === 0) {
        listHtml = `<div class="empty-state" style="padding:16px 0; background:transparent; border:none;"><p>Sin datos para los filtros.</p></div>`;
    } else {
        listHtml += renderGroup('Gastos', gastos, Math.abs(currentTotals.gastos));
        listHtml += renderGroup('Ingresos', ingresos, currentTotals.ingresos);
    }
    
    conceptListContainer.innerHTML = listHtml;
}
		
		if (select('patrimonio-completo-container')) { await renderPatrimonioPage(); }
        if (select('patrimonio-inversiones-container')) { await renderInversionesPage('patrimonio-inversiones-container'); }
        if (select('informe-personalizado-widget')) { await renderInformeWidgetContent(); }
		
    } finally {
        // --- INICIO DE LA CORRECCIÓN ---
        const widgetContainers = document.querySelectorAll('[data-widget-type]');
        // --- FIN DE LA CORRECCIÓN ---
        
        widgetContainers.forEach(container => {
            if (container) {
                container.classList.remove('widget--loading');
                const spinner = container.querySelector('.widget-spinner');
                if (spinner) {
                    spinner.remove();
                }
            }
        });
        isDashboardRendering = false;
    }
};


// Rellena el widget con el gráfico y datos según la configuración guardada
const renderInformeWidgetContent = async () => {
    const container = select('informe-widget-content');
    if (!container) return;

    const reportConfig = db.config?.savedReports?.main;

    if (!reportConfig) {
        container.innerHTML = `
        <div class="empty-state" style="background:transparent; border:none; padding: var(--sp-4) 0;">
            <p>Aún no has configurado tu informe. Haz clic en "Configurar" para empezar.</p>
        </div>`;
        return;
    }
    
    container.innerHTML = `<div class="chart-container" style="height: 240px;"><canvas id="informe-main-chart"></canvas></div>`;

    const data = await generateInformeData(reportConfig);
    const chartCanvas = select('informe-main-chart');
    const chartCtx = chartCanvas ? chartCanvas.getContext('2d') : null;

    if (informeChart) informeChart.destroy();
    if (!chartCtx) return;

    if (data.labels.length === 0) {
        container.innerHTML = `<div class="empty-state" style="background:transparent; border:none; padding: var(--sp-2) 0;"><p>No se encontraron datos para los criterios de tu informe.</p></div>`;
        return;
    }

    informeChart = new Chart(chartCtx, {
        type: 'bar',
        data: {
            labels: data.labels,
            datasets: data.datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { stacked: reportConfig.desglose === 'concepto' },
                y: { stacked: reportConfig.desglose === 'concepto', ticks: { callback: (value) => `€${value.toLocaleString('es-ES')}` } }
            },
            plugins: {
                legend: { display: data.datasets.length > 1, position: 'top' },
                tooltip: { callbacks: { label: (c) => `${c.dataset.label || ''}: ${formatCurrency(c.raw * 100)}` } },
                datalabels: { display: false }
            }
        }
    });
};
      

/** Función auxiliar que calcula dónde se debe insertar el elemento que se arrastra. */
const getDragAfterElement = (container, y) => {
    const draggableElements = [...container.querySelectorAll('.widget-config-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
};

		let suggestionDebounceTimer = null;
        const applyDescriptionSuggestion = (target) => {
    // Extraemos la información directamente del elemento clicado
    const { description, conceptoId, cuentaId } = target.dataset;

    // Rellenamos los campos del formulario
    select('movimiento-descripcion').value = toSentenceCase(description);
    select('movimiento-concepto').value = conceptoId;
    select('movimiento-cuenta').value = cuentaId;
    
    // Ocultamos la caja de sugerencias
    select('description-suggestions').style.display = 'none';

    // Damos feedback visual y movemos el cursor al siguiente paso
    hapticFeedback('light');
    [select('movimiento-concepto'), select('movimiento-cuenta')].forEach(el => {
        const parent = el.closest('.form-group-addon');
        if(parent) {
            parent.classList.add('field-highlighted');
            setTimeout(() => parent.classList.remove('field-highlighted'), 1500);
        }
    });

    // ¡La magia final! Movemos el foco al campo de la cantidad.
    select('movimiento-cantidad').focus();
};

// =================================================================
// === INICIO: CÓDIGO UNIFICADO PARA MODALES ARRASTRABLES ===
// =================================================================

let modalDragState = {
    isDragging: false,
    startY: 0,
    currentY: 0,
    targetModal: null
};

// Se activa CUANDO EMPIEZAS A ARRASTRAR
function handleModalDragStart(e) {
    const modal = e.target.closest('.modal');
    if (!modal) return;

    const modalBody = modal.querySelector('.modal__body');
    if (modalBody && modalBody.scrollTop > 0) return;

    modalDragState.isDragging = true;
    modalDragState.targetModal = modal;
    modalDragState.startY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

    modal.style.transition = 'none';
}

// Se activa MIENTRAS MUEVES EL DEDO/RATÓN
function handleModalDragMove(e) {
    if (!modalDragState.isDragging || !modalDragState.targetModal) return;

    modalDragState.currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
    let deltaY = modalDragState.currentY - modalDragState.startY;

    if (deltaY > 0) {
        e.preventDefault();
        modalDragState.targetModal.style.transform = `translateY(${deltaY}px)`;
    }
}

// Se activa CUANDO SUELTAS EL DEDO/RATÓN
function handleModalDragEnd(e) {
    if (!modalDragState.isDragging || !modalDragState.targetModal) return;

    const modal = modalDragState.targetModal;
    modal.style.transition = 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)'; 

    const deltaY = modalDragState.currentY - modalDragState.startY;
    const modalHeight = modal.offsetHeight;

    if (deltaY > modalHeight * 0.3) {
        const overlay = modal.closest('.modal-overlay');
        if (overlay) hideModal(overlay.id);
    } else {
        modal.style.transform = 'translateY(0)';
    }

    modalDragState.isDragging = false;
    modalDragState.targetModal = null;
}

// FUNCIÓN showModal ACTUALIZADA
const showModal = (id) => {
    const m = select(id);
    if (m) {
        m.classList.add('modal-overlay--active');
        select('app-root').classList.add('app-layout--transformed-by-modal');

        const modalElement = m.querySelector('.modal');
        if (modalElement) {
            modalElement.addEventListener('mousedown', handleModalDragStart);
            modalElement.addEventListener('touchstart', handleModalDragStart, { passive: true });
        }

        document.addEventListener('mousemove', handleModalDragMove);
        document.addEventListener('touchmove', handleModalDragMove, { passive: false });
        document.addEventListener('mouseup', handleModalDragEnd);
        document.addEventListener('touchend', handleModalDragEnd);

        if (!id.includes('calculator')) {
            const f = m.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (f) f.focus();
        }
    }
};

// FUNCIÓN hideModal ACTUALIZADA
const hideModal = (id) => {
    const m = select(id);
    if (m) {
        m.classList.remove('modal-overlay--active');
        select('app-root').classList.remove('app-layout--transformed-by-modal');

        const modalElement = m.querySelector('.modal');
        if (modalElement) {
            modalElement.removeEventListener('mousedown', handleModalDragStart);
            modalElement.removeEventListener('touchstart', handleModalDragStart);
        }
        document.removeEventListener('mousemove', handleModalDragMove);
        document.removeEventListener('touchmove', handleModalDragMove);
        document.removeEventListener('mouseup', handleModalDragEnd);
        document.removeEventListener('touchend', handleModalDragEnd);

        if (modalElement) modalElement.style.transform = '';
    }

    const mainScroller = selectOne('.app-layout__main');
    if (mainScroller && lastScrollTop !== null) {
        requestAnimationFrame(() => {
            mainScroller.scrollTop = lastScrollTop;
            lastScrollTop = null;
        });
    }
};

// =================================================================
// === FIN: CÓDIGO UNIFICADO PARA MODALES ARRASTRABLES ===
// =================================================================

	const showAidanaiModal = (pageId) => {
    // Busca el contenido de ayuda para la página actual, o usa el por defecto si no lo encuentra.
    const help = AIDANAI_HELP_CONTENT[pageId] || AIDANAI_HELP_CONTENT['default'];
    
    // Formateamos el contenido con nuestro estilo personalizado.
    const modalHtml = `
        <div class="aidanai-modal-content">
            <img src="aiDANaI.webp" alt="Asistente aiDANaI">
            <h4>${help.title}</h4>
            <p>${help.content}</p>
        </div>
        <div class="modal__actions">
            <button class="btn btn--primary" data-action="close-modal" data-modal-id="generic-modal">¡Entendido!</button>
        </div>
    `;

    // Usamos tu función de modales ya existente para mostrar el contenido.
    showGenericModal("Tu Asistente Personal", modalHtml);
    hapticFeedback('light');
};	
		

        const closeCalculatorOnClickOutside = (e) => {
            const calculatorEl = select('calculator-ui');
            if (!calculatorState.isVisible || (calculatorEl && calculatorEl.contains(e.target))) {
                 setTimeout(() => {
                     document.addEventListener('click', closeCalculatorOnClickOutside, { once: true });
                 }, 0);
                return;
            }
            hideCalculator();
        };       

		 const updateDoneButtonText = () => {
            const doneButton = select('calculator-btn-done');
            if (doneButton) {
                doneButton.textContent = calculatorState.isResultDisplayed ? 'Cerrar' : 'OK';
            }
        };
        

        const updateCalculatorDisplay = () => {
    const display = select('calculator-display');
    if (display) {
        // Esta función ahora es muy "tonta". Simplemente muestra lo que hay en
        // calculatorState.displayValue, sin intentar formatearlo o cambiarlo.
        // ¡El camarero obediente!
        display.textContent = calculatorState.displayValue;
    }
};
        const showGenericModal=(title,html)=>{const titleEl = select('generic-modal-title'); if (titleEl) titleEl.textContent=title; const bodyEl = select('generic-modal-body'); if(bodyEl) bodyEl.innerHTML=html;showModal('generic-modal');};
const showDrillDownModal = (title, movements) => {
    // Ordenamos los movimientos para que se muestren cronológicamente
    movements.sort((a, b) => new Date(b.fecha) - new Date(a.fecha));

    // Construimos el contenido del modal
    let modalContentHTML = movements.length === 0
    ? `<div class="empty-state" style="background:transparent; border:none; padding-top: var(--sp-4);">
           <span class="material-icons">search_off</span>
           <h3>Sin movimientos</h3>
           <p>No se han encontrado movimientos para esta selección.</p>
       </div>`
    : movements.map(m => 
          TransactionCardComponent(m, { cuentas: db.cuentas, conceptos: db.conceptos })
      )
      .join('')
      .replace(/data-action="edit-movement-from-list"/g, 'data-action="edit-movement-from-modal"');

    // ==============================================================================
    // === ¡AQUÍ ESTÁ LA LÍNEA DE CÓDIGO CLAVE QUE SOLUCIONA EL PROBLEMA VISUAL! ===
    // ==============================================================================
    // Eliminamos la clase que los hacía invisibles (opacity: 0)
    modalContentHTML = modalContentHTML.replace(/list-item-animate/g, '');

    // Llamamos a la función existente para mostrar el modal con el HTML ya limpio y visible
    showGenericModal(title, modalContentHTML);
};
        const showConfirmationModal=(msg, onConfirm, title="Confirmar Acción")=>{ hapticFeedback('medium'); const id='confirmation-modal';const existingModal = document.getElementById(id); if(existingModal) existingModal.remove(); const overlay=document.createElement('div');overlay.id=id;overlay.className='modal-overlay modal-overlay--active'; overlay.innerHTML=`<div class="modal" role="alertdialog" style="border-radius:var(--border-radius-lg)"><div class="modal__header"><h3 class="modal__title">${title}</h3></div><div class="modal__body"><p>${msg}</p><div style="display:flex;gap:var(--sp-3);margin-top:var(--sp-4);"><button class="btn btn--secondary btn--full" data-action="close-modal" data-modal-id="confirmation-modal">Cancelar</button><button class="btn btn--danger btn--full" data-action="confirm-action">Sí, continuar</button></div></div></div>`; document.body.appendChild(overlay); (overlay.querySelector('[data-action="confirm-action"]')).onclick=()=>{hapticFeedback('medium');onConfirm();overlay.remove();}; (overlay.querySelector('[data-action="close-modal"]')).onclick=()=>overlay.remove(); };


// Esta nueva función prepara el campo de cantidad cuando se abre el formulario.
const initAmountInput = () => {
    const amountInput = select('movimiento-cantidad');
    const calculatorToggle = select('calculator-toggle-btn');
    if (!amountInput || !calculatorToggle) return;
    
    if (isMobileDevice()) {
        // MÓVIL: Hacemos que el input no saque el teclado y que al tocarlo, se abra nuestra calculadora.
        amountInput.setAttribute('inputmode', 'none');
        calculatorToggle.style.display = 'none'; // Ocultamos el botón del icono en móvil
        
        // Usamos un listener de 'click' porque 'focus' puede ser problemático en algunos móviles
        amountInput.onclick = (e) => {
            e.preventDefault();
            showCalculator(amountInput);
        };

    } else {
        // ESCRITORIO: Permitimos escribir normalmente y el botón del icono abre la calculadora.
        amountInput.setAttribute('inputmode', 'decimal');
        calculatorToggle.style.display = 'inline-flex';
        amountInput.onclick = null; // Quitamos el listener de móvil por si acaso
        calculatorToggle.onclick = () => showCalculator(amountInput);
    }
};


const showCalculator = (targetInput) => {
    const calculatorOverlay = select('calculator-overlay');
    if (!calculatorOverlay) return;
    
    calculatorOverlay.classList.add('modal-overlay--active');
    calculatorState.isVisible = true;
    calculatorState.targetInput = targetInput;
    calculatorState.displayValue = '0';
    calculatorState.waitingForNewValue = true;
    updateCalculatorDisplay();

    // ¡LA MAGIA PARA PC!
    if (!isMobileDevice()) {
        if (calculatorKeyboardHandler) {
            document.removeEventListener('keydown', calculatorKeyboardHandler);
        }
        
        calculatorKeyboardHandler = (e) => {
            if ("0123456789,.+-*\/".includes(e.key) || ['Enter', 'Backspace', 'Escape', 'Delete'].includes(e.key)) {
                e.preventDefault();
            }

            if (e.key >= '0' && e.key <= '9') handleCalculatorInput(e.key);
            else if (e.key === ',' || e.key === '.') handleCalculatorInput('comma');
            else if (e.key === 'Enter') handleCalculatorInput('done');
            else if (e.key === 'Backspace') handleCalculatorInput('backspace');
            else if (e.key === 'Delete') handleCalculatorInput('clear');
            else if (e.key === 'Escape') hideCalculator();
            else if (e.key === '+') handleCalculatorInput('add');
            else if (e.key === '-') handleCalculatorInput('subtract');
            else if (e.key === '*' || e.key.toLowerCase() === 'x') handleCalculatorInput('multiply');
            else if (e.key === '/') handleCalculatorInput('divide');
        };

        document.addEventListener('keydown', calculatorKeyboardHandler);
    }
};

const hideCalculator = () => {
    const calculatorOverlay = select('calculator-overlay');
    if (calculatorOverlay) {
        calculatorOverlay.classList.remove('modal-overlay--active');
    }
    calculatorState.isVisible = false;
    
    if (calculatorKeyboardHandler) {
        document.removeEventListener('keydown', calculatorKeyboardHandler);
        calculatorKeyboardHandler = null;
    }
};		
		
		
// =================================================================
// === INICIO: FUNCIÓN showToast (CORRECCIÓN CRÍTICA) ===
// =================================================================
const showAccountMovementsModal = async (cId) => {
    const cuenta = getVisibleAccounts().find((c) => c.id === cId);
    if (!cuenta) return;

    showGenericModal(`Movimientos de ${cuenta.nombre}`, `<div style="text-align:center; padding: var(--sp-5);"><span class="spinner"></span><p style="margin-top: var(--sp-3);">Cargando historial...</p></div>`);

    try {
        const movsSnapshot = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos').get();
        const allMovements = movsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const accountMovements = allMovements.filter(m => 
            m.cuentaId === cId || 
            m.cuentaOrigenId === cId || 
            m.cuentaDestinoId === cId
        );
        
        // ¡LA MAGIA SUCEDE AQUÍ! Usamos nuestra nueva función para preparar los datos.
        if (accountMovements.length > 0) {
            recalculateAndApplyRunningBalances(accountMovements, db.cuentas);
        }
        
        // Llamamos directamente a showDrillDownModal, que ya sabe cómo mostrar la lista.
        showDrillDownModal(`Movimientos de ${cuenta.nombre}`, accountMovements);

    } catch (error) {
        console.error("Error al obtener los movimientos de la cuenta:", error);
        showToast("No se pudo cargar el historial de la cuenta.", "danger");
        const modalBody = select('generic-modal-body');
        if (modalBody) {
            modalBody.innerHTML = `<p class="text-danger" style="text-align:center;">Ha ocurrido un error al cargar los datos.</p>`;
        }
    }
};
    const showAccountMovementsForDashboardPeriod = async (accountId) => {
    const cuenta = getVisibleAccounts().find((c) => c.id === accountId);
    if (!cuenta) return;

    // Mostramos un spinner mientras se procesan los datos.
    showGenericModal(`Movimientos de ${cuenta.nombre}`, `<div style="text-align:center; padding: var(--sp-5);"><span class="spinner"></span></div>`);

    // 1. Obtenemos los movimientos ya filtrados por fecha del panel.
    const { current } = await getFilteredMovements(false);
    
    // 2. Filtramos esa lista por la cuenta seleccionada.
    const accountMovementsInPeriod = current.filter(m => 
        m.cuentaId === accountId || 
        m.cuentaOrigenId === accountId || 
        m.cuentaDestinoId === accountId
    );
    
    // 3. ¡EL PASO CRÍTICO QUE FALTABA!
    // Calculamos los saldos acumulados para esta lista específica de movimientos.
    if (accountMovementsInPeriod.length > 0) {
        recalculateAndApplyRunningBalances(accountMovementsInPeriod, db.cuentas);
    }

    // 4. Usamos la función de modal existente para mostrar el resultado ya procesado.
    showDrillDownModal(`Movimientos de ${cuenta.nombre}`, accountMovementsInPeriod);
};
const setMovimientoFormType = (type) => {
    hapticFeedback('light');
    const isTraspaso = type === 'traspaso';

    // 1. Obtenemos referencias a los elementos que vamos a colorear
    const titleEl = select('form-movimiento-title');
    const amountGroup = select('movimiento-cantidad-form-group');

    // Ocultar/mostrar los campos de movimiento vs traspaso
    select('movimiento-fields').classList.toggle('hidden', isTraspaso);
    select('traspaso-fields').classList.toggle('hidden', !isTraspaso);

    // 2. Reseteamos los colores cada vez que se cambia de tipo
    if (titleEl) {
        titleEl.classList.remove('title--gasto', 'title--ingreso', 'title--traspaso');
    }
    if (amountGroup) {
        amountGroup.classList.remove('is-gasto', 'is-ingreso', 'is-traspaso');
    }

    // 3. Aplicamos los nuevos colores y textos según el tipo seleccionado
    if (titleEl && amountGroup) {
        switch (type) {
            case 'gasto':
                titleEl.textContent = 'Nuevo Gasto';
                titleEl.classList.add('title--gasto');
                amountGroup.classList.add('is-gasto');
                break;
            case 'ingreso':
                titleEl.textContent = 'Nuevo Ingreso';
                titleEl.classList.add('title--ingreso');
                amountGroup.classList.add('is-ingreso');
                break;
            case 'traspaso':
                titleEl.textContent = 'Nuevo Traspaso';
                titleEl.classList.add('title--traspaso');
                amountGroup.classList.add('is-traspaso');
                if (select('movimiento-descripcion').value.trim() === '') {
                    select('movimiento-descripcion').value = 'Traspaso';
                }
                break;
        }
    }
    
    // Gestionar la clase activa en los tres botones
    selectAll('[data-action="set-movimiento-type"]').forEach(btn => {
        btn.classList.toggle('filter-pill--active', btn.dataset.type === type);
    });
};

                const updateDateDisplay = (dateInput) => {
            const dateTextEl = select('movimiento-fecha-text');
            if (!dateTextEl || !dateInput.value) return;

            const today = new Date();
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            
            today.setHours(0, 0, 0, 0);
            yesterday.setHours(0, 0, 0, 0);

            const selectedDate = new Date(dateInput.value);
            selectedDate.setMinutes(selectedDate.getMinutes() + selectedDate.getTimezoneOffset());
            selectedDate.setHours(0, 0, 0, 0);

            if (selectedDate.getTime() === today.getTime()) {
                dateTextEl.textContent = "Hoy";
            } else if (selectedDate.getTime() === yesterday.getTime()) {
                dateTextEl.textContent = "Ayer";
            } else {
                dateTextEl.textContent = selectedDate.toLocaleDateString('es-ES', {
                    day: '2-digit', month: '2-digit', year: 'numeric'
                });
            }
        };


 // ▼▼▼ REEMPLAZA TU FUNCIÓN startMovementForm POR COMPLETO CON ESTA ▼▼▼
const startMovementForm = async (id = null, isRecurrent = false) => {
    hapticFeedback('medium');
    const form = select('form-movimiento');
    form.reset();
    clearAllErrors(form.id);
    populateAllDropdowns();

    let data = null;
    let mode = 'new';
    let initialType = 'gasto'; // Por defecto, abrimos en modo "Gasto"

    if (id) {
        try {
            const collectionName = isRecurrent ? 'recurrentes' : 'movimientos';
            const doc = await fbDb.collection('users').doc(currentUser.uid).collection(collectionName).doc(id).get();

            if (doc.exists) {
                data = { id: doc.id, ...doc.data() };
                mode = isRecurrent ? 'edit-recurrent' : 'edit-single';
                if (data.tipo === 'traspaso') {
                    initialType = 'traspaso';
                } else {
                    initialType = data.cantidad < 0 ? 'gasto' : 'ingreso';
                }
            } else {
                showToast("Error: No se encontró el elemento para editar.", "danger");
                id = null; // Reseteamos si no se encuentra
            }
        } catch (error) {
            console.error("Error al cargar datos para editar:", error);
            showToast("Error al cargar los datos.", "danger");
            return;
        }
    }

    // Llamamos a nuestra nueva función para establecer el estado inicial
    setMovimientoFormType(initialType);

    select('movimiento-mode').value = mode;
    select('movimiento-id').value = id || '';

    // El título se gestionará dinámicamente por setMovimientoFormType, pero lo ajustamos para edición
    if (id && data) {
         select('form-movimiento-title').textContent = initialType === 'traspaso' ? 'Editar Traspaso' : 'Editar Movimiento';
    }

    // La cantidad SIEMPRE se muestra en positivo
    select('movimiento-cantidad').value = data ? `${(Math.abs(data.cantidad) / 100).toLocaleString('es-ES', { minimumFractionDigits: 2, useGrouping: false })}` : '';
    
    const fechaInput = select('movimiento-fecha');
    const fecha = data && data.fecha ? new Date(data.fecha) : new Date();
    fechaInput.value = new Date(fecha.getTime() - (fecha.getTimezoneOffset() * 60000)).toISOString().slice(0, 10);
    updateDateDisplay(fechaInput);

    select('movimiento-descripcion').value = (data && data.descripcion) || '';

    if (data && data.tipo === 'traspaso') {
        select('movimiento-cuenta-origen').value = data.cuentaOrigenId || '';
        select('movimiento-cuenta-destino').value = data.cuentaDestinoId || '';
    } else if (data) {
        select('movimiento-cuenta').value = data.cuentaId || '';
        select('movimiento-concepto').value = data.conceptoId || '';
    }

    // Lógica de recurrentes (sin cambios)
    const recurrenteCheckbox = select('movimiento-recurrente');
    const recurrentOptions = select('recurrent-options');
    if (mode === 'edit-recurrent' && data) {
        recurrenteCheckbox.checked = true;
        select('recurrent-frequency').value = data.frequency;
        select('recurrent-next-date').value = data.nextDate;
        select('recurrent-end-date').value = data.endDate || '';
        recurrentOptions.classList.remove('hidden');
    } else {
        recurrenteCheckbox.checked = false;
        recurrentOptions.classList.add('hidden');
    }

    select('delete-movimiento-btn').classList.toggle('hidden', !id || !data);
    select('delete-movimiento-btn').dataset.isRecurrent = isRecurrent;
    select('duplicate-movimiento-btn').classList.toggle('hidden', !(mode === 'edit-single' && data));
    
    showModal('movimiento-modal');
    initAmountInput();
    
    // Si es nuevo, abrimos la calculadora
    if (!id) {
        setTimeout(() => showCalculator(select('movimiento-cantidad')), 150);
    }
};
        
        
        const showGlobalSearchModal = () => {
            hapticFeedback('medium');
            showModal('global-search-modal');
            setTimeout(() => {
                const input = select('global-search-input');
								
                if (input) {
                    input.focus();
                    input.value = '';
                    input.dispatchEvent(new Event('input'));
                }
            }, 100);
        };
        
        // REEMPLAZA TU FUNCIÓN performGlobalSearch POR ESTA VERSIÓN MEJORADA
const performGlobalSearch = async (query) => {
    const resultsContainer = select('global-search-results');
    if (!resultsContainer) return;

    if (!query || query.trim().length < 2) {
        resultsContainer.innerHTML = `<div class="empty-state" style="background:transparent; border: none;"><span class="material-icons">manage_search</span><h3>Encuéntralo todo</h3><p>Busca movimientos, cuentas o conceptos. <br>Atajo: <strong>Cmd/Ctrl + K</strong></p></div>`;
        return;
    }

    resultsContainer.innerHTML = `<div style="text-align: center; padding: var(--sp-5);"><span class="spinner"></span><p style="margin-top: var(--sp-2);">Buscando en toda tu base de datos...</p></div>`;
    
    const queryLower = query.toLowerCase();
    let resultsHtml = '';
    const MAX_RESULTS_PER_GROUP = 10;

    const allMovements = await fetchAllMovementsForSearch();

    // --- SECCIÓN DE MOVIMIENTOS MEJORADA ---
    const movs = allMovements
        .map(m => {
            const concepto = db.conceptos.find(c => c.id === m.conceptoId);
            const conceptoNombre = (concepto && concepto.nombre) || '';
            let cuentaInfo = '';
            if (m.tipo === 'traspaso') {
                const origen = db.cuentas.find(c => c.id === m.cuentaOrigenId);
                const destino = db.cuentas.find(c => c.id === m.cuentaDestinoId);
                cuentaInfo = `${(origen && origen.nombre) || ''} → ${(destino && destino.nombre) || ''}`;
            } else {
                const cuenta = db.cuentas.find(c => c.id === m.cuentaId);
                cuentaInfo = (cuenta && cuenta.nombre) || '';
            }
            const fecha = new Date(m.fecha).toLocaleDateString('es-ES');
            const importe = (m.cantidad / 100).toLocaleString('es-ES');
            const searchableText = `${m.descripcion} ${conceptoNombre} ${cuentaInfo} ${fecha} ${importe}`.toLowerCase();
            return { movement: m, text: searchableText, cuentaInfo: cuentaInfo };
        })
        .filter(item => item.text.includes(queryLower))
        .sort((a, b) => new Date(b.movement.fecha) - new Date(a.movement.fecha))
        .slice(0, MAX_RESULTS_PER_GROUP)
        .map(item => item); // Devolvemos el objeto completo con cuentaInfo

    if (movs.length > 0) {
        resultsHtml += `<div class="search-result-group">
                            <div class="search-result-group__title">Movimientos Encontrados</div>`;
        movs.forEach(item => {
            const m = item.movement;
            const amountClass = m.cantidad >= 0 ? 'text-positive' : 'text-negative';
            resultsHtml += `
                <button class="search-result-item" data-action="search-result-movimiento" data-id="${m.id}">
                    <span class="material-icons search-result-item__icon">receipt_long</span>
                    <div class="search-result-item__details">
                        <p>${escapeHTML(m.descripcion)}</p>
                        <small>${new Date(m.fecha).toLocaleDateString('es-ES')} • ${escapeHTML(item.cuentaInfo)}</small>
                    </div>
                    <strong class="search-result-item__amount ${amountClass}">${formatCurrency(m.cantidad)}</strong>
                </button>`;
        });
        resultsHtml += `</div>`;
    }

    // --- SECCIÓN DE CUENTAS MEJORADA ---
    const cuentas = (db.cuentas || []).filter(c => c.nombre.toLowerCase().includes(queryLower) || c.tipo.toLowerCase().includes(queryLower)).slice(0, MAX_RESULTS_PER_GROUP);
    if (cuentas.length > 0) {
        resultsHtml += `<div class="search-result-group">
                            <div class="search-result-group__title">Cuentas</div>`;
        cuentas.forEach(c => {
            resultsHtml += `
                <button class="search-result-item" data-action="search-result-cuenta" data-id="${c.id}">
                    <span class="material-icons search-result-item__icon">account_balance_wallet</span>
                    <div class="search-result-item__details">
                        <p>${escapeHTML(c.nombre)}</p>
                        <small>${escapeHTML(c.tipo)}</small>
                    </div>
                </button>`;
        });
        resultsHtml += `</div>`;
    }

    // --- SECCIÓN DE CONCEPTOS MEJORADA ---
    const conceptos = (db.conceptos || []).filter(c => c.nombre.toLowerCase().includes(queryLower)).slice(0, MAX_RESULTS_PER_GROUP);
    if (conceptos.length > 0) {
        resultsHtml += `<div class="search-result-group">
                            <div class="search-result-group__title">Conceptos</div>`;
        conceptos.forEach(c => {
            resultsHtml += `
                <button class="search-result-item" data-action="search-result-concepto" data-id="${c.id}">
                    <span class="material-icons search-result-item__icon">label</span>
                    <div class="search-result-item__details">
                        <p>${escapeHTML(c.nombre)}</p>
                    </div>
                </button>`;
        });
        resultsHtml += `</div>`;
    }

    if (!resultsHtml) {
        resultsHtml = `<div class="empty-state" style="background:transparent; border: none;"><span class="material-icons">search_off</span><h3>Sin resultados</h3><p>No se encontró nada para "${escapeHTML(query)}".</p></div>`;
    }
    
    resultsContainer.innerHTML = resultsHtml;
};

		// REEMPLAZA tu función showValoracionModal con esta versión
const showValoracionModal = (cuentaId) => {
    const cuenta = db.cuentas.find(c => c.id === cuentaId);
    if (!cuenta) return;

    const fechaISO = new Date(new Date().getTime() - (new Date().getTimezoneOffset() * 60000)).toISOString().slice(0, 10);
    
    const ultimaValoracion = (db.inversiones_historial || []).filter(v => v.cuentaId === cuentaId).sort((a, b) => new Date(b.fecha).getTime() - new Date(a.fecha).getTime())[0];

    const valorActualInput = ultimaValoracion ? (ultimaValoracion.valor / 100).toLocaleString('es-ES', { useGrouping: false, minimumFractionDigits: 2 }) : '';

    const formHtml = `
    <form id="form-valoracion" data-id="${cuentaId}" novalidate>
        <p class="form-label" style="margin-bottom: var(--sp-3);">
            Introduce el valor de mercado actual para <strong>${escapeHTML(cuenta.nombre)}</strong>. Esto actualizará el P&L y la TIR.
        </p>
        <div class="form-group">
            <label for="valoracion-valor" class="form-label">Nuevo Valor Total del Activo</label>
            <input type="text" id="valoracion-valor" class="form-input input-amount-calculator" inputmode="none" required value="${valorActualInput}" placeholder="Ej: 15250,75">
        </div>
        <div class="form-group">
            <label for="valoracion-fecha" class="form-label">Fecha de la Valoración</label>
            <input type="date" id="valoracion-fecha" class="form-input" value="${fechaISO}" required>
        </div>
        <div class="modal__actions">
            <button type="submit" class="btn btn--primary">Guardar Valoración</button>
        </div>
    </form>`;

    showGenericModal(`Actualizar Valor de ${cuenta.nombre}`, formHtml);
};

// ======================================================================================
// === INICIO: GUARDADO DE VALORACIÓN - VERSIÓN FINAL CON ACTUALIZACIÓN OPTIMISTA (v8.0) ===
// ======================================================================================
const handleSaveValoracion = async (form, btn) => {
    setButtonLoading(btn, true);
    const cuentaId = form.dataset.id;
    const cuenta = db.cuentas.find(c => c.id === cuentaId);
    if (!cuenta) {
        showToast("Error: No se pudo encontrar la cuenta.", "danger");
        setButtonLoading(btn, false);
        return;
    }

    const valor = parseCurrencyString(select('valoracion-valor').value);
    const fecha = select('valoracion-fecha').value;
    
    if (isNaN(valor) || !fecha || valor < 0) {
        showToast('El valor debe ser un número positivo y la fecha es obligatoria.', "warning");
        setButtonLoading(btn, false);
        return;
    }
    
    const fechaISO = parseDateStringAsUTC(fecha).toISOString();
    const valorEnCentimos = Math.round(valor * 100);

    try {
        const userRef = fbDb.collection('users').doc(currentUser.uid);
        const query = userRef.collection('inversiones_historial').where('cuentaId', '==', cuentaId).where('fecha', '==', fechaISO).limit(1);
        const existingSnapshot = await query.get();

        let docId;
        if (!existingSnapshot.empty) {
            docId = existingSnapshot.docs[0].id;
			await existingSnapshot.docs[0].ref.update({ valor: valorEnCentimos });
        } else {
            docId = generateId();
            await saveDoc('inversiones_historial', docId, { id: docId, cuentaId, valor: valorEnCentimos, fecha: fechaISO });
        }

        // =====================================================================
        // === INICIO: ACTUALIZACIÓN OPTIMISTA DE LA UI (LA SOLUCIÓN CLAVE)   ===
        // =====================================================================

        // 1. Buscamos si ya existe una valoración para esta fecha en nuestra memoria local.
        const existingIndex = (db.inversiones_historial || []).findIndex(v => v.cuentaId === cuentaId && v.fecha === fechaISO);

        if (existingIndex > -1) {
            // Si existe, la actualizamos directamente en la memoria.
            db.inversiones_historial[existingIndex].valor = valorEnCentimos;
        } else {
            // Si no existe, la añadimos a la memoria.
            if (!db.inversiones_historial) db.inversiones_historial = [];
            db.inversiones_historial.push({ id: docId, cuentaId, valor: valorEnCentimos, fecha: fechaISO });
        }

        // 2. Nos aseguramos de que el filtro para este tipo de activo esté visible.
        const tipoDeCuenta = toSentenceCase(cuenta.tipo || 'S/T');
        deselectedInvestmentTypesFilter.delete(tipoDeCuenta);

        // 3. Ahora sí, redibujamos la pantalla. Esta llamada usará la memoria que acabamos de actualizar.
        const container = select('inversiones-content-container');
        if (container) {
            await renderInversionesPage('inversiones-content-container');
        }
        
        // ===================================================================
        // === FIN: ACTUALIZACIÓN OPTIMISTA DE LA UI                       ===
        // ===================================================================

        setButtonLoading(btn, false);
        hideModal('generic-modal');
        hapticFeedback('success');
        showToast('Valoración guardada y cálculos actualizados instantáneamente.');

    } catch (error) {
        console.error("Error al guardar la valoración:", error);
        showToast("No se pudo guardar la valoración.", "danger");
        setButtonLoading(btn, false);
    }
};
// ======================================================================================
// === FIN: GUARDADO DE VALORACIÓN - VERSIÓN FINAL                                      ===
// ======================================================================================

const showHelpModal = () => {
    const titleEl = select('help-modal-title');
    const bodyEl = select('help-modal-body');
    
    if (titleEl) {
        titleEl.textContent = 'Guía de Usuario aiDANaI';
    }
    if (bodyEl) {
        bodyEl.innerHTML = `
<div style="text-align: center; margin-bottom: var(--sp-4);">
    <img src="aiDANaI.webp" alt="Logo Cuentas aiDANaI" class="login-view__logo" style="margin-bottom: var(--sp-2); width: 80px; height: 80px; border-radius: 18px;">
    <h3 style="font-size: 1.4rem;">Tu Centro de Mando Financiero</h3>
    <p style="color: var(--c-primary); font-weight: 600;">Donde la claridad se convierte en poder.</p>
</div>

<h4>¡Hola! Soy aiDANaI, tu copiloto financiero personal. ¡Abróchate el cinturón!</h4>
<p>Si alguna vez has sentido que tu dinero tiene vida propia, que aparece y desaparece como por arte de magia, has llegado al lugar perfecto. Manejar las finanzas es como ser el director de una orquesta: cada instrumento (tus cuentas) debe sonar en armonía para crear una sinfonía de prosperidad. Y yo, aiDANaI, te entrego la batuta.</p>
<p>He diseñado esta herramienta para que sea tu GPS financiero, no un examinador severo. Olvídate de hojas de cálculo que dan más miedo que la factura de la luz en invierno. Aquí todo está pensado para que, en menos de cinco minutos, te sientas como el CEO de tu propio banco personal. ¿Listo/a para tomar el control? ¡Vamos allá!</p>

<h3><span class="material-icons">explore</span>El Gran Tour: Un Paseo por Tu Imperio</h3>
<p>Cada pestaña de la aplicación es un departamento de tu imperio financiero, diseñado para responder a una pregunta clave sobre tu dinero:</p>

<details class="accordion" style="margin-bottom: var(--sp-2);">
    <summary><span class="material-icons" style="margin-right:8px">dashboard</span><strong>1. Inicio: ¿Cómo voy hoy? (La Torre de Control)</strong></summary>
    <div class="accordion__content" style="padding-top: var(--sp-2);">
        <p>Esta es tu <strong>vista de pájaro</strong>. De un solo vistazo, tienes el pulso de tu situación. Es tu panel personalizable con los famosos "Widgets", que son como tus asesores personales que nunca duermen. Puedes activarlos, desactivarlos y reordenarlos a tu antojo desde el botón de personalizar (<span class="material-icons" style="font-size: 1em; vertical-align: middle;">dashboard_customize</span>) que aparece junto al título.</p>
        <p><strong>Consejo de aiDANaI:</strong> ¡No te quedes en la superficie! Haz clic en las barras de los gráficos. Si tocas la barra de "Comida" en el gráfico de conceptos, ¡PUM! Verás todos los movimientos de comida de ese periodo. Es interactivo, ¡explóralo!</p>
    </div>
</details>

<details class="accordion" style="margin-bottom: var(--sp-2);">
    <summary><span class="material-icons" style="margin-right:8px">receipt_long</span><strong>2. Diario: ¿Qué ha pasado exactamente? (El Libro de la Verdad)</strong></summary>
    <div class="accordion__content" style="padding-top: var(--sp-2);">
        <p>Tu <strong>diario financiero</strong>, el registro notarial de cada céntimo. Aquí es donde buceas en tu historial completo. Es la verdad absoluta de tus finanzas, sin trampa ni cartón. Puedes cambiar entre la vista de lista y una <strong>vista de calendario</strong> para una perspectiva diferente.</p>
        <p><strong>Superpoder secreto:</strong> ¡El Gesto Mágico! Desliza cualquier movimiento hacia la <strong>derecha para duplicarlo</strong> (perfecto para ese café que te tomas cada mañana) o hacia la <strong>izquierda para borrarlo</strong>. Te garantizo que esto te ahorrará horas a lo largo del año.</p>
    </div>
</details>

<details class="accordion" style="margin-bottom: var(--sp-2);">
    <summary><span class="material-icons" style="margin-right:8px">rocket_launch</span><strong>3. Inversiones: ¿Mi dinero está trabajando para mí? (El Motor de Riqueza)</strong></summary>
    <div class="accordion__content" style="padding-top: var(--sp-2);">
        <p>¡La joya de la corona! Esta es la sección dedicada exclusivamente a tu portafolio. Analiza tus inversiones como un profesional con métricas clave que te harán sentir como un magnate de Wall Street:</p>
        <ul>
            <li><strong>P&L (Ganancias y Pérdidas):</strong> Es el "marcador" del partido. Te dice, en euros contantes y sonantes (y en porcentaje), si vas ganando o perdiendo basándose en las valoraciones que introduces. Simple y brutalmente honesto.</li>
            <li><strong>TIR (Tasa Interna de Retorno):</strong> ¡El indicador definitivo! Olvídate de porcentajes confusos. La TIR te dice la rentabilidad <strong>anualizada real</strong> de tu dinero, teniendo en cuenta CUÁNDO y CUÁNTO has invertido. Es la métrica que usan los profesionales para saber si una inversión de verdad merece la pena.</li>
        </ul>
    </div>
</details>
                
<details class="accordion" style="margin-bottom: var(--sp-2);">
    <summary><span class="material-icons" style="margin-right:8px">apps</span><strong>4. Otros: ¿Qué puedo automatizar y analizar? (La Sala de Herramientas)</strong></summary>
    <div class="accordion__content" style="padding-top: var(--sp-2);">
        <p>Aquí agrupamos utilidades poderosas para planificar y auditar. Es donde le dices a tu dinero qué hacer, en lugar de preguntarte a dónde se ha ido a final de mes.</p>
         <ul>
            <li><strong>Movimientos Recurrentes:</strong> ¡Automatiza tu vida! Registra tu nómina, el alquiler, Netflix, el gimnasio... y la app los tendrá listos para ti cada mes en la sección "Pendientes". Se acabó el teclear lo mismo una y otra vez.</li>
            <li><strong>Extracto de Cuenta:</strong> ¡Tu cartilla bancaria digital! Selecciona cualquier cuenta y genera un historial completo, idéntico a una cartilla tradicional, con saldo acumulado después de cada operación. Perfecto para revisiones detalladas.</li>
        </ul>
    </div>
</details>

<p style="text-align: center; margin-top: var(--sp-5); font-style: italic; color: var(--c-on-surface-secondary);">¡Explora, registra y toma el control definitivo de tu futuro financiero! Estás al mando, y yo, aiDANaI, estoy aquí para asegurarme de que ganes la partida.</p>
        `;
    }
    
    showModal('help-modal');
};
 
	const updateThemeIcon = () => {
    const themeBtn = selectOne('[data-action="toggle-theme"]');
    if (!themeBtn) return;
    
    const iconEl = themeBtn.querySelector('.material-icons');
    if (!iconEl) return;

    const themeKeys = Object.keys(THEMES);
    const currentThemeKey = document.body.dataset.theme || 'default';
    const currentIndex = themeKeys.indexOf(currentThemeKey);
    
    const nextIndex = (currentIndex + 1) % themeKeys.length;
    const nextThemeKey = themeKeys[nextIndex];

    // --- ¡ESTA ES LA LÍNEA CLAVE QUE CAMBIA! ---
    // Ahora, el icono que se muestra es el del tema ACTUAL.
    iconEl.textContent = THEMES[currentThemeKey].icon;
    
    // El tooltip sigue describiendo la acción de cambiar al siguiente tema.
    themeBtn.title = `Cambiar a Tema: ${THEMES[nextThemeKey].name}`;
};


 // REEMPLAZA LA FUNCIÓN ANTIGUA CON ESTA
const handleToggleTheme = () => {
    const themeKeys = Object.keys(THEMES);
    const currentTheme = document.body.dataset.theme || 'default';
    const currentIndex = themeKeys.indexOf(currentTheme);
    const nextIndex = (currentIndex + 1) % themeKeys.length;
    const newTheme = themeKeys[nextIndex];

    document.body.dataset.theme = newTheme;
    localStorage.setItem('appTheme', newTheme);
    hapticFeedback('light');
    updateThemeIcon(); // No necesita parámetro, ahora es más inteligente

    // Esto es importante para que los gráficos recarguen sus colores
    if (conceptosChart) conceptosChart.destroy();
    if (liquidAssetsChart) liquidAssetsChart.destroy();
    
    const activePageEl = document.querySelector('.view--active');
    const activePageId = activePageEl ? activePageEl.id : null;
    if (activePageId) {
        navigateTo(activePageId, true);
    }
};
        const showConceptosModal = () => { 
            const html = `
    <div class="form-group" style="margin-bottom: var(--sp-3);">
        <input type="search" id="concepto-search-input" class="form-input" placeholder="Buscar conceptos..." autocomplete="off">
    </div>
                <form id="add-concepto-form" novalidate style="margin-bottom: var(--sp-4);">
                    <div class="form-grid"><div class="form-group" style="grid-column: 1 / -1;"><label for="new-concepto-nombre" class="form-label">Nombre del Concepto</label><input type="text" id="new-concepto-nombre" class="form-input" placeholder="Ej: Nómina" required></div></div>
                    <button type="submit" class="btn btn--primary btn--full">Añadir Concepto</button>
                </form>
                <hr style="border-color: var(--c-outline); opacity: 0.5;"><h4 style="margin-top: var(--sp-4); margin-bottom: var(--sp-2); font-size: var(--fs-base); color: var(--c-on-surface-secondary);">Conceptos Existentes</h4><div id="conceptos-modal-list"></div>`; 
            showGenericModal('Gestionar Conceptos', html); 
            renderConceptosModalList(); 
        };
        
        const renderConceptosModalList = () => { 
            const list = select('conceptos-modal-list'); 
            if (!list) return;
			 const searchQuery = select('concepto-search-input')?.value.toLowerCase() || '';
    const conceptosFiltrados = (db.conceptos || []).filter(c => 
        c.nombre.toLowerCase().includes(searchQuery)
    );
            list.innerHTML = conceptosFiltrados.length === 0 
                ? `<p style="font-size:var(--fs-sm); color:var(--c-on-surface-secondary); text-align:center; padding: var(--sp-4) 0;">No hay conceptos.</p>` 
                : conceptosFiltrados.sort((a,b) => a.nombre.localeCompare(b.nombre)).map((c) => {
                    const icon = (c && c.icon) || 'label';
                    const nombre = (c && c.nombre) || '';
                    return `<div id="concepto-item-${c.id}" class="modal__list-item"><div style="display: flex; align-items: center; gap: 12px; flex-grow: 1; min-width: 0;"><span class="material-icons" style="color: var(--c-primary);">${icon}</span><span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHTML(nombre)}</span></div><div style="display: flex; align-items: center; gap: var(--sp-1); flex-shrink: 0;"><button class="icon-btn" data-action="edit-concepto" data-id="${c.id}" title="Editar Concepto"><span class="material-icons">edit_note</span></button><button class="icon-btn" data-action="delete-concepto" data-id="${c.id}" title="Eliminar Concepto"><span class="material-icons">delete_outline</span></button></div></div>`;
                }).join(''); 
        };
        
        const showConceptoEditForm = (id) => {
            const itemContainer = select(`concepto-item-${id}`);
            const concepto = db.conceptos.find(c => c.id === id);
            if (!itemContainer || !concepto) return;
            itemContainer.innerHTML = `
                <form class="inline-edit-form" data-id="${id}" novalidate>
                    <div class="form-group" style="margin-bottom: 0;"><label class="form-label" for="edit-concepto-nombre-${id}">Nombre</label><input type="text" id="edit-concepto-nombre-${id}" class="form-input" value="${escapeHTML(concepto.nombre)}" required></div>
                    <div style="display:flex; justify-content: flex-end; gap: var(--sp-2); align-items: center; margin-top: var(--sp-2);"><button type="button" class="btn btn--secondary" data-action="cancel-edit-concepto">Cancelar</button><button type="button" class="btn btn--primary" data-action="save-edited-concepto" data-id="${id}">Guardar</button></div>
                </form>`;
            select(`edit-concepto-nombre-${id}`).focus();
        };
        const handleSaveEditedConcept = async (id, btn) => {
            const nombreInput = select(`edit-concepto-nombre-${id}`);
            const nombre = nombreInput.value.trim();
            if (!nombre) { showToast('El nombre es obligatorio.', 'warning'); nombreInput.classList.add('form-input--invalid'); return; }
            
            await saveDoc('conceptos', id, { nombre }, btn);
			hapticFeedback('success');
			showToast('Concepto actualizado.');
			renderConceptosModalList();
        };

        const showCuentasModal = () => { 
            const existingAccountTypes = [...new Set((db.cuentas || []).map(c => c.tipo))].sort();
            const datalistOptions = existingAccountTypes.map(type => `<option value="${type}"></option>`).join('');
            const html = `
			<div class="form-group" style="margin-bottom: var(--sp-3);">
        <input type="search" id="cuenta-search-input" class="form-input" placeholder="Buscar cuentas..." autocomplete="off">
    </div>
                   <form id="add-cuenta-form" novalidate>
                <div class="form-group"><label for="new-cuenta-nombre" class="form-label">Nombre de la Cuenta</label><input type="text" id="new-cuenta-nombre" class="form-input" placeholder="Ej: Cartera personal" required></div>
                <div class="form-group"><label for="new-cuenta-tipo" class="form-label">Tipo de Cuenta</label><input type="text" id="new-cuenta-tipo" class="form-input" list="tipos-cuenta-list" placeholder="Ej: Banco, Cripto, Fintech..." required><datalist id="tipos-cuenta-list">${datalistOptions}</datalist></div>
                <button type="submit" class="btn btn--primary btn--full" style="margin-top: var(--sp-3)">Añadir Cuenta</button>
            </form>
            <hr style="margin: var(--sp-4) 0; border-color: var(--c-outline); opacity: 0.5;"><h4 style="margin-top: var(--sp-4); margin-bottom: var(--sp-2); font-size: var(--fs-base); color: var(--c-on-surface-secondary);">Cuentas Existentes</h4><div id="cuentas-modal-list"></div>`; 
            showGenericModal('Gestionar Cuentas', html); 
            renderCuentasModalList(); 
        };
    
        const renderCuentasModalList = () => {
            const list = select('cuentas-modal-list');
            if (!list) return;
            const searchQuery = select('cuenta-search-input')?.value.toLowerCase() || '';
            const cuentasFiltradas = (db.cuentas || []).filter(c => 
                c.nombre.toLowerCase().includes(searchQuery) || 
                c.tipo.toLowerCase().includes(searchQuery)
            );
            list.innerHTML = cuentasFiltradas.length === 0 
                ? `<p style="font-size:var(--fs-sm); color:var(--c-on-surface-secondary); text-align:center; padding: var(--sp-4) 0;">No hay cuentas.</p>` 
                : [...cuentasFiltradas].sort((a,b) => a.nombre.localeCompare(b.nombre)).map((c) => `
                    <div class="modal__list-item" id="cuenta-item-${c.id}">
                    <div style="display: flex; flex-direction: column; flex-grow: 1; min-width: 0;"><span style="font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHTML(c.nombre)}</span><small style="color: var(--c-on-surface-secondary); font-size: var(--fs-xs);">${toSentenceCase(escapeHTML(c.tipo))}</small></div>
                    <div style="display: flex; align-items: center; gap: var(--sp-1); flex-shrink: 0;"><div class="form-switch-group" style="gap: var(--sp-2);"><label for="offbalance-toggle-${c.id}" style="font-size: var(--fs-xs); color: var(--c-on-surface-secondary);" title="Marcar como 'Contabilidad B'">B</label><label class="form-switch"><input type="checkbox" id="offbalance-toggle-${c.id}" data-action="toggle-off-balance" data-id="${c.id}" ${c.offBalance ? 'checked' : ''}><span class="slider"></span></label></div><button class="icon-btn" data-action="edit-cuenta" data-id="${c.id}" title="Editar Cuenta"><span class="material-icons">edit_note</span></button><button class="icon-btn" data-action="delete-cuenta" data-id="${c.id}" title="Eliminar Cuenta"><span class="material-icons">delete_outline</span></button></div>
                    </div>`).join('');
        };
    
        const showAccountEditForm = (id) => {
            const itemContainer = select(`cuenta-item-${id}`);
            const cuenta = db.cuentas.find(c => c.id === id);
            if (!itemContainer || !cuenta) return;
            itemContainer.innerHTML = `
                <form class="inline-edit-form" data-id="${id}" novalidate>
                    <div class="form-grid">
                                                <div class="form-group" style="margin-bottom: 0;"><label class="form-label" for="edit-cuenta-nombre-${id}">Nombre</label><input type="text" id="edit-cuenta-nombre-${id}" class="form-input" value="${escapeHTML(cuenta.nombre)}" required></div>
                        <div class="form-group" style="margin-bottom: 0;"><label class="form-label" for="edit-cuenta-tipo-${id}">Tipo</label><input type="text" id="edit-cuenta-tipo-${id}" class="form-input" list="tipos-cuenta-list" value="${escapeHTML(cuenta.tipo)}" required></div>
                    </div>
                    <div style="display:flex; justify-content: flex-end; gap: var(--sp-2); align-items: center; margin-top: var(--sp-2);"><button type="button" class="btn btn--secondary" data-action="cancel-edit-cuenta">Cancelar</button><button type="button" class="btn btn--primary" data-action="save-edited-cuenta" data-id="${id}">Guardar</button></div>
                </form>`;
            select(`edit-cuenta-nombre-${id}`).focus();
        };
    
        const handleSaveEditedAccount = async (id, btn) => {
            const nombreInput = select(`edit-cuenta-nombre-${id}`);
            const tipoInput = select(`edit-cuenta-tipo-${id}`);
            const nombre = nombreInput.value.trim();
            const tipo = toSentenceCase(tipoInput.value.trim());
        
            if (!nombre || !tipo) { showToast('El nombre y el tipo no pueden estar vacíos.', 'warning'); if (!nombre) nombreInput.classList.add('form-input--invalid'); if (!tipo) tipoInput.classList.add('form-input--invalid'); return; }
            
            await saveDoc('cuentas', id, { nombre, tipo }, btn);
            hapticFeedback('success');
            showToast('Cuenta actualizada.');
            renderCuentasModalList();
        };

        const showRecurrentesModal = () => {
            let html = `<p class="form-label" style="margin-bottom: var(--sp-3);">Aquí puedes ver y gestionar tus operaciones programadas. Se crearán automáticamente en su fecha de ejecución.</p><div id="recurrentes-modal-list"></div>`;
            showGenericModal('Gestionar Movimientos Recurrentes', html);
            renderRecurrentesModalList();
        };
				
        const renderRecurrentesModalList = () => {
    const list = select('recurrentes-modal-list');
    if (!list) return;
    const recurrentes = [...(db.recurrentes || [])].sort((a,b) => new Date(a.nextDate) - new Date(b.nextDate));
    list.innerHTML = recurrentes.length === 0 
        ? `<div class="empty-state" style="background:transparent; padding:var(--sp-4) 0; border: none;"><span class="material-icons">event_repeat</span><h3>Sin operaciones programadas</h3><p>Puedes crear una al añadir un nuevo movimiento.</p></div>`
        : recurrentes.map(r => {
            const nextDate = new Date(r.nextDate).toLocaleDateString('es-ES', { day: '2-digit', month: 'short', year: 'numeric' });
            
            // --- LA MISMA CORRECCIÓN, APLICADA AQUÍ TAMBIÉN ---
            const frequencyMap = { once: 'Única vez', daily: 'Diaria', weekly: 'Semanal', monthly: 'Mensual', yearly: 'Anual' };
            
            const amountClass = r.cantidad >= 0 ? 'text-positive' : 'text-negative';
            const icon = r.cantidad >= 0 ? 'south_west' : 'north_east';
            return `
            <div class="modal__list-item" id="recurrente-item-${r.id}">
                <div style="display: flex; align-items: center; gap: 12px; flex-grow: 1; min-width: 0;">
                    <span class="material-icons ${amountClass}" style="font-size: 20px;">${icon}</span>
                <div style="display: flex; flex-direction: column; min-width: 0;">
                        <span style="font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHTML(r.descripcion)}</span>
                        <small style="color: var(--c-on-surface-secondary); font-size: var(--fs-xs);">Próximo: ${nextDate} (${frequencyMap[r.frequency] || 'N/A'})</small>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: var(--sp-1); flex-shrink: 0;">
                    <strong class="${amountClass}" style="margin-right: var(--sp-2);">${formatCurrency(r.cantidad)}</strong>
                    <button class="icon-btn" data-action="edit-recurrente" data-id="${r.id}" title="Editar Recurrente"><span class="material-icons">edit</span></button>
                </div>
            </div>`
        }).join('');
};

        const showManageInvestmentAccountsModal = () => {
            const visibleAccounts = getVisibleAccounts().sort((a, b) => a.nombre.localeCompare(b.nombre));
            let formHtml = `
            <form id="manage-investment-accounts-form" novalidate>
                <p class="form-label" style="margin-bottom: var(--sp-3);">
                    Selecciona las cuentas que quieres que formen parte de tu portafolio de inversión. Estas aparecerán en la sección "Portafolio" para un seguimiento detallado de su rentabilidad.
                </p>
                <div style="max-height: 40vh; overflow-y: auto; padding: var(--sp-2); background: var(--c-surface-variant); border-radius: var(--border-radius-md);">`;

            if (visibleAccounts.length > 0) {
                formHtml += visibleAccounts.map(c => `
                    <div class="form-checkbox-group modal__list-item" style="padding: var(--sp-2);">
                        <input type="checkbox" id="investment-toggle-${c.id}" value="${c.id}" ${c.esInversion ? 'checked' : ''}>
                        <label for="investment-toggle-${c.id}" style="flex-grow: 1;">${escapeHTML(c.nombre)} <small>(${toSentenceCase(c.tipo)})</small></label>
                    </div>
                `).join('');
            } else {
                formHtml += `<p class="empty-state" style="background: transparent; border: none;">No hay cuentas en la contabilidad actual para configurar.</p>`;
            }

            formHtml += `
                </div>
				<div style="border-top: 1px solid var(--c-outline); padding-top: var(--sp-4); margin-top: var(--sp-4);">
    <h4 style="color: var(--c-danger);">Zona de Peligro</h4>
    <p class="form-label" style="margin-bottom: var(--sp-3);">
        Esta acción creará una nueva valoración para TODOS tus activos de inversión, igualando su valor al capital aportado. Esto pondrá su P&L a cero a fecha de hoy.
    </p>
    <button type="button" class="btn btn--danger btn--full" data-action="reset-portfolio-baseline">
        <span class="material-icons" style="font-size: 16px;">restart_alt</span>
        <span>Resetear P&L de Todos los Activos</span>
    </button>
</div>
                <div class="modal__actions">
                    <button type="submit" class="btn btn--primary btn--full">Guardar Selección</button>
                </div>
            </form>`;

            showGenericModal('Gestionar Activos de Inversión', formHtml);
        };

        
// =========================================================================
// === INICIO: MODAL DE CONFIGURACIÓN DE WIDGETS (v2.2 - VERSIÓN FINAL) ===
// =========================================================================
const showDashboardConfigModal = () => {
    const savedWidgetOrder = (db.config && db.config.dashboardWidgets) || DEFAULT_DASHBOARD_WIDGETS;
    const widgetOrder = savedWidgetOrder.filter(widgetId => AVAILABLE_WIDGETS[widgetId]);
    
    let listHtml = widgetOrder.map(widgetId => 
        renderWidgetConfigItem(widgetId, AVAILABLE_WIDGETS[widgetId], true)
    ).join('');

    listHtml += Object.keys(AVAILABLE_WIDGETS)
        .filter(id => !widgetOrder.includes(id))
        .map(widgetId => renderWidgetConfigItem(widgetId, AVAILABLE_WIDGETS[widgetId], false))
        .join('');

    const modalHtml = `
        <p class="form-label">Activa, desactiva y reordena los elementos que quieres ver en tu panel de control.</p>
        <div id="widget-config-list" style="margin-top: var(--sp-4);">${listHtml}</div>
        <div class="modal__actions">
            <button class="btn btn--primary btn--full" data-action="save-dashboard-config">Guardar Cambios</button>
        </div>`;
    showGenericModal('Personalizar Panel', modalHtml);

    const list = select('widget-config-list');
    
    Sortable.create(list, {
        handle: '.drag-handle',
        animation: 150,
    });
};

const renderWidgetConfigItem = (id, details, isEnabled) => `
    <div class="widget-config-item" data-id="${id}">
        <span class="material-icons drag-handle">drag_indicator</span>
        <div class="widget-config-item__details">
            <p class="widget-config-item__title">${details.title}</p>
            <p class="widget-config-item__desc">${details.description}</p>
        </div>
        <label class="form-switch"><input type="checkbox" ${isEnabled ? 'checked' : ''}><span class="slider"></span></label>
    </div>`;

const handleSaveDashboardConfig = async (btn) => {
    setButtonLoading(btn, true);
    const list = select('widget-config-list');
    if (!list) return;

    const newOrder = Array.from(list.querySelectorAll('.widget-config-item'))
        .filter(item => item.querySelector('input[type="checkbox"]').checked)
        .map(item => item.dataset.id);

    if (!db.config) db.config = {};
    db.config.dashboardWidgets = newOrder;
    await fbDb.collection('users').doc(currentUser.uid).set({ config: db.config }, { merge: true });
    
    setButtonLoading(btn, false);
    hideModal('generic-modal');
    hapticFeedback('success');
    showToast('Panel actualizado.');
    renderInicioResumenView();
};

// =============================================================
// === BLOQUE ÚNICO Y DEFINITIVO PARA LA PESTAÑA DE INFORMES ===
// =============================================================

const renderInformeCuentaRow = (mov, cuentaId, allCuentas) => {
    const fecha = new Date(mov.fecha).toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit' });
    let importe = 0;
    let colorClass = '';
    let descripcionFinal = '';

    if (mov.tipo === 'traspaso') {
        const origen = allCuentas.find(c => c.id === mov.cuentaOrigenId);
        const destino = allCuentas.find(c => c.id === mov.cuentaDestinoId);
        
        if (mov.cuentaOrigenId === cuentaId) {
            importe = -mov.cantidad;
            colorClass = 'text-gasto';
            descripcionFinal = `Traspaso a ${destino ? escapeHTML(destino.nombre) : '?'}`;
        } else {
            importe = mov.cantidad;
            colorClass = 'text-ingreso';
            descripcionFinal = `Traspaso desde ${origen ? escapeHTML(origen.nombre) : '?'}`;
        }
        if (mov.descripcion && mov.descripcion.toLowerCase() !== 'traspaso') {
            descripcionFinal += ` - ${escapeHTML(mov.descripcion)}`;
        }
    } else {
        importe = mov.cantidad;
        colorClass = importe >= 0 ? 'text-ingreso' : 'text-gasto';
        descripcionFinal = mov.descripcion ? escapeHTML(mov.descripcion) : 'Movimiento sin descripción';
    }

    // NUEVO HTML con la estructura Flexbox
    return `
        <div class="informe-linea-movimiento">
            <span class="fecha">${fecha}</span>
            <span class="descripcion">${descripcionFinal}</span>
            <span class="importe ${colorClass}">${formatCurrency(importe)}</span>
			<span class="saldo">${formatCurrency(mov.runningBalance)}</span>
        </div>
    `;
};

const handleGenerateInformeCuenta = async (form, btn) => {
    setButtonLoading(btn, true, 'Generando...');
    const cuentaId = select('informe-cuenta-select').value;
    const resultadoContainer = select('informe-resultado-container');

    if (!cuentaId || !resultadoContainer) {
        showToast("Por favor, selecciona una cuenta.", "warning");
        setButtonLoading(btn, false);
        return;
    }

    const cuenta = db.cuentas.find(c => c.id === cuentaId);
    if (!cuenta) {
         showToast("Cuenta no encontrada.", "danger");
         setButtonLoading(btn, false);
         return;
    }

    resultadoContainer.innerHTML = `<div class="card"><div class="card__content" style="text-align:center;"><span class="spinner"></span></div></div>`;

    try {
        // 1. Obtener TODOS los movimientos (considera obtener solo los de la cuenta si el rendimiento se ve afectado)
        const todosLosMovimientos = await fetchAllMovementsForHistory();

        // 2. Filtrar movimientos relacionados con la cuenta seleccionada
        const movimientosDeLaCuenta = todosLosMovimientos.filter(m =>
            (m.cuentaId === cuentaId) ||
            (m.cuentaOrigenId === cuentaId) ||
            (m.cuentaDestinoId === cuentaId)
        );

        // Si no hay movimientos, mostrar estado vacío
        if (movimientosDeLaCuenta.length === 0) {
             resultadoContainer.innerHTML = `
                <h3 class="card__title">Extracto de ${escapeHTML(cuenta.nombre)}</h3>
                <div class="empty-state"><p>Esta cuenta no tiene movimientos.</p></div>`;
             setButtonLoading(btn, false);
             return;
        }

        // 3. Ordenar movimientos ANTIGUO -> NUEVO para cálculo de saldo acumulado
        movimientosDeLaCuenta.sort((a, b) => new Date(a.fecha).getTime() - new Date(b.fecha).getTime() || a.id.localeCompare(b.id));

        // 4. Calcular Saldos Acumulados (Iterando ANTIGUO -> NUEVO)
        // Determinar el saldo inicial *antes* del primer movimiento en la lista
        const impactoTotalHistorico = movimientosDeLaCuenta.reduce((sum, mov) => {
            if (mov.tipo === 'traspaso') {
                if (mov.cuentaOrigenId === cuentaId) return sum - mov.cantidad;
                if (mov.cuentaDestinoId === cuentaId) return sum + mov.cantidad;
            } else if (mov.cuentaId === cuentaId) { // Solo contar movimientos directos para cálculo de saldo
                return sum + mov.cantidad;
            }
            return sum;
        }, 0);
        let saldoAcumulado = (cuenta.saldo || 0) - impactoTotalHistorico;

        // Asignar saldo acumulado a cada movimiento
        for (const mov of movimientosDeLaCuenta) {
            if (mov.tipo === 'traspaso') {
                if (mov.cuentaOrigenId === cuentaId) saldoAcumulado -= mov.cantidad;
                if (mov.cuentaDestinoId === cuentaId) saldoAcumulado += mov.cantidad;
            } else if (mov.cuentaId === cuentaId) { // Solo ajustar por movimientos directos
                saldoAcumulado += mov.cantidad;
            }
            // Guardar el saldo *después* de que ocurriera el movimiento
            mov.runningBalance = saldoAcumulado;
        }

        // 5. Agrupar movimientos por Mes (YYYY-MM)
        const groupedByMonth = movimientosDeLaCuenta.reduce((acc, mov) => {
            const monthKey = mov.fecha.slice(0, 7); // "YYYY-MM"
            if (!acc[monthKey]) {
                acc[monthKey] = [];
            }
            acc[monthKey].push(mov);
            return acc;
        }, {});

        // 6. Generar HTML (Iterando NUEVO -> ANTIGUO para mostrar)
        let resultadoHtml = `
			<h3 class="card__title">
			<span>Extracto de ${escapeHTML(cuenta.nombre)}</span>
			</h3>
				<div class="informe-extracto-container">
                <div class="informe-linea-header">
                    <span class="fecha">Fecha</span>
                    <span class="descripcion">Descripción</span>
                    <span class="importe">Importe</span>
                    <span class="saldo">Saldo</span>
                </div>`;

        // Función auxiliar para calcular el impacto específico en la cuenta
        const calculateAccountImpact = (mov, accId) => {
             if (mov.tipo === 'traspaso') {
                if (mov.cuentaOrigenId === accId) return -mov.cantidad;
                if (mov.cuentaDestinoId === accId) return mov.cantidad;
             } else if (mov.cuentaId === accId) {
                return mov.cantidad;
             }
             return 0; // El movimiento no impacta el flujo de caja de esta cuenta
        };


        // Obtener claves de mes y ordenar NUEVO -> ANTIGUO
        const sortedMonthKeys = Object.keys(groupedByMonth).sort().reverse();

        for (const monthKey of sortedMonthKeys) {
            const movementsForMonth = groupedByMonth[monthKey];

            // 1. INICIALIZAR los totales del mes a CERO ANTES del bucle de movimientos
            let monthIncome = 0;
            let monthExpense = 0;

            // 2. Ordenar movimientos dentro del mes (NUEVO -> ANTIGUO para mostrar)
            movementsForMonth.sort((a, b) => new Date(b.fecha).getTime() - new Date(a.fecha).getTime() || b.id.localeCompare(a.id));

            // 3. BUCLE PARA AÑADIR LAS FILAS DE MOVIMIENTOS Y CALCULAR TOTALES
            for (const mov of movementsForMonth) {
                // Añadir la fila del movimiento al HTML
                resultadoHtml += renderInformeCuentaRow(mov, cuentaId, db.cuentas); // Usa el runningBalance precalculado

                // Calcular el impacto de este movimiento y sumarlo a los totales del mes
                const impact = calculateAccountImpact(mov, cuentaId);
                if (impact > 0) {
                    monthIncome += impact;
                } else {
                    monthExpense += impact; // Los gastos son negativos
                }
            } // <-- FIN del bucle for (const mov...)

            // 4. DESPUÉS del bucle de movimientos, calcular el neto y AÑADIR LA FILA DE RESUMEN
            const monthNet = monthIncome + monthExpense;
            // Usar día 2 para crear la fecha evita problemas con zonas horarias al obtener el nombre del mes
            const monthDate = new Date(monthKey + '-02T12:00:00Z');
            const monthName = monthDate.toLocaleDateString('es-ES', { month: 'long', year: 'numeric', timeZone: 'UTC' });

            resultadoHtml += `
                <div class="informe-linea-resumen">
                    <span class="fecha"></span>
                    <span class="descripcion">${monthName}: Ingresos ${formatCurrency(monthIncome)} - Gastos ${formatCurrency(Math.abs(monthExpense))}</span>
                    <span class="importe ${monthNet >= 0 ? 'text-ingreso' : 'text-gasto'}">${formatCurrency(monthNet)}</span>
                    <span class="saldo"></span>
                </div>`; // <-- Fila de resumen añadida AL FINAL

        } // --- FIN DEL BUCLE DE MESES ---

        // Cerrar el contenedor principal del informe
        resultadoHtml += `</div>`;
        resultadoContainer.innerHTML = resultadoHtml;
    } catch (error) {
        console.error("Error generando informe de cuenta:", error);
        resultadoContainer.innerHTML = `<div class="card card--no-bg text-danger" style="padding: var(--sp-4); text-align: center;">Error al generar el informe.</div>`;
        showToast("No se pudo generar el extracto.", "danger");
    } finally {
        setButtonLoading(btn, false);
    }
};

// =================================================================
// === FIN DEL BLOQUE DEFINITIVO                                 ===
// =================================================================

const attachEventListeners = () => {
    const cantidadInput = document.getElementById("movimiento-cantidad");
    if (cantidadInput) {
        const cantidadError = document.getElementById("movimiento-cantidad-error");

        cantidadInput.addEventListener("input", () => {
            let valor = cantidadInput.value.trim();
            valor = valor.replace(",", ".");
            const regex = /^\d+(.\d{0,2})?$/;

            if (valor === "" || !regex.test(valor)) {
                cantidadError.textContent = "Introduce un número positivo (ej: 2,50 o 15.00)";
                cantidadInput.classList.add("form-input--error");
            } else {
                cantidadError.textContent = "";
                cantidadInput.classList.remove("form--error");
            }
        });

        const descripcionInput = document.getElementById("movimiento-descripcion");
        const cuentaSelect = document.getElementById("movimiento-cuenta");
        const saveBtn = document.getElementById("save-movimiento-btn");
        
        document.addEventListener("show-modal", (e) => {
            if (e.detail.modalId === "movimiento-modal") {
                setTimeout(() => cantidadInput.focus(), 100);
            }
        });

        cantidadInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                descripcionInput.focus();
            }
        });
        
        descripcionInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                cuentaSelect.focus();
            }
        });
        
        cuentaSelect.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                saveBtn.click();
            }
        });
    }
    const amountInputForFormatting = select('movimiento-cantidad');
    if (amountInputForFormatting) {
        amountInputForFormatting.addEventListener('focus', (e) => {
            const input = e.target;
            if (input.value === '') return;
            const rawValue = input.value.replace(/\./g, '');
            input.value = rawValue;
        });
        amountInputForFormatting.addEventListener('blur', (e) => {
            const input = e.target;
            if (input.value === '') return;
            const numericValue = parseCurrencyString(input.value);
            input.value = formatAsCurrencyInput(numericValue);
        });
    }
    window.addEventListener('popstate', (event) => {
        const activeModal = document.querySelector('.modal-overlay--active');
        if (activeModal) {
            hideModal(activeModal.id);
            history.pushState({ page: window.history.state?.page }, '', `#${window.history.state?.page || 'panel-page'}`);
            return;
        }
        const pageToNavigate = event.state ? event.state.page : PAGE_IDS.INICIO;
        if (pageToNavigate) {
            navigateTo(pageToNavigate, false);
        }
    });
    
    document.body.addEventListener('click', async (e) => {
        const target = e.target;
        
        if (target.matches('.input-amount-calculator')) {
            e.preventDefault();
            showCalculator(target);
            return;
        }

        const actionTarget = target.closest('[data-action]');
        
        if (!actionTarget && !target.closest('.transaction-card')) {
             resetActiveSwipe();
        }
        
        if (!actionTarget) return;

        const { action, id, page, type, modalId, reportId } = actionTarget.dataset;
        const btn = actionTarget.closest('button');
              
        const actions = {
			 'show-main-menu': () => {
    const menu = document.getElementById('main-menu-popover');
    if (!menu) return;

    // Muestra u oculta el menú
    menu.classList.toggle('popover-menu--visible');

    // Si el menú se acaba de hacer visible, preparamos un "detector de clics"
    if (menu.classList.contains('popover-menu--visible')) {
        // Usamos un pequeño truco para que este detector no se active con el mismo clic que abrió el menú
        setTimeout(() => {
            const closeOnClickOutside = (event) => {
                // Si se hace clic fuera del menú, lo cerramos
                if (!menu.contains(event.target) && !event.target.closest('[data-action="show-main-menu"]')) {
                    menu.classList.remove('popover-menu--visible');
                    // Importante: una vez cerrado, eliminamos el detector para que no se quede escuchando para siempre
                    document.removeEventListener('click', closeOnClickOutside);
                }
            };
            // Añadimos el detector a todo el documento
            document.addEventListener('click', closeOnClickOutside);
        }, 0);
    }
},
            'toggle-fab-menu': toggleFabMenu,
            'open-fab-action': (e) => {
                const button = e.target.closest('[data-type]');
                if (!button) return;
                document.querySelector('.fab-container').classList.remove('fab-container--active');
                startMovementForm();
                setTimeout(() => {
                    setMovimientoFormType(button.dataset.type);
                }, 50);
            },
            'export-filtered-csv': () => handleExportFilteredCsv(btn),
            'show-diario-filters': showDiarioFiltersModal,
            'clear-diario-filters': clearDiarioFilters,	
            'toggle-amount-type': () => {
                const amountInput = select('movimiento-cantidad');
                const amountGroup = select('movimiento-cantidad-form-group');
                if (!amountInput || !amountGroup) return;
                hapticFeedback('light');
                const currentValue = parseCurrencyString(amountInput.value) || 0;
                const isCurrentlyGasto = amountGroup.classList.contains('is-gasto');
                const newValue = currentValue === 0 ? 0 : -currentValue;
                amountInput.value = newValue.toLocaleString('es-ES', { useGrouping: false, minimumFractionDigits: 2, maximumFractionDigits: 2 });
                updateAmountTypeUI(!isCurrentlyGasto);
            },
            'context-edit': () => {
                hideModal('generic-modal');
                startMovementForm(id, false);
            },
            'context-duplicate': () => {
                hideModal('generic-modal');
                const movement = db.movimientos.find(m => m.id === id);
                if(movement) handleDuplicateMovement(movement);
            },
            'context-delete': () => {
                hideModal('generic-modal');
                showConfirmationModal('¿Seguro que quieres eliminar este movimiento?', async () => {
                    await deleteMovementAndAdjustBalance(id, false);
                });
            },
            'show-kpi-drilldown': () => handleKpiDrilldown(actionTarget),
            'edit-movement-from-modal': (e) => {
                const movementId = e.target.closest('[data-id]').dataset.id;
                hideModal('generic-modal');
                startMovementForm(movementId, false);
            },
            'edit-movement-from-list': (e) => {
                const movementId = e.target.closest('[data-id]').dataset.id;
                startMovementForm(movementId, false);
            },
            'view-account-details': (e) => {
                const accountId = e.target.closest('[data-id]').dataset.id;
                showAccountMovementsModal(accountId);
            },
            'apply-description-suggestion': (e) => {
                const suggestionItem = e.target.closest('.suggestion-item');
                if (suggestionItem) {
                    const { description, conceptoId, cuentaId } = suggestionItem.dataset;
                    select('movimiento-descripcion').value = toSentenceCase(description); 
                    select('movimiento-concepto').value = conceptoId;
                    select('movimiento-cuenta').value = cuentaId;
                    select('description-suggestions').style.display = 'none';
                    [select('movimiento-concepto'), select('movimiento-cuenta')].forEach(el => {
                        const parent = el.closest('.form-group-addon');
                        if(parent) {
                            parent.classList.add('field-highlighted');
                            setTimeout(() => parent.classList.remove('field-highlighted'), 1500);
                        }
                    });
                    select('movimiento-cantidad').focus();
                    hapticFeedback('light');
                }
            },
            'show-aidanai-help': () => {
                const activeView = document.querySelector('.view--active');
                const pageId = activeView ? activeView.id : PAGE_IDS.INICIO;
                showAidanaiModal(pageId);
            },
            'show-concept-drilldown': () => {
                const conceptId = actionTarget.dataset.conceptId;
                const conceptName = actionTarget.dataset.conceptName;
                getFilteredMovements(false).then(({ current }) => {
                    const movementsOfConcept = current.filter(m => m.conceptoId === conceptId);
                    showDrillDownModal(`Movimientos de: ${conceptName}`, movementsOfConcept);
                });
            },
            'toggle-diario-view': () => { diarioViewMode = diarioViewMode === 'list' ? 'calendar' : 'list'; const btnIcon = selectOne('[data-action="toggle-diario-view"] .material-icons'); if(btnIcon) btnIcon.textContent = diarioViewMode === 'list' ? 'calendar_month' : 'list'; renderDiarioPage(); },
            'calendar-nav': () => {
                const direction = actionTarget.dataset.direction;
                if (!(diarioCalendarDate instanceof Date) || isNaN(diarioCalendarDate)) {
                    diarioCalendarDate = new Date();
                }
                const currentMonth = diarioCalendarDate.getUTCMonth();
                diarioCalendarDate.setUTCMonth(currentMonth + (direction === 'next' ? 1 : -1));
                renderDiarioCalendar(); 
            },
            'show-day-details': () => {
                const date = actionTarget.dataset.date;
                const movementsOfDay = db.movimientos.filter(m => m.fecha.startsWith(date));
                if (movementsOfDay.length > 0) {
                    const formattedDate = new Date(date + 'T12:00:00Z').toLocaleDateString('es-ES', { day: 'numeric', month: 'long', year: 'numeric' });
                    showDrillDownModal(`Movimientos del ${formattedDate}`, movementsOfDay);
                }
            },
            'toggle-investment-type-filter': () => handleToggleInvestmentTypeFilter(type),
            'toggle-account-type-filter': () => { hapticFeedback('light'); if (deselectedAccountTypesFilter.has(type)) { deselectedAccountTypesFilter.delete(type); } else { deselectedAccountTypesFilter.add(type); } renderPatrimonioPage(); },
            'show-help-topic': () => { const topic = actionTarget.dataset.topic; if(topic) { let title, content; if (topic === 'tasa-ahorro') { title = '¿Cómo se calcula la Tasa de Ahorro?'; content = `<p>Mide qué porcentaje de tus ingresos consigues guardar después de cubrir todos tus gastos en el periodo seleccionado.</p><h4>Fórmula:</h4><code style="display: block; background: var(--c-surface-variant); padding: var(--sp-2); border-radius: 6px; font-size: 0.9em; margin-top: var(--sp-1);">(Saldo Neto del Periodo / Ingresos Totales del Periodo) * 100</code><p style="margin-top: var(--sp-2);">Es el indicador clave de tu capacidad para generar riqueza.</p>`; } else if (topic === 'patrimonio-neto') { title = '¿Cómo se calcula el Patrimonio Neto?'; content = `<p>Representa tu riqueza total. Es la suma de todo lo que tienes (activos) menos todo lo que debes (pasivos).</p><h4>Fórmula:</h4><code style="display: block; background: var(--c-surface-variant); padding: var(--sp-2); border-radius: 6px; font-size: 0.9em; margin-top: var(--sp-1);">Suma de los saldos de todas tus cuentas.</code><p style="margin-top: var(--sp-2);"><strong>Importante:</strong> Este valor es siempre tu situación global actual y no se ve afectado por los filtros de fecha del panel.</p>`; } else if (topic === 'pnl-inversion') { title = '¿Cómo se calcula el P&L de Inversión?'; content = `<p>P&L son las siglas de "Profits and Losses" (Ganancias y Pérdidas). Mide el <strong>flujo de caja neto</strong> de tus cuentas de inversión durante el periodo seleccionado.</p><h4>Fórmula:</h4><code style="display: block; background: var(--c-surface-variant); padding: var(--sp-2); border-radius: 6px; font-size: 0.9em; margin-top: var(--sp-1);">Suma de todos los movimientos en cuentas de inversión.</code><p style="margin-top: var(--sp-2);">No incluye la revalorización de activos que no hayas vendido. Es útil para saber si tus inversiones te están dando dinero (dividendos, ventas) o si estás invirtiendo más capital (compras).</p>`; } else if (topic === 'progreso-presupuesto') { title = '¿Cómo se calcula el Progreso del Presupuesto?'; content = `<p>Compara tus gastos reales con tu plan de gastos para el periodo seleccionado.</p><h4>Fórmula:</h4><ol style="list-style-position: inside; padding-left: var(--sp-2);"><li style="margin-bottom: 6px;">Se calcula tu <strong>límite de gasto proporcional</strong> para el periodo (ej. Presupuesto Anual / 12 para un mes).</li><li style="margin-bottom: 6px;">Se comparan tus <strong>gastos reales</strong> del periodo con ese límite.</li></ol><p style="margin-top: var(--sp-2);">Te ayuda a ver si te estás ciñendo a tu plan financiero y a corregir desviaciones a tiempo.</p>`; } else if (topic === 'colchon-emergencia') { title = 'Colchón de Emergencia'; content = `<p>Es tu red de seguridad financiera. Mide cuántos meses podrías vivir cubriendo tus gastos si dejaras de tener ingresos hoy mismo.</p><h4>Fórmula:</h4><code style="display: block; background: var(--c-surface-variant); padding: var(--sp-2); border-radius: 6px; font-size: 0.9em; margin-top: var(--sp-1);">Dinero Líquido Total / Gasto Mensual Promedio</code><p style="margin-top: var(--sp-2);">Se considera "dinero líquido" el saldo de tus cuentas de tipo Banco, Ahorro y Efectivo.</p>`; } else if (topic === 'independencia-financiera') { title = 'Independencia Financiera (I.F.)'; content = `<p>Mide tu progreso para alcanzar el punto en el que tus inversiones podrían cubrir tus gastos para siempre, sin necesidad de trabajar.</p><h4>Fórmula del Objetivo:</h4><code style="display: block; background: var(--c-surface-variant); padding: var(--sp-2); border-radius: 6px; font-size: 0.9em; margin-top: var(--sp-1);">(Gasto Mensual Promedio * 12) * 30</code><p style="margin-top: var(--sp-2);">El porcentaje muestra qué parte de ese objetivo ya has alcanzado con tu patrimonio neto actual.</p>`; } const titleEl = select('help-modal-title'); const bodyEl = select('help-modal-body'); if(titleEl) titleEl.textContent = title; if(bodyEl) bodyEl.innerHTML = `<div style="padding: 0 var(--sp-2);">${content}</div>`; showModal('help-modal'); } },
            'configure-dashboard': (e) => { e.preventDefault(); showDashboardConfigModal(); },
            'save-dashboard-config': () => handleSaveDashboardConfig(btn),
            'use-password-instead': () => showPasswordFallback(),
            'toggle-theme': () => { handleToggleTheme(); hapticFeedback('light'); },
            'navigate': () => { hapticFeedback('light'); navigateTo(page); },
            'help': showHelpModal,
            'exit': handleExitApp,
            'forgot-password': (e) => { e.preventDefault(); const email = prompt("Por favor, introduce el correo electrónico de tu cuenta para restablecer la contraseña:"); if (email) { firebase.auth().sendPasswordResetEmail(email).then(() => { showToast('Se ha enviado un correo para restablecer tu contraseña.', 'info', 5000); }).catch((error) => { console.error("Error al enviar correo de recuperación:", error); if (error.code === 'auth/user-not-found') { showToast('No se encontró ninguna cuenta con ese correo.', 'danger'); } else { showToast('Error al intentar restablecer la contraseña.', 'danger'); } }); } },
            'show-register': (e) => { e.preventDefault(); const title = select('login-title'); const mainButton = document.querySelector('#login-form button[data-action="login"]'); const secondaryAction = document.querySelector('.login-view__secondary-action'); if (mainButton.dataset.action === 'login') { title.textContent = 'Crear una Cuenta Nueva'; mainButton.dataset.action = 'register'; mainButton.textContent = 'Registrarse'; secondaryAction.innerHTML = `<span>¿Ya tienes una cuenta?</span> <a href="#" class="login-view__link" data-action="show-login">Inicia sesión</a>`; } else { handleRegister(mainButton); } },
            'show-login': (e) => { e.preventDefault(); const title = select('login-title'); const mainButton = document.querySelector('#login-form button[data-action="register"]'); const secondaryAction = document.querySelector('.login-view__secondary-action'); if (mainButton.dataset.action === 'register') { title.textContent = 'Bienvenido de nuevo'; mainButton.dataset.action = 'login'; mainButton.textContent = 'Iniciar Sesión'; secondaryAction.innerHTML = `<span>¿No tienes una cuenta?</span> <a href="#" class="login-view__link" data-action="show-register">Regístrate aquí</a>`; } },
            'import-csv': showCsvImportWizard,
            'toggle-ledger': async () => {
                hapticFeedback('medium');
                isOffBalanceMode = !isOffBalanceMode;
                document.body.dataset.ledgerMode = isOffBalanceMode ? 'B' : 'A';
                const toggleBtn = select('ledger-toggle-btn');
                if (toggleBtn) {
                    toggleBtn.innerHTML = ` ${isOffBalanceMode ? 'B' : 'A'}`;
                    toggleBtn.title = `Cambiar a Contabilidad ${isOffBalanceMode ? 'A' : 'B'}`;
                }
                const activePageEl = selectOne('.view--active');
                const activePageId = activePageEl ? activePageEl.id : PAGE_IDS.INICIO;
                const pageRenderers = {
                    [PAGE_IDS.INICIO]: renderInicioPage,
                    [PAGE_IDS.DIARIO]: renderDiarioPage,
                    [PAGE_IDS.INVERSIONES]: renderInversionesView,
                    [PAGE_IDS.OTROS]: renderOtrosPage, // Añadido
                    [PAGE_IDS.CONFIGURACION]: loadConfig,
                };
                if (pageRenderers[activePageId]) {
                    await pageRenderers[activePageId]();
                }
                showToast(`Mostrando Contabilidad ${isOffBalanceMode ? 'B' : 'A'}.`, 'info');
            },
            'toggle-off-balance': async () => { const checkbox = target.closest('input[type="checkbox"]'); if (!checkbox) return; hapticFeedback('light'); await saveDoc('cuentas', checkbox.dataset.id, { offBalance: checkbox.checked }); },
            'apply-filters': () => { hapticFeedback('light'); scheduleDashboardUpdate(); },
            'edit-recurrente': () => { hideModal('generic-modal'); startMovementForm(id, true); },
            'delete-movement-from-modal': () => { const isRecurrent = (actionTarget.dataset.isRecurrent === 'true'); const idToDelete = select('movimiento-id').value; const message = isRecurrent ? '¿Seguro que quieres eliminar esta operación recurrente?' : '¿Seguro que quieres eliminar este movimiento?'; showConfirmationModal(message, async () => { hideModal('movimiento-modal'); await deleteMovementAndAdjustBalance(idToDelete, isRecurrent); }); },
            'swipe-delete-movement': () => { const isRecurrent = actionTarget.dataset.isRecurrent === 'true'; showConfirmationModal('¿Seguro que quieres eliminar este movimiento?', async () => { await deleteMovementAndAdjustBalance(id, isRecurrent); }); },
            'swipe-duplicate-movement': () => {
                const movement = db.movimientos.find(m => m.id === id) || recentMovementsCache.find(m => m.id === id);
                if (movement) {
                    handleDuplicateMovement(movement);
                }
            },
            'search-result-movimiento': (e) => {
                hideModal('global-search-modal');
                startMovementForm(e.target.closest('[data-id]').dataset.id, false);
            },
            'delete-concepto': async () => { const movsCheck = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos').where('conceptoId', '==', id).limit(1).get(); if(!movsCheck.empty) { showToast("Concepto en uso, no se puede borrar.","warning"); return; } showConfirmationModal('¿Seguro que quieres eliminar este concepto?', async () => { await deleteDoc('conceptos', id); hapticFeedback('success'); showToast("Concepto eliminado."); renderConceptosModalList(); }); },
            'delete-cuenta': async () => { const movsCheck = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos').where('cuentaId', '==', id).limit(1).get(); if(!movsCheck.empty) { showToast("Cuenta con movimientos, no se puede borrar.","warning",3500); return; } showConfirmationModal('¿Seguro que quieres eliminar esta cuenta?', async () => { await deleteDoc('cuentas', id); hapticFeedback('success'); showToast("Cuenta eliminada."); renderCuentasModalList(); }); },
            'close-modal': () => { const closestOverlay = target.closest('.modal-overlay'); const effectiveModalId = modalId || (closestOverlay ? closestOverlay.id : null); if (effectiveModalId) hideModal(effectiveModalId); },
            'manage-conceptos': showConceptosModal, 'manage-cuentas': showCuentasModal,
            'save-config': () => handleSaveConfig(btn),
            'export-data': () => handleExportData(btn), 'export-csv': () => handleExportCsv(btn), 'import-data': () => showImportJSONWizard(),
            'clear-data': () => { showConfirmationModal('¿Borrar TODOS tus datos de la nube? Esta acción es IRREVERSIBLE y no se puede deshacer.', async () => { /* Lógica de borrado aquí */ }, 'Confirmación Final de Borrado'); },
            'delete-account': () => { showConfirmationModal('Esto eliminará tu cuenta y todos tus datos de forma PERMANENTE. ¿Estás absolutamente seguro?', async () => { /* Lógica de borrado de cuenta aquí */ }); },
            'manage-investment-accounts': showManageInvestmentAccountsModal, 'update-asset-value': () => showValoracionModal(id),
            'set-investment-chart-mode': () => handleSetInvestmentChartMode(actionTarget.dataset.mode),
            'global-search': () => {
                showGlobalSearchModal();
                hapticFeedback('medium');
            },
            'edit-concepto': () => showConceptoEditForm(id), 'cancel-edit-concepto': renderConceptosModalList, 'save-edited-concepto': () => handleSaveEditedConcept(id, btn),
            'edit-cuenta': () => showAccountEditForm(id), 'cancel-edit-cuenta': renderCuentasModalList, 'save-edited-cuenta': () => handleSaveEditedAccount(id, btn),
            'duplicate-movement': () => {
                hapticFeedback('medium');
                select('movimiento-mode').value = 'new';
                select('movimiento-id').value = '';
                select('form-movimiento-title').textContent = 'Duplicar Movimiento';
                select('delete-movimiento-btn').classList.add('hidden');
                select('duplicate-movimiento-btn').classList.add('hidden');
                const today = new Date();
                const fechaInput = select('movimiento-fecha');
                fechaInput.value = new Date(today.getTime() - (today.getTimezoneOffset() * 60000)).toISOString().slice(0, 10);
                updateDateDisplay(fechaInput);
                showToast('Datos duplicados. Ajusta y guarda como nuevo.', 'info');
            },
            'save-and-new-movement': () => handleSaveMovement(document.getElementById('form-movimiento'), btn), 'set-movimiento-type': () => setMovimientoFormType(type),
            'recalculate-balances': () => {
                showConfirmationModal(
                    'Esta es una herramienta de auditoría que recalculará el saldo de cada cuenta desde cero, leyendo todo tu historial de movimientos. Úsala solo si sospechas que hay una inconsistencia. La operación puede tardar y consumir datos. ¿Quieres continuar?',
                    () => auditAndFixAllBalances(btn),
                    'Confirmar Auditoría Completa'
                );
            }, 'json-wizard-back-2': () => goToJSONStep(1), 'json-wizard-import-final': () => handleFinalJsonImport(btn),
            'toggle-traspaso-accounts-filter': () => populateTraspasoDropdowns(), 'set-pin': async () => { const pin = prompt("Introduce tu nuevo PIN de 4 dígitos. Déjalo en blanco para eliminarlo."); if (pin === null) return; if (pin === "") { localStorage.removeItem('pinUserHash'); localStorage.removeItem('pinUserEmail'); showToast('PIN de acceso rápido eliminado.', 'info'); return; } if (!/^\d{4}$/.test(pin)) { showToast('El PIN debe contener exactamente 4 dígitos numéricos.', 'danger'); return; } const pinConfirm = prompt("Confirma tu nuevo PIN de 4 dígitos."); if (pin !== pinConfirm) { showToast('Los PINs no coinciden. Inténtalo de nuevo.', 'danger'); return; } const pinHash = await hashPin(pin); localStorage.setItem('pinUserHash', pinHash); localStorage.setItem('pinUserEmail', currentUser.email); hapticFeedback('success'); showToast('¡PIN de acceso rápido configurado con éxito!', 'info'); },
            'edit-recurrente-from-pending': () => startMovementForm(id, true),
            'confirm-recurrent': () => handleConfirmRecurrent(id, btn), 'skip-recurrent': () => handleSkipRecurrent(id, btn),
            };
        
        if (actions[action]) {
            actions[action](e);
        }
    });

    document.body.addEventListener('toggle', (e) => {
    const detailsElement = e.target;
    // Nos aseguramos de que solo reaccione a los acordeones de la página de informes
    if (detailsElement.tagName !== 'DETAILS' || !detailsElement.classList.contains('informe-acordeon')) {
        return;
    }
    
    if (detailsElement.open) {
        const informeId = detailsElement.id.replace('acordeon-', '');
        // Llamamos a nuestra nueva función router, que sabe qué hacer con cada ID
        renderInformeDetallado(informeId);
    }
}, true);
    // ▼▼▼ REEMPLAZA TU BLOQUE 'submit' ENTERO POR ESTE ▼▼▼
    document.body.addEventListener('submit', (e) => {
        e.preventDefault();
        const target = e.target;
        const submitter = e.submitter;
        const handlers = {
            'login-form': () => {
                const action = submitter ? submitter.dataset.action : 'login';
                if (action === 'login') {
                    handleLogin(submitter);
                } else if (action === 'register') {
                    handleRegister(submitter);
                }
            },
            'pin-form': handlePinSubmit,
            'form-movimiento': () => handleSaveMovement(target, submitter),
            'add-concepto-form': () => handleAddConcept(submitter),
            'add-cuenta-form': () => handleAddAccount(submitter),
            
            // --- ¡AQUÍ ESTÁ LA CONEXIÓN QUE FALTABA! ---
            'informe-cuenta-form': () => handleGenerateInformeCuenta(target, submitter),
            // --- FIN DE LA CONEXIÓN ---

            'manage-investment-accounts-form': () => handleSaveInvestmentAccounts(target, submitter),
            'form-valoracion': () => handleSaveValoracion(target, submitter),
            'diario-filters-form': applyDiarioFilters
        };

        if (handlers[target.id]) {
            handlers[target.id]();
        }
    });
// ▲▲▲ FIN DEL BLOQUE DE REEMPLAZO ▲▲▲
    document.body.addEventListener('input', (e) => { const id = e.target.id; if (id) { clearError(id); if (id === 'movimiento-cantidad') validateField('movimiento-cantidad', true); if (id === 'movimiento-descripcion') handleDescriptionInput(); if (id === 'movimiento-concepto' || id === 'movimiento-cuenta') validateField(id, true); if (id === 'movimiento-cuenta-origen' || id === 'movimiento-cuenta-destino') { validateField('movimiento-cuenta-origen', true); validateField('movimiento-cuenta-destino', true); } if (id === 'concepto-search-input') { clearTimeout(globalSearchDebounceTimer); globalSearchDebounceTimer = setTimeout(() => renderConceptosModalList(), 200); } if (id === 'cuenta-search-input') { clearTimeout(globalSearchDebounceTimer); globalSearchDebounceTimer = setTimeout(() => renderCuentasModalList(), 200); } } });
    document.body.addEventListener('blur', (e) => {
    const id = e.target.id;
    if (id) {
        if (id === 'movimiento-cantidad') validateField('movimiento-cantidad');  
        if (id === 'movimiento-concepto' || id === 'movimiento-cuenta') validateField(id);
        }
}, true);
    document.body.addEventListener('focusin', (e) => { if (e.target.matches('.pin-input')) { handlePinInputInteraction(); } if (e.target.id === 'movimiento-descripcion') { handleDescriptionInput(); } });
    document.addEventListener('change', e => {
    const target = e.target;

    if (target.id === 'filter-periodo') {
        const el = select('custom-date-filters');
        if (el) el.classList.toggle('hidden', target.value !== 'custom');
    }
    if (target.id === 'filter-periodo') {
    const customFiltersEl = select('custom-date-filters');
    const applyBtnEl = document.querySelector('[data-action="apply-filters"]');
    const isCustom = target.value === 'custom';

    if (customFiltersEl) customFiltersEl.classList.toggle('hidden', !isCustom);
    if (applyBtnEl) applyBtnEl.classList.toggle('hidden', !isCustom);

    if (!isCustom) {
        hapticFeedback('light');
        scheduleDashboardUpdate();
    }
}
    if (target.id === 'movimiento-recurrente') {
        select('recurrent-options').classList.toggle('hidden', !target.checked);
        if(target.checked && !select('recurrent-next-date').value) {
            select('recurrent-next-date').value = select('movimiento-fecha').value;
        }
    }
    
    if (target.id === 'recurrent-frequency') {
        const endDateGroup = select('recurrent-end-date').closest('.form-group');
        if (endDateGroup) {
            endDateGroup.classList.toggle('hidden', target.value === 'once');
        }
    }
});
    const importFileInput = select('import-file-input'); if (importFileInput) importFileInput.addEventListener('change', (e) => { if(e.target.files) handleJSONFileSelect(e.target.files[0]); });
    const calculatorGrid = select('calculator-grid'); if (calculatorGrid) calculatorGrid.addEventListener('click', (e) => { const btn = e.target.closest('button'); if(btn && btn.dataset.key) handleCalculatorInput(btn.dataset.key); });
    const searchInput = select('global-search-input'); if (searchInput) searchInput.addEventListener('input', () => { clearTimeout(globalSearchDebounceTimer); globalSearchDebounceTimer = setTimeout(() => { performGlobalSearch(searchInput.value); }, 250); });
    document.body.addEventListener('keydown', (e) => { if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); e.stopPropagation(); showGlobalSearchModal(); } });
    const dropZone = select('json-drop-zone'); if (dropZone) { dropZone.addEventListener('click', () => { const el = select('import-file-input'); if (el) el.click() }); dropZone.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.add('drag-over'); }); dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('drag-over'); }); dropZone.addEventListener('drop', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('drag-over'); const files = e.dataTransfer.files; if (files && files.length > 0) handleJSONFileSelect(files); }); }
    const suggestionsBox = select('description-suggestions'); if (suggestionsBox) { suggestionsBox.addEventListener('click', (e) => { const suggestionItem = e.target.closest('.suggestion-item'); if (suggestionItem) { const { description, conceptoId, cuentaId } = suggestionItem.dataset; applyDescriptionSuggestion(description, conceptoId, cuentaId); } }); }
    const fechaDisplayButton = select('movimiento-fecha-display'); const fechaRealInput = select('movimiento-fecha'); if (fechaDisplayButton && fechaRealInput) { fechaDisplayButton.addEventListener('click', () => fechaRealInput.showPicker()); fechaRealInput.addEventListener('input', () => updateDateDisplay(fechaRealInput)); }
    const diarioContainer = select('diario-page');
if (diarioContainer) {
    const mainScroller = selectOne('.app-layout__main');

    diarioContainer.addEventListener('touchstart', (e) => {
        if (mainScroller.scrollTop > 0) return;

        ptrState.startY = e.touches[0].clientY;
        ptrState.isPulling = true;
        
        if (e.target.closest('.transaction-card')) {
            handleInteractionStart(e);
        }
    }, { passive: true });

    diarioContainer.addEventListener('touchmove', (e) => {
        if (!ptrState.isPulling) {
            handleInteractionMove(e);
            return;
        }

        const currentY = e.touches[0].clientY;
        ptrState.distance = currentY - ptrState.startY;

        if (ptrState.distance > 0) {
            e.preventDefault(); 
            
            const indicator = select('pull-to-refresh-indicator');
            if (indicator) {
                indicator.classList.add('visible');
                const rotation = Math.min(ptrState.distance * 2, 360);
                indicator.querySelector('.spinner').style.transform = `rotate(${rotation}deg)`;
            }
        }
    }, { passive: false });

    diarioContainer.addEventListener('touchend', async (e) => {
        const indicator = select('pull-to-refresh-indicator');

        if (ptrState.isPulling && ptrState.distance > ptrState.threshold) {
            hapticFeedback('medium');
            if (indicator) {
                indicator.querySelector('.spinner').style.animation = 'spin 1s linear infinite';
            }

            await loadMoreMovements(true);

            setTimeout(() => {
                if (indicator) {
                    indicator.classList.remove('visible');
                    indicator.querySelector('.spinner').style.animation = '';
                }
            }, 500);

        } else if (indicator) {
            indicator.classList.remove('visible');
        }
        
        ptrState.isPulling = false;
        ptrState.distance = 0;

        handleInteractionEnd(e);
    });

    diarioContainer.addEventListener('mousedown', (e) => e.target.closest('.transaction-card') && handleInteractionStart(e));
    diarioContainer.addEventListener('mousemove', handleInteractionMove);
    diarioContainer.addEventListener('mouseup', handleInteractionEnd);
    diarioContainer.addEventListener('mouseleave', handleInteractionEnd);
}
    const mainScroller = selectOne('.app-layout__main');
    if (mainScroller) {
        let scrollRAF = null;
        mainScroller.addEventListener('scroll', () => {
            if (scrollRAF) window.cancelAnimationFrame(scrollRAF);
            scrollRAF = window.requestAnimationFrame(() => {
                if (diarioViewMode === 'list' && select('diario-page')?.classList.contains('view--active')) {
                    renderVisibleItems();
                }
            });
        }, { passive: true });
    }
    document.body.addEventListener('toggle', (e) => {
    const detailsElement = e.target;
    if (detailsElement.tagName !== 'DETAILS' || !detailsElement.classList.contains('informe-acordeon')) {
        return;
    }
    
    if (detailsElement.open) {
        const id = detailsElement.id;
        const informeId = id.replace('acordeon-', '');
        const container = select(`informe-content-${informeId}`);
        
        if (container && container.querySelector('.form-label')) {
            renderInformeDetallado(informeId);
        }
    }
}, true);
};
// =================================================================
// === FIN: BLOQUE DE CÓDIGO CORREGIDO PARA REEMPLAZAR           ===
// =================================================================

	const handleSetInvestmentChartMode = (mode) => {
    if (investmentChartMode === mode) return; // No hacer nada si ya está en ese modo
    hapticFeedback('light');
    investmentChartMode = mode; // Actualizamos el estado global
    
    // LA SOLUCIÓN:
    // Aplicamos la misma lógica aquí. Forzamos el redibujado en el contenedor correcto.
    renderInversionesView();
};
            
        const showImportJSONWizard = () => {
            jsonWizardState = { file: null, data: null, preview: { counts: {}, meta: {} } };
            goToJSONStep(1);
            const errorEl = select('json-file-error');
            const textEl = select('json-drop-zone-text');
            if(errorEl) errorEl.textContent = '';
            if(textEl) textEl.textContent = 'Arrastra tu archivo aquí o haz clic';
            showModal('json-import-wizard-modal');
        };

        const goToJSONStep = (stepNumber) => {
            selectAll('.json-wizard-step').forEach(step => step.style.display = 'none');
            const targetStep = select(`json-wizard-step-${stepNumber}`);
            if (targetStep) targetStep.style.display = 'flex';
        };

        const handleJSONFileSelect = (file) => {
            const errorEl = select('json-file-error');
            if(!errorEl) return;
            errorEl.textContent = '';

            if (!file.type.includes('json')) {
                errorEl.textContent = 'Error: El archivo debe ser de tipo .json.';
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    let data = JSON.parse(event.target.result);
                    let dataToAnalyze = data;

                    if (data.meta && data.data) {
                        jsonWizardState.preview.meta = data.meta;
                        dataToAnalyze = data.data;
                    } else {
                        jsonWizardState.preview.meta = { appName: 'Cuentas (Formato Antiguo)', exportDate: 'N/A' };
                    }

                    if (!dataToAnalyze.cuentas || !dataToAnalyze.conceptos || !dataToAnalyze.movimientos) {
                        throw new Error("El archivo no tiene la estructura de una copia de seguridad válida.");
                    }

                    jsonWizardState.data = dataToAnalyze;
                    
                    const counts = {};
                    for (const key in dataToAnalyze) {
                        if (Array.isArray(dataToAnalyze[key])) {
                            counts[key] = dataToAnalyze[key].length;
                        }
                    }
                    jsonWizardState.preview.counts = counts;
                    
                    renderJSONPreview();
                    goToJSONStep(2);

                } catch (error) {
                    console.error("Error al procesar el archivo JSON:", error);
                    errorEl.textContent = `Error: ${error.message}`;
                }
            };
            reader.readAsText(file);
        };

        const renderJSONPreview = () => {
            const previewList = select('json-preview-list');
            if(!previewList) return;
            const { counts } = jsonWizardState.preview;
            
            const friendlyNames = {
                cuentas: 'Cuentas', conceptos: 'Conceptos', movimientos: 'Movimientos',
                presupuestos: 'Presupuestos', recurrentes: 'Recurrentes',
                inversiones_historial: 'Historial de Inversión', inversion_cashflows: 'Flujos de Capital'
            };
            
            let html = '';
            for(const key in counts) {
                if(counts[key] > 0) {
                    html += `<li><span class="material-icons">check_circle</span> <strong>${counts[key]}</strong> ${friendlyNames[key] || key}</li>`;
                }
            }
            
            previewList.innerHTML = html || `<li><span class="material-icons">info</span>El archivo parece estar vacío.</li>`;
        };

        const handleFinalJsonImport = async (btn) => {
            goToJSONStep(3);
            setButtonLoading(btn, true, 'Importando...');
            select('json-import-progress').style.display = 'block';
            select('json-import-result').style.display = 'none';

            try {
                const dataToImport = jsonWizardState.data;
                const collectionsToClear = ['cuentas', 'conceptos', 'movimientos', 'presupuestos', 'recurrentes', 'inversiones_historial', 'inversion_cashflows'];

                for (const collectionName of collectionsToClear) {
                    const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection(collectionName).get();
                    if (snapshot.empty) continue;
                    let batch = fbDb.batch();
                    let count = 0;
                    for (const doc of snapshot.docs) {
                        batch.delete(doc.ref);
                        count++;
                        if (count >= 450) { await batch.commit(); batch = fbDb.batch(); count = 0; }
                    }
                    if(count > 0) await batch.commit();
                }
                
                for (const collectionName of Object.keys(dataToImport)) {
                    const items = dataToImport[collectionName];
                    if (Array.isArray(items) && items.length > 0) {
                        let batch = fbDb.batch();
                        let count = 0;
                        for (const item of items) {
                            if (item.id) {
                                const docRef = fbDb.collection('users').doc(currentUser.uid).collection(collectionName).doc(item.id);
                                batch.set(docRef, item);
                                count++;
                                if (count >= 450) { await batch.commit(); batch = fbDb.batch(); count = 0; }
                            }
                        }
                        if(count > 0) await batch.commit();
                    } else if (collectionName === 'config') {
                        await fbDb.collection('users').doc(currentUser.uid).set({ config: items }, { merge: true });
                    }
                }
                
                select('json-import-progress').style.display = 'none';
                select('json-import-result').style.display = 'block';
                select('json-result-message').textContent = `Se han importado los datos correctamente. La aplicación se recargará.`;
                hapticFeedback('success');
                
                setTimeout(() => location.reload(), 4000);

            } catch (error) {
                console.error("Error durante la importación final:", error);
                showToast("Error crítico durante la importación.", "danger", 5000);
                select('json-result-title').textContent = '¡Error en la Importación!';
                select('json-result-message').textContent = `Ocurrió un error. Por favor, revisa la consola e inténtalo de nuevo.`;
                select('json-import-result .material-icons').style.color = 'var(--c-danger)';
                setButtonLoading(btn, false);
            }
        };
const toggleFabMenu = () => {
    const container = document.querySelector('.fab-container');
    if (!container) return;

    hapticFeedback('medium');
    container.classList.toggle('fab-container--active');

    // Cierra el menú si se pulsa el overlay
    const overlay = container.querySelector('.fab-overlay');
    const closeMenu = () => container.classList.remove('fab-container--active');
    overlay.addEventListener('click', closeMenu, { once: true });
};
    
// =================================================================
// === INICIO: NUEVA FUNCIÓN PARA CONFIRMAR MOVIMIENTOS RECURRENTES ===
// =================================================================
const handleConfirmRecurrent = async (id, btn) => {
    if (btn) setButtonLoading(btn, true);

    const recurrenteIndex = db.recurrentes.findIndex(r => r.id === id);
    if (recurrenteIndex === -1) {
        showToast("Error: no se encontró la operación recurrente.", "danger");
        if (btn) setButtonLoading(btn, false);
        return;
    }
    const recurrente = db.recurrentes[recurrenteIndex];

    try {
        const newMovementId = generateId();
        
        // Lógica optimista (actualización local inmediata)
        const newMovementData = {
            id: newMovementId,
            cantidad: recurrente.cantidad,
            descripcion: recurrente.descripcion,
            fecha: new Date().toISOString(), // Se añade con la fecha de hoy
            tipo: recurrente.tipo,
            cuentaId: recurrente.cuentaId,
            conceptoId: recurrente.conceptoId,
            cuentaOrigenId: recurrente.cuentaOrigenId,
            cuentaDestinoId: recurrente.cuentaDestinoId
        };
        
        db.movimientos.unshift(newMovementData);

        // === ¡AQUÍ ESTÁ LA MAGIA! ===
        if (recurrente.frequency === 'once') {
            // Si es de única vez, lo eliminamos de la lista local de recurrentes.
            db.recurrentes.splice(recurrenteIndex, 1);
        } else {
            // Si es periódico, calculamos la siguiente fecha.
            const nextDueDate = calculateNextDueDate(recurrente.nextDate, recurrente.frequency);
            db.recurrentes[recurrenteIndex].nextDate = nextDueDate.toISOString().slice(0, 10);
        }
        
        // Refrescamos la UI al instante
        const activePage = document.querySelector('.view--active');
        if (activePage && activePage.id === PAGE_IDS.DIARIO) {
            updateLocalDataAndRefreshUI();
        } else if (activePage && activePage.id === PAGE_IDS.OTROS) {
			renderOtrosPage();
		}

        // Sincronización en segundo plano con Firebase
        const batch = fbDb.batch();
        const newMovementRef = fbDb.collection('users').doc(currentUser.uid).collection('movimientos').doc(newMovementId);
        batch.set(newMovementRef, newMovementData);
        
        const recurrenteRef = fbDb.collection('users').doc(currentUser.uid).collection('recurrentes').doc(id);

        // === ¡LA MISMA LÓGICA EN FIREBASE! ===
        if (recurrente.frequency === 'once') {
            // Si es de única vez, lo borramos de la base de datos.
            batch.delete(recurrenteRef);
        } else {
            // Si es periódico, actualizamos su próxima fecha.
            const nextDueDate = calculateNextDueDate(recurrente.nextDate, recurrente.frequency);
            batch.update(recurrenteRef, { nextDate: nextDueDate.toISOString().slice(0, 10) });
        }

        // Ajuste de saldos (esto no cambia)
        if (recurrente.tipo === 'traspaso') {
            const origenRef = fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(recurrente.cuentaOrigenId);
            const destinoRef = fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(recurrente.cuentaDestinoId);
            batch.update(origenRef, { saldo: firebase.firestore.FieldValue.increment(-recurrente.cantidad) });
            batch.update(destinoRef, { saldo: firebase.firestore.FieldValue.increment(recurrente.cantidad) });
        } else {
            const cuentaRef = fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(recurrente.cuentaId);
            batch.update(cuentaRef, { saldo: firebase.firestore.FieldValue.increment(recurrente.cantidad) });
        }

        await batch.commit();

        hapticFeedback('success');
        showToast("Movimiento añadido desde recurrente.", "info");

    } catch (error) {
        console.error("Error al confirmar el movimiento recurrente:", error);
        showToast("No se pudo añadir el movimiento recurrente.", "danger");
        // En caso de error, podríamos necesitar recargar los datos para asegurar la consistencia.
    } finally {
        if (btn) setButtonLoading(btn, false);
    }
};

const handleSkipRecurrent = async (id, btn) => {
    if (btn) setButtonLoading(btn, true);

    const recurrente = db.recurrentes.find(r => r.id === id);
    if (!recurrente) {
        showToast("Error: no se encontró la operación recurrente.", "danger");
        if (btn) setButtonLoading(btn, false);
        return;
    }

    try {
        // === ¡LA MISMA MAGIA OTRA VEZ! ===
        if (recurrente.frequency === 'once') {
            // Si es de única vez y lo omitimos, simplemente lo borramos.
            await deleteDoc('recurrentes', id);
            showToast("Operación programada eliminada.", "info");
        } else {
            // Si es periódico, calculamos la siguiente fecha para omitir la actual.
            const nextDueDate = calculateNextDueDate(recurrente.nextDate, recurrente.frequency);
            await saveDoc('recurrentes', id, { nextDate: nextDueDate.toISOString().slice(0, 10) });
            showToast("Operación recurrente omitida esta vez.", "info");
        }

        hapticFeedback('success');

        // La animación de borrado y refresco de UI funciona para ambos casos.
        const itemEl = select(`pending-recurrente-${id}`);
        if (itemEl) {
            itemEl.classList.add('item-deleting');
            itemEl.addEventListener('animationend', () => {
                const activePage = document.querySelector('.view--active');
                if (activePage && activePage.id === PAGE_IDS.DIARIO) {
                    updateVirtualListUI();
                } else if (activePage && activePage.id === PAGE_IDS.OTROS) {
					renderOtrosPage();
				} else {
                    scheduleDashboardUpdate();
                }
            }, { once: true });
        }

    } catch (error) {
        console.error("Error al omitir el movimiento recurrente:", error);
        showToast("No se pudo omitir la operación.", "danger");
    } finally {
        if (btn) setButtonLoading(btn, false);
    }
};

const generateCalendarGrid = (date, dataMap) => {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    
    const firstDayOffset = (new Date(Date.UTC(year, month, 1)).getUTCDay() + 6) % 7;
    
    // --- INICIO DE LA CORRECCIÓN ---
    // Obtenemos el número de días del mes de forma segura en UTC.
    const daysInMonth = new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    // --- FIN DE LA CORRECCIÓN ---

    const today = new Date();
    today.setUTCHours(0, 0, 0, 0);

    const monthName = date.toLocaleDateString('es-ES', { month: 'long', year: 'numeric', timeZone: 'UTC' });
    
    let gridHtml = `<div class="calendar-header">
        <button class="icon-btn" data-action="calendar-nav" data-direction="prev"><span class="material-icons">chevron_left</span></button>
        <h3 class="calendar-header__title">${monthName}</h3>
        <button class="icon-btn" data-action="calendar-nav" data-direction="next"><span class="material-icons">chevron_right</span></button>
    </div>`;

    gridHtml += '<div class="calendar-grid">';
    const weekdays = ['L', 'M', 'X', 'J', 'V', 'S', 'D'];
    weekdays.forEach(day => gridHtml += `<div class="calendar-weekday">${day}</div>`);

    let dayOfMonth = 1;
    for (let i = 0; i < 42; i++) {
        // La condición del bucle se mantiene, ya que con el `daysInMonth` corregido, debería funcionar.
        if (i < firstDayOffset || dayOfMonth > daysInMonth) {
            gridHtml += `<div class="calendar-day empty"></div>`;
        } else {
            const currentDate = new Date(Date.UTC(year, month, dayOfMonth));
            const dateKey = currentDate.toISOString().slice(0, 10);
            const dayData = dataMap.get(dateKey);
            
            let classes = 'calendar-day';
            if (currentDate.getTime() === today.getTime()) {
                classes += ' is-today';
            }

            gridHtml += `<div class="${classes}" data-action="show-day-details" data-date="${dateKey}">
                <span class="calendar-day__number">${dayOfMonth}</span>`;

            if (dayData) {
                if (dayData.total !== undefined) {
                    const totalClass = dayData.total >= 0 ? 'text-positive' : 'text-negative';
                    if (Math.abs(dayData.total) > 0) {
                        gridHtml += `<span class="calendar-day__total ${totalClass}">${formatCurrency(dayData.total)}</span>`;
                    }
                }
                if (dayData.markers) {
                    gridHtml += `<div class="calendar-day__markers">`;
                    if(dayData.markers.has('income')) gridHtml += `<div class="calendar-day__marker marker--income"></div>`;
                    if(dayData.markers.has('expense')) gridHtml += `<div class="calendar-day__marker marker--expense"></div>`;
                    gridHtml += `</div>`;
                }
            }
            
            gridHtml += `</div>`;
            dayOfMonth++;
        }
    }
    gridHtml += '</div>';
    return gridHtml;
};
// Reemplaza esta función completa:
const renderDiarioCalendar = async () => {
    const container = select('diario-view-container');
    if (!container) return;
    
    container.innerHTML = `<div class="calendar-container skeleton" style="height: 400px;"></div>`;

    try {
        // Aseguramos que diarioCalendarDate siempre sea un objeto Date válido
        if (!(diarioCalendarDate instanceof Date) || isNaN(diarioCalendarDate)) {
            diarioCalendarDate = new Date();
        }
        // Forzamos la fecha a mediodía para evitar problemas de zona horaria en los cálculos
        diarioCalendarDate.setHours(12, 0, 0, 0);

        const year = diarioCalendarDate.getFullYear();
        const month = diarioCalendarDate.getMonth();
        
        const startDate = new Date(Date.UTC(year, month, 1));
        const endDate = new Date(Date.UTC(year, month + 1, 1)); // El primer instante del siguiente mes
        
        const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection('movimientos')
            .where('fecha', '>=', startDate.toISOString())
            .where('fecha', '<', endDate.toISOString())
            .get();

        const movementsOfMonth = snapshot.docs.map(doc => doc.data());
        
        const dataMap = new Map();
        movementsOfMonth.forEach(m => {
            const dateKey = m.fecha.slice(0, 10);
            if (!dataMap.has(dateKey)) dataMap.set(dateKey, { total: 0, markers: new Set() });
            
            let amount = 0;
            const visibleAccountIds = new Set(getVisibleAccounts().map(c => c.id));

            if (m.tipo === 'traspaso') {
                if (visibleAccountIds.has(m.cuentaOrigenId) && !visibleAccountIds.has(m.cuentaDestinoId)) amount = -m.cantidad;
                else if (!visibleAccountIds.has(m.cuentaOrigenId) && visibleAccountIds.has(m.cuentaDestinoId)) amount = m.cantidad;
            } else {
                if (visibleAccountIds.has(m.cuentaId)) amount = m.cantidad;
            }

            if (amount !== 0) {
                 dataMap.get(dateKey).total += amount;
                 if (amount > 0) dataMap.get(dateKey).markers.add('income');
                 if (amount < 0) dataMap.get(dateKey).markers.add('expense');
            }
        });
        
        container.innerHTML = `<div class="calendar-container" data-context="diario">${generateCalendarGrid(diarioCalendarDate, dataMap)}</div>`;
    } catch(error) {
        console.error("Error fetching calendar data:", error);
        container.innerHTML = `<div class="empty-state"><p class="text-danger">No se pudieron cargar los datos del calendario.</p></div>`;
    }
};


const applyOptimisticBalanceUpdate = (newData, oldData = null) => {
    // Revertir el impacto del movimiento antiguo si estamos editando
    if (oldData) {
        if (oldData.tipo === 'traspaso') {
            const origen = db.cuentas.find(c => c.id === oldData.cuentaOrigenId);
            if (origen) origen.saldo += oldData.cantidad;
            const destino = db.cuentas.find(c => c.id === oldData.cuentaDestinoId);
            if (destino) destino.saldo -= oldData.cantidad;
        } else {
            const cuenta = db.cuentas.find(c => c.id === oldData.cuentaId);
            if (cuenta) cuenta.saldo -= oldData.cantidad;
        }
    }

    // Aplicar el impacto del nuevo movimiento
    if (newData.tipo === 'traspaso') {
        const origen = db.cuentas.find(c => c.id === newData.cuentaOrigenId);
        if (origen) origen.saldo -= newData.cantidad;
        const destino = db.cuentas.find(c => c.id === newData.cuentaDestinoId);
        if (destino) destino.saldo += newData.cantidad;
    } else {
        const cuenta = db.cuentas.find(c => c.id === newData.cuentaId);
        if (cuenta) cuenta.saldo += newData.cantidad;
    }
};

const handleSaveMovement = async (form, btn) => {
    clearAllErrors(form.id);
    if (!validateMovementForm()) {
        hapticFeedback('error');
        showToast('Por favor, revisa los campos marcados en rojo.', 'warning');
        return false;
    }

    const isSaveAndNew = btn && btn.dataset.action === 'save-and-new-movement';
    setButtonLoading(btn, true);

    const isRecurrent = select('movimiento-recurrente').checked;

    if (isRecurrent) {
        // La lógica para recurrentes no ha cambiado y sigue siendo correcta.
        try {
            const id = select('movimiento-id').value || generateId();
            
            // Lógica para determinar la cantidad en recurrentes
            const cantidadPositiva = parseCurrencyString(select('movimiento-cantidad').value);
            let cantidadRecurrente = Math.round(cantidadPositiva * 100);
            const tipoRecurrente = document.querySelector('[data-action="set-movimiento-type"].filter-pill--active').dataset.type;

            if (tipoRecurrente === 'gasto') {
                 cantidadRecurrente = -Math.abs(cantidadRecurrente);
            } else {
                 cantidadRecurrente = Math.abs(cantidadRecurrente);
            }
            
            const dataToSave = {
                id: id,
                cantidad: tipoRecurrente === 'traspaso' ? Math.abs(cantidadRecurrente) : cantidadRecurrente,
                descripcion: select('movimiento-descripcion').value.trim(),
                tipo: tipoRecurrente === 'traspaso' ? 'traspaso' : 'movimiento',
                cuentaId: select('movimiento-cuenta').value,
                conceptoId: select('movimiento-concepto').value,
                cuentaOrigenId: select('movimiento-cuenta-origen').value,
                cuentaDestinoId: select('movimiento-cuenta-destino').value,
                frequency: select('recurrent-frequency').value,
                nextDate: select('recurrent-next-date').value,
                endDate: select('recurrent-end-date').value || null
            };

            await saveDoc('recurrentes', id, dataToSave);

            setButtonLoading(btn, false);
            hapticFeedback('success');
			triggerSaveAnimation(btn, dataToSave.cantidad >= 0 ? 'green' : 'red');
            if (!isSaveAndNew) {
                hideModal('movimiento-modal');
                showToast(select('movimiento-mode').value === 'new' ? 'Operación programada.' : 'Operación actualizada.');
            } else {
                form.reset();
                setMovimientoFormType('gasto'); // Volver a Gasto por defecto
                showToast('Operación programada, puedes añadir otra.', 'info');
                select('movimiento-cantidad').focus();
            }

            const activePage = document.querySelector('.view--active');
            if (activePage && activePage.id === PAGE_IDS.PLANIFICACION) {
                renderPlanificacionPage();
            }
            return true;

        } catch (error) {
            console.error("Error al guardar la operación recurrente:", error);
            showToast("No se pudo guardar la operación recurrente.", "danger");
            setButtonLoading(btn, false);
            return false;
        }

    } 
	else {
    // --- ✅ LÓGICA CORREGIDA PARA MOVIMIENTOS NORMALES (NO RECURRENTES) ---
    
    const mode = select('movimiento-mode').value;
    const movementId = select('movimiento-id').value;

    // --- ✅ INICIO DE LA CORRECCIÓN ---
    // Usamos el mismo método robusto para obtener el tipo de movimiento
    const selectedType = document.querySelector('[data-action="set-movimiento-type"].filter-pill--active').dataset.type;
    // --- ✅ FIN DE LA CORRECCIÓN ---
    
    const cantidadPositiva = parseCurrencyString(select('movimiento-cantidad').value);
    let cantidadFinal = Math.round(Math.abs(cantidadPositiva) * 100);

    if (selectedType === 'gasto') {
        cantidadFinal = -cantidadFinal;
    } else {
        // Para 'ingreso' y 'traspaso', la cantidad es positiva
        cantidadFinal = Math.abs(cantidadFinal);
    }

    const dataFromForm = {
        id: movementId || generateId(),
        cantidad: cantidadFinal,
        tipo: selectedType === 'traspaso' ? 'traspaso' : 'movimiento',
        descripcion: (() => {
    const descInput = select('movimiento-descripcion').value.trim();
    if (selectedType === 'traspaso' && descInput === '') {
        const origen = select('movimiento-cuenta-origen');
        const destino = select('movimiento-cuenta-destino');
        const nombreOrigen = origen.options[origen.selectedIndex]?.text || '?';
        const nombreDestino = destino.options[destino.selectedIndex]?.text || '?';
        return `Traspaso de ${nombreOrigen} a ${nombreDestino}`;
    }
    return descInput;
})(),
        fecha: parseDateStringAsUTC(select('movimiento-fecha').value).toISOString(),
        cuentaId: select('movimiento-cuenta').value,
        conceptoId: select('movimiento-concepto').value,
        cuentaOrigenId: select('movimiento-cuenta-origen').value,
        cuentaDestinoId: select('movimiento-cuenta-destino').value,
    };

    try {
        let oldMovementData = null;
        if (mode.startsWith('edit')) {
            oldMovementData = db.movimientos.find(m => m.id === dataFromForm.id) || null;
        }
        
        applyOptimisticBalanceUpdate(dataFromForm, oldMovementData);

        if (mode.startsWith('edit')) {
            const index = db.movimientos.findIndex(m => m.id === dataFromForm.id);
            if (index !== -1) db.movimientos[index] = dataFromForm;
        } else {
            db.movimientos.unshift(dataFromForm);
            newMovementIdToHighlight = dataFromForm.id;
        }
        db.movimientos.sort((a, b) => new Date(b.fecha) - new Date(a.fecha) || b.id.localeCompare(a.id));

        updateLocalDataAndRefreshUI();
        
        const activePage = document.querySelector('.view--active');
        if (activePage && activePage.id === PAGE_IDS.DIARIO) {
            const mainScroller = document.querySelector('.app-layout__main');
            if (mainScroller) mainScroller.scrollTo({ top: 0, behavior: 'smooth' });
        }

        await fbDb.runTransaction(async (transaction) => {
            let oldDataForTx = null;
            if (mode.startsWith('edit')) {
                const oldDocRef = fbDb.collection('users').doc(currentUser.uid).collection('movimientos').doc(movementId);
                const oldDoc = await transaction.get(oldDocRef);
                if (oldDoc.exists) oldDataForTx = oldDoc.data();
            }
            if (oldDataForTx) {
                if (oldDataForTx.tipo === 'traspaso') {
                    transaction.update(fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(oldDataForTx.cuentaOrigenId), { saldo: firebase.firestore.FieldValue.increment(oldDataForTx.cantidad) });
                    transaction.update(fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(oldDataForTx.cuentaDestinoId), { saldo: firebase.firestore.FieldValue.increment(-oldDataForTx.cantidad) });
                } else {
                    transaction.update(fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(oldDataForTx.cuentaId), { saldo: firebase.firestore.FieldValue.increment(-oldDataForTx.cantidad) });
                }
            }
            if (dataFromForm.tipo === 'traspaso') {
                transaction.update(fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(dataFromForm.cuentaOrigenId), { saldo: firebase.firestore.FieldValue.increment(-dataFromForm.cantidad) });
                transaction.update(fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(dataFromForm.cuentaDestinoId), { saldo: firebase.firestore.FieldValue.increment(dataFromForm.cantidad) });
            } else {
                transaction.update(fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(dataFromForm.cuentaId), { saldo: firebase.firestore.FieldValue.increment(dataFromForm.cantidad) });
            }
            const movRef = fbDb.collection('users').doc(currentUser.uid).collection('movimientos').doc(dataFromForm.id);
            transaction.set(movRef, dataFromForm);
        });
        
        setButtonLoading(btn, false);
        hapticFeedback('success');
        triggerSaveAnimation(btn, dataFromForm.cantidad >= 0 ? 'green' : 'red');

        if (!isSaveAndNew) {
            setTimeout(() => hideModal('movimiento-modal'), 200);
            showToast(mode === 'new' ? 'Movimiento guardado.' : 'Movimiento actualizado.');
        } else {
            form.reset();
            setMovimientoFormType('gasto');
            const today = new Date();
            const fechaInput = select('movimiento-fecha');
            fechaInput.value = new Date(today.getTime() - (today.getTimezoneOffset() * 60000)).toISOString().slice(0, 10);
            updateDateDisplay(fechaInput);
            select('movimiento-cantidad').focus();
        }
        return true;

    } catch (error) {
        console.error("Error al guardar el movimiento:", error);
        showToast("Error crítico al guardar. La operación fue cancelada.", "danger");
        setButtonLoading(btn, false);
        if (select('diario-page')?.classList.contains('view--active')) {
             await renderDiarioPage();
        }
        return false;
    }
}
};

/**

Prepara el formulario para duplicar un movimiento existente.

@param {object} movementToDuplicate - El objeto del movimiento que se va a copiar.
*/
const handleDuplicateMovement = (movementToDuplicate) => {
if (!movementToDuplicate) return;

hapticFeedback('medium');

// 1. Abrimos el formulario de edición con los datos del movimiento original.
// Esto rellena todos los campos por nosotros (cantidad, descripción, etc.).
startMovementForm(movementToDuplicate.id, false);

// 2. Usamos un pequeño retardo para asegurarnos de que el formulario ya está visible
// antes de modificarlo para que actúe como "Nuevo" en lugar de "Editar".
setTimeout(() => {
// 3. Modificamos el estado del formulario para que sepa que vamos a crear
// un movimiento NUEVO, no a actualizar el antiguo.
select('movimiento-mode').value = 'new';
select('movimiento-id').value = ''; // Borramos el ID antiguo, ¡muy importante!
select('form-movimiento-title').textContent = 'Duplicar Movimiento';


// 4. Ocultamos los botones que no tienen sentido aquí (borrar y duplicar de nuevo).
 select('delete-movimiento-btn').classList.add('hidden');
 select('duplicate-movimiento-btn').classList.add('hidden');
 
 // 5. Ponemos la fecha de hoy por defecto, que es lo más común al duplicar.
 const today = new Date();
 const fechaInput = select('movimiento-fecha');
 fechaInput.value = new Date(today.getTime() - (today.getTimezoneOffset() * 60000)).toISOString().slice(0, 10);
 updateDateDisplay(fechaInput); // Actualizamos el texto "Hoy"

 showToast('Datos duplicados. Ajusta y guarda.', 'info');

}, 50); // 50 milisegundos es suficiente.
};


const handleAddConcept = async (btn) => { 
     const nombre = toSentenceCase((select('new-concepto-nombre')).value.trim());
     if (!nombre) { showToast('El nombre es obligatorio.', 'warning'); return; } 
     const newId = generateId();
     await saveDoc('conceptos', newId, { id: newId, nombre, icon: 'label' }, btn);
     hapticFeedback('success'); 
     showToast('Concepto añadido.');
     (select('add-concepto-form')).reset(); 
 };
 const handleAddAccount = async (btn) => { 
     const nombre = (select('new-cuenta-nombre')).value.trim(); 
     const tipo = toSentenceCase((select('new-cuenta-tipo')).value.trim()); 
     if (!nombre || !tipo) { showToast('El nombre y el tipo son obligatorios.', 'warning'); return; } 
     const newId = generateId();
     await saveDoc('cuentas', newId, { id: newId, nombre, tipo, saldo: 0, esInversion: false, offBalance: isOffBalanceMode, fechaCreacion: new Date().toISOString() }, btn);
     hapticFeedback('success'); 
     showToast('Cuenta añadida.');
     (select('add-cuenta-form')).reset();
 };
 const handleSaveConfig = async (btn) => { 
     setButtonLoading(btn, true);
     const newConfig = { dashboardWidgets: (db.config && db.config.dashboardWidgets) || DEFAULT_DASHBOARD_WIDGETS };
     await fbDb.collection('users').doc(currentUser.uid).set({ config: newConfig }, { merge: true });
     localStorage.setItem('skipIntro', String(newConfig.skipIntro));
     setButtonLoading(btn, false);
     hapticFeedback('success'); showToast('Configuración guardada.'); 
 };
 

          const handleExportData = async (btn) => {
     if (!currentUser) { showToast("No hay usuario autenticado.", "danger"); return; }
     setButtonLoading(btn, true, 'Exportando...');
     try {
         const dataPayload = {};
         const collections = ['cuentas', 'conceptos', 'movimientos', 'presupuestos', 'recurrentes', 'inversiones_historial', 'inversion_cashflows'];
         
         for (const collectionName of collections) {
             const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection(collectionName).get();
             dataPayload[collectionName] = snapshot.docs.map(doc => doc.data());
         }
         dataPayload.config = db.config;

         const exportObject = {
             meta: {
                 appName: "Cuentas aiDANaI",
                 version: "2.0.0",
                 exportDate: new Date().toISOString()
             },
             data: dataPayload
         };
         
         const jsonString = JSON.stringify(exportObject, null, 2);
         const blob = new Blob([jsonString], { type: 'application/json' });
         const url = URL.createObjectURL(blob);
         const a = document.createElement('a');
         a.href = url;
         a.download = `cuentas_aidanai_backup_${new Date().toISOString().slice(0,10)}.json`;
         document.body.appendChild(a);
         a.click();
         document.body.removeChild(a);
         URL.revokeObjectURL(url);
         showToast("Exportación JSON completada.", "info");
     } catch (error) {
         console.error("Error al exportar datos:", error);
         showToast("Error durante la exportación.", "danger");
     } finally {
         setButtonLoading(btn, false);
     }
 };
 const formatDateForCsv = (isoDateString) => {
     if (!isoDateString) return '';
     const date = new Date(isoDateString);
     const day = String(date.getUTCDate()).padStart(2, '0');
     const month = String(date.getUTCMonth() + 1).padStart(2, '0');
     const year = date.getUTCFullYear();
     return `${day}/${month}/${year}`;
 };

 const handleExportCsv = async (btn) => {
     if (!currentUser) { showToast("No hay usuario autenticado.", "danger"); return; }
     setButtonLoading(btn, true, 'Exportando...');
     
     try {
         const allMovements = await fetchAllMovementsForSearch();
         const allCuentas = db.cuentas;
         const allConceptos = db.conceptos;

         const cuentasMap = new Map(allCuentas.map(c => [c.id, c]));
         const conceptosMap = new Map(allConceptos.map(c => [c.id, c]));

         let csvRows = [];
         const csvHeader = ['FECHA', 'CUENTA', 'CONCEPTO', 'IMPORTE', 'DESCRIPCIÓN'];
         csvRows.push(csvHeader.join(';'));
         
         for (const cuenta of allCuentas) {
             const movementsOfAccount = allMovements.filter(m => {
                 return (m.tipo === 'movimiento' && m.cuentaId === cuenta.id) ||
                        (m.tipo === 'traspaso' && m.cuentaOrigenId === cuenta.id) ||
                        (m.tipo === 'traspaso' && m.cuentaDestinoId === cuenta.id);
             });

             const balanceChange = movementsOfAccount.reduce((sum, m) => {
                 if (m.tipo === 'movimiento') return sum + m.cantidad;
                 if (m.tipo === 'traspaso' && m.cuentaOrigenId === cuenta.id) return sum - m.cantidad;
                 if (m.tipo === 'traspaso' && m.cuentaDestinoId === cuenta.id) return sum + m.cantidad;
                 return sum;
             }, 0);
             
             const initialBalance = (cuenta.saldo || 0) - balanceChange;
             
             if (initialBalance !== 0) {
                 const cuentaNombre = `${cuenta.offBalance ? 'N-' : ''}${cuenta.nombre}`;
                 const importeStr = (initialBalance / 100).toLocaleString('es-ES', { useGrouping: false, minimumFractionDigits: 2 });
                 const fechaCreacion = cuenta.fechaCreacion ? formatDateForCsv(cuenta.fechaCreacion) : '01/01/2025';

                 csvRows.push([fechaCreacion, `"${cuentaNombre}"`, 'INICIAL', importeStr, '"Saldo Inicial"'].join(';'));
             }
         }
         
         const sortedMovements = allMovements.sort((a, b) => new Date(a.fecha) - new Date(b.fecha));

         for (const mov of sortedMovements) {
             const fecha = formatDateForCsv(mov.fecha);
             const descripcion = `"${mov.descripcion.replace(/"/g, '""')}"`;
             const importeStr = (mov.cantidad / 100).toLocaleString('es-ES', { useGrouping: false, minimumFractionDigits: 2 });

             if (mov.tipo === 'traspaso') {
                 const cuentaOrigen = cuentasMap.get(mov.cuentaOrigenId);
                 const cuentaDestino = cuentasMap.get(mov.cuentaDestinoId);
                 
                 if (cuentaOrigen && cuentaDestino) {
                     const nombreOrigen = `${cuentaOrigen.offBalance ? 'N-' : ''}${cuentaOrigen.nombre}`;
                     const nombreDestino = `${cuentaDestino.offBalance ? 'N-' : ''}${cuentaDestino.nombre}`;
                     const importeNegativo = (-mov.cantidad / 100).toLocaleString('es-ES', { useGrouping: false, minimumFractionDigits: 2 });
                     
                     csvRows.push([fecha, `"${nombreOrigen}"`, 'TRASPASO', importeNegativo, descripcion].join(';'));
                     csvRows.push([fecha, `"${nombreDestino}"`, 'TRASPASO', importeStr, descripcion].join(';'));
                 }
             } else {
                 const cuenta = cuentasMap.get(mov.cuentaId);
                 const concepto = conceptosMap.get(mov.conceptoId);

                 if (cuenta && concepto && concepto.nombre !== 'Saldo Inicial') {
                     const nombreCuenta = `${cuenta.offBalance ? 'N-' : ''}${cuenta.nombre}`;
                     csvRows.push([fecha, `"${nombreCuenta}"`, `"${concepto.nombre}"`, importeStr, descripcion].join(';'));
                 }
             }
         }

         const csvString = csvRows.join('\r\n');
         const blob = new Blob([`\uFEFF${csvString}`], { type: 'text/csv;charset=utf-8;' });
         const url = URL.createObjectURL(blob);
         const a = document.createElement('a');
         a.href = url;
         a.download = `cuentas_aidanai_export_${new Date().toISOString().slice(0,10)}.csv`;
         document.body.appendChild(a);
         a.click();
         document.body.removeChild(a);
         URL.revokeObjectURL(url);
         showToast("Exportación CSV completada.", "info");
         
     } catch (error) {
         console.error("Error al exportar datos a CSV:", error);
         showToast("Error durante la exportación a CSV.", "danger");
     } finally {
         setButtonLoading(btn, false);
     }
 };
 const csv_parseDate = (dateString) => {
     if (!dateString) return null;
     const parts = dateString.split('/');
     if (parts.length !== 3) return null;
     const day = parseInt(parts[0], 10);
	 const month = parseInt(parts[1], 10) - 1;
	 const year = parseInt(parts[2], 10);
     if (isNaN(day) || isNaN(month) || isNaN(year) || year < 1970) return null;
     return new Date(Date.UTC(year, month, day, 12, 0, 0));
 };

 const csv_parseCurrency = (currencyString) => {
     if (typeof currencyString !== 'string' || !currencyString) return 0;
     const number = parseFloat(
         currencyString
         .replace('€', '')
         .trim()
         .replace(/\./g, '')
         .replace(',', '.')
     );
     return isNaN(number) ? 0 : Math.round(number * 100);
 };

 const csv_inferType = (name) => {
     const upperName = name.toUpperCase();
     if (upperName.includes('TARJETA')) return { tipo: 'Tarjeta', esInversion: false };
     if (upperName.includes('EFECTIVO')) return { tipo: 'Efectivo', esInversion: false };
     if (upperName.includes('PENSIÓN')) return { tipo: 'Pensión', esInversion: true };
     if (upperName.includes('LETRAS')) return { tipo: 'Renta Fija', esInversion: true };
     if (['FONDO', 'FONDOS'].some(t => upperName.includes(t))) return { tipo: 'Fondos', esInversion: true };
     if (['TRADEREPUBLIC', 'MYINVESTOR', 'DEGIRO', 'INTERACTIVEBROKERS', 'INDEXACAPITAL', 'COINBASE', 'CRIPTAN', 'KRAKEN', 'BIT2ME', 'N26', 'FREEDOM24', 'DEBLOCK', 'BBVA', 'CIVISLEND', 'HOUSERS', 'URBANITAE', 'MINTOS', 'HAUSERA'].some(b => upperName.includes(b))) return { tipo: 'Broker', esInversion: true };
     if (upperName.includes('NARANJA') || upperName.includes('AHORRO')) return { tipo: 'Ahorro', esInversion: false };
     return { tipo: 'Banco', esInversion: false };
 };

  const csv_processFile = (file) => {
     return new Promise((resolve, reject) => {
         const reader = new FileReader();
         reader.onload = (event) => {
             try {
                 const csvData = event.target.result.replace(/^\uFEFF/, '');
                 const lines = csvData.split(/\r?\n/).filter(line => line.trim() !== '' && line.includes(';'));
                 if (lines.length <= 1) {
                     showToast("El archivo CSV está vacío o solo contiene la cabecera.", "warning");
                     return resolve(null);
                 }
                 
                 lines.shift(); // Eliminar la cabecera

                 let rowCount = 0, initialCount = 0;
                 const cuentasMap = new Map();
                 const conceptosMap = new Map();
                 const movimientos = [];
                 const potentialTransfers = [];
                 
                 for (const line of lines) {
                     rowCount++;
                     const columns = line.split(';').map(c => c.trim().replace(/"/g, ''));
                     const [fechaStr, cuentaStr, conceptoStr, importeStr, descripcion = ''] = columns;

                     if (!fechaStr || !cuentaStr || !conceptoStr || !importeStr) {
                         console.warn(`Línea inválida o incompleta #${rowCount + 1}. Saltando...`, line);
                         continue;
                     }
                     
                     const fecha = csv_parseDate(fechaStr);
                     if (!fecha) {
                          console.warn(`Fecha inválida en la fila ${rowCount + 1}: ${fechaStr}`);
                          continue;
                     }

                     const conceptoLimpio = conceptoStr.trim().toUpperCase().replace(/\s*;-$/, '');
                     const offBalance = cuentaStr.startsWith('N-');
                     const nombreCuentaLimpio = cuentaStr.replace(/^(D-|N-)/, '');
                     const cantidad = csv_parseCurrency(importeStr);

                     if (!cuentasMap.has(nombreCuentaLimpio)) {
                         const { tipo, esInversion } = csv_inferType(nombreCuentaLimpio);
                         cuentasMap.set(nombreCuentaLimpio, { id: generateId(), nombre: nombreCuentaLimpio, tipo, saldo: 0, esInversion, offBalance, fechaCreacion: new Date(Date.UTC(2025, 0, 1)).toISOString() });
                     }

                     if (conceptoLimpio === 'INICIAL') {
                         initialCount++;
                         if (!conceptosMap.has('SALDO INICIAL')) conceptosMap.set('SALDO INICIAL', { id: generateId(), nombre: 'Saldo Inicial', icon: 'account_balance' });
                         const conceptoInicial = conceptosMap.get('SALDO INICIAL');
                         movimientos.push({ id: generateId(), fecha: fecha.toISOString(), cantidad, descripcion: descripcion || 'Existencia Inicial', tipo: 'movimiento', cuentaId: cuentasMap.get(nombreCuentaLimpio).id, conceptoId: conceptoInicial ? conceptoInicial.id : null });
                         continue;
                     }

                     if (conceptoLimpio && conceptoLimpio !== 'TRASPASO' && !conceptosMap.has(conceptoLimpio)) {
                         conceptosMap.set(conceptoLimpio, { id: generateId(), nombre: toSentenceCase(conceptoLimpio), icon: 'label' });
                     }
                     
                     if (conceptoLimpio === 'TRASPASO') {
                         // CAMBIO CLAVE: Incluimos la descripción en el objeto que guardamos para su posterior análisis.
                         potentialTransfers.push({ fecha, nombreCuenta: nombreCuentaLimpio, cantidad, descripcion, originalRow: rowCount });
                     } else {
                         const conceptoActual = conceptosMap.get(conceptoLimpio);
                         movimientos.push({ id: generateId(), fecha: fecha.toISOString(), cantidad, descripcion, tipo: 'movimiento', cuentaId: cuentasMap.get(nombreCuentaLimpio).id, conceptoId: conceptoActual ? conceptoActual.id : null });
                     }
                 }

                 let matchedTransfersCount = 0;
                 let unmatchedTransfers = [];
                 const transferGroups = new Map();
                 
                 potentialTransfers.forEach(t => {
                     // CAMBIO CLAVE: La nueva "llave" para agrupar ahora incluye la descripción.
                     // Esto asegura que solo traspasos con misma fecha, importe Y descripción se agrupen.
                     const key = `${t.fecha.getTime()}_${Math.abs(t.cantidad)}_${t.descripcion}`;
                     if (!transferGroups.has(key)) transferGroups.set(key, []);
                     transferGroups.get(key).push(t);
                 });

                 transferGroups.forEach((group) => {
                     const gastos = group.filter(t => t.cantidad < 0);
                     const ingresos = group.filter(t => t.cantidad > 0);
                     
                     // Este bucle ahora opera sobre un grupo mucho más específico y fiable.
                     while (gastos.length > 0 && ingresos.length > 0) {
                         const Gasto = gastos.pop();
                         const Ingreso = ingresos.pop();
                         movimientos.push({ id: generateId(), fecha: Gasto.fecha.toISOString(), cantidad: Math.abs(Gasto.cantidad), descripcion: Gasto.descripcion || Ingreso.descripcion || 'Traspaso', tipo: 'traspaso', cuentaOrigenId: cuentasMap.get(Gasto.nombreCuenta).id, cuentaDestinoId: cuentasMap.get(Ingreso.nombreCuenta).id });
                         matchedTransfersCount++;
                     }
                     // Los que no se emparejan se añaden a la lista de "sin pareja".
                     unmatchedTransfers.push(...gastos, ...ingresos);
                 });
                 
                 const conceptoInicialId = conceptosMap.has('SALDO INICIAL') ? conceptosMap.get('SALDO INICIAL').id : null;
                 const finalData = { cuentas: Array.from(cuentasMap.values()), conceptos: Array.from(conceptosMap.values()), movimientos, presupuestos: [], recurrentes: [], inversiones_historial: [], inversion_cashflows: [], config: getInitialDb().config };
                 const totalMovements = movimientos.filter(m => m.tipo === 'movimiento' && m.conceptoId !== conceptoInicialId).length;

                 resolve({
                     jsonData: finalData,
                     stats: { rowCount, accounts: cuentasMap.size, concepts: conceptosMap.size, movements: totalMovements, transfers: matchedTransfersCount, initials: initialCount, unmatched: unmatchedTransfers.length }
                 });

             } catch (error) {
                 reject(error);
             }
         };
         reader.onerror = () => reject(new Error("No se pudo leer el archivo."));
         reader.readAsText(file, 'UTF-8');
     });
 };

 const showCsvImportWizard = () => {
     const wizardHTML = `
     <div id="csv-wizard-content">
         <div id="csv-wizard-step-1" class="json-wizard-step">
             <h4>Paso 1: Selecciona tu archivo CSV</h4>
             <p class="form-label" style="margin-bottom: var(--sp-3);">
                 Columnas requeridas: <code>FECHA;CUENTA;CONCEPTO;IMPORTE;DESCRIPCIÓN</code>.
                 <br><strong>Atención:</strong> La importación reemplazará <strong>todos</strong> tus datos actuales.
             </p>
             <div id="csv-drop-zone" class="upload-area">
                 <p>Arrastra tu archivo <code>.csv</code> aquí o <strong>haz clic para seleccionarlo</strong>.</p>
                 <span id="csv-file-name" class="file-name" style="color: var(--c-success); font-weight: 600; margin-top: 1rem; display: block;"></span>
             </div>
             <div id="csv-file-error" class="form-error" style="text-align: center; margin-top: var(--sp-3);"></div>
             <div class="modal__actions">
                 <button id="csv-process-btn" class="btn btn--primary btn--full" disabled>Analizar Archivo</button>
             </div>
         </div>

         <div id="csv-wizard-step-2" class="json-wizard-step" style="display: none;">
             <h4>Paso 2: Revisa y confirma</h4>
             <p class="form-label" style="margin-bottom: var(--sp-3);">Hemos analizado tu archivo. Si los datos son correctos, pulsa "Importar" para reemplazar tus datos actuales.</p>
             <div class="results-log" style="display: block; margin-top: 0;">
                 <h2>Resultados del Análisis</h2>
                 <ul id="csv-preview-list"></ul>
             </div>
             <div class="form-error" style="margin-top: var(--sp-2); text-align: center;"><strong>Atención:</strong> Esta acción es irreversible.</div>
             <div class="modal__actions" style="justify-content: space-between;">
                 <button id="csv-wizard-back-btn" class="btn btn--secondary">Atrás</button>
                 <button id="csv-wizard-import-final" class="btn btn--danger"><span class="material-icons">warning</span>Importar y Reemplazar</button>
             </div>
         </div>

         <div id="csv-wizard-step-3" class="json-wizard-step" style="display: none; justify-content: center; align-items: center; text-align: center; min-height: 250px;">
             <div id="csv-import-progress">
                 <span class="spinner" style="width: 48px; height: 48px; border-width: 4px;"></span>
                 <h4 style="margin-top: var(--sp-4);">Importando...</h4>
                 <p>Borrando datos antiguos e importando los nuevos. Por favor, no cierres esta ventana.</p>
             </div>
              <div id="csv-import-result" style="display: none;">
                 <span class="material-icons" style="font-size: 60px; color: var(--c-success);">task_alt</span>
                 <h4 id="csv-result-title" style="margin-top: var(--sp-2);"></h4>
                 <p id="csv-result-message"></p>
                 <div class="modal__actions" style="justify: center;">
                     <button class="btn btn--primary" data-action="close-modal" data-modal-id="generic-modal">Finalizar</button>
                 </div>
              </div>
         </div>
     </div>`;

     showGenericModal('Asistente de Importación CSV', wizardHTML);

     setTimeout(() => {
         let csvFile = null;
         let processedData = null;
         const wizardContent = select('csv-wizard-content');
         if (!wizardContent) return;

         const goToStep = (step) => {
             wizardContent.querySelectorAll('.json-wizard-step').forEach(s => s.style.display = 'none');
             wizardContent.querySelector(`#csv-wizard-step-${step}`).style.display = 'flex';
         };

         const fileInput = document.createElement('input');
         fileInput.type = 'file'; fileInput.accept = '.csv, text/csv'; fileInput.className = 'hidden';
         wizardContent.appendChild(fileInput);

         const handleFileSelection = (files) => {
             const file = files;
             const nameEl = select('csv-file-name'), processBtn = select('csv-process-btn'), errorEl = select('csv-file-error');
             if (file && (file.type === 'text/csv' || file.name.endsWith('.csv'))) {
                 csvFile = file;
                 nameEl.textContent = `Archivo: ${file.name}`;
                 processBtn.disabled = false;
                 errorEl.textContent = '';
             } else {
                 csvFile = null;
                 nameEl.textContent = 'Por favor, selecciona un archivo .csv válido.';
                 processBtn.disabled = true;
             }
         };
         
         const dropZone = select('csv-drop-zone');
         dropZone.addEventListener('click', () => fileInput.click());
         fileInput.addEventListener('change', () => handleFileSelection(fileInput.files));
         dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('drag-over'); });
         dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
         dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('drag-over'); handleFileSelection(e.dataTransfer.files); });

         select('csv-process-btn').addEventListener('click', async (e) => {
             if (!csvFile) return;
             const btn = e.target;
             setButtonLoading(btn, true, 'Analizando...');
             try {
                 const result = await csv_processFile(csvFile);
                 if (result) {
                     processedData = result.jsonData;
                     const { stats } = result;
                     const previewList = select('csv-preview-list');
                     let html = `
                         <li><span class="label">Filas Válidas Leídas</span><span class="value">${stats.rowCount}</span></li>
                         <li><span class="label">Cuentas a Crear</span><span class="value success">${stats.accounts}</span></li>
                         <li><span class="label">Conceptos a Crear</span><span class="value success">${stats.concepts}</span></li>
                         <li><span class="label">Saldos Iniciales</span><span class="value">${stats.initials}</span></li>
                         <li><span class="label">Movimientos (Ingreso/Gasto)</span><span class="value">${stats.movements}</span></li>
                         <li><span class="label">Transferencias Emparejadas</span><span class="value">${stats.transfers}</span></li>
                         <li><span class="label">Transferencias sin Pareja</span><span class="value ${stats.unmatched > 0 ? 'danger' : 'success'}">${stats.unmatched}</span></li>
                     `;
                     previewList.innerHTML = html;
                     goToStep(2);
                 }
             } catch (error) {
                 console.error("Error al procesar CSV:", error);
                 select('csv-file-error').textContent = `Error: ${error.message}`;
             } finally {
                 setButtonLoading(btn, false);
             }
         });

         select('csv-wizard-back-btn').addEventListener('click', () => goToStep(1));
         select('csv-wizard-import-final').addEventListener('click', (e) => {
             if (processedData) handleFinalCsvImport(e.target, processedData, goToStep);
         });
     }, 0);
 };

 const handleFinalCsvImport = async (btn, dataToImport, goToStep) => {
     goToStep(3);
     setButtonLoading(btn, true, 'Importando...');

     try {
         const collectionsToClear = ['cuentas', 'conceptos', 'movimientos', 'presupuestos', 'recurrentes', 'inversiones_historial', 'inversion_cashflows'];

         for (const collectionName of collectionsToClear) {
             const snapshot = await fbDb.collection('users').doc(currentUser.uid).collection(collectionName).get();
             if (snapshot.empty) continue;
             let batch = fbDb.batch();
             let count = 0;
             for (const doc of snapshot.docs) {
                 batch.delete(doc.ref);
                 count++;
                 if (count >= 450) { await batch.commit(); batch = fbDb.batch(); count = 0; }
             }
             if (count > 0) await batch.commit();
         }
         
         for (const collectionName of Object.keys(dataToImport)) {
             const items = dataToImport[collectionName];
             if (Array.isArray(items) && items.length > 0) {
                 let batch = fbDb.batch();
                 let count = 0;
                 for (const item of items) {
                     if (item.id) {
                         const docRef = fbDb.collection('users').doc(currentUser.uid).collection(collectionName).doc(item.id);
                         batch.set(docRef, item);
                         count++;
                         if (count >= 450) { await batch.commit(); batch = fbDb.batch(); count = 0; }
                     }
                 }
                 if (count > 0) await batch.commit();
             } else if (collectionName === 'config') {
                 await fbDb.collection('users').doc(currentUser.uid).set({ config: items }, { merge: true });
             }
         }
         
         const resultEl = select('csv-import-result');
         select('csv-import-progress').style.display = 'none';
         if(resultEl) {
             resultEl.style.display = 'block';
             resultEl.querySelector('#csv-result-title').textContent = '¡Importación Completada!';
             resultEl.querySelector('#csv-result-message').textContent = 'Los datos se han importado correctamente. La aplicación se recargará.';
         }
         
         hapticFeedback('success');
         showToast('¡Importación completada!', 'info', 4000);
         setTimeout(() => location.reload(), 4500);

     } catch (error) {
         console.error("Error en importación final desde CSV:", error);
         showToast("Error crítico durante la importación.", "danger", 5000);
         const resultEl = select('csv-import-result');
         select('csv-import-progress').style.display = 'none';
         if(resultEl) {
             resultEl.style.display = 'block';
             resultEl.querySelector('#csv-result-title').textContent = '¡Error en la Importación!';
             resultEl.querySelector('#csv-result-message').textContent = 'Ocurrió un error. Revisa la consola e inténtalo de nuevo.';
             const iconEl = resultEl.querySelector('.material-icons');
             if (iconEl) iconEl.style.color = 'var(--c-danger)';
         }
         setButtonLoading(btn, false);
     }
 };

// ==============================================================
// === INICIO: FUNCIÓN DE BORRADO OPTIMIZADA (v2.0) ===
// ==============================================================
const deleteMovementAndAdjustBalance = async (id, isRecurrent = false) => {
    const collection = isRecurrent ? 'recurrentes' : 'movimientos';
    const ANIMATION_DURATION = 400; // Debe coincidir con la duración en el CSS (0.4s)

    // Buscamos el elemento visual en el DOM ANTES de hacer cualquier cambio.
    const itemElement = document.querySelector(`.transaction-card[data-id="${id}"]`)?.closest('.swipe-container');

    try {
        // 1. ELIMINACIÓN DE DATOS (Optimista e Inmediata)
        let itemToDelete;
        if (isRecurrent) {
            const index = db.recurrentes.findIndex(r => r.id === id);
            if (index === -1) throw new Error("Recurrente no encontrado.");
            [itemToDelete] = db.recurrentes.splice(index, 1);
        } else {
            const index = db.movimientos.findIndex(m => m.id === id);
            if (index === -1) throw new Error("Movimiento no encontrado.");
            [itemToDelete] = db.movimientos.splice(index, 1);
        }

        // 2. EFECTO VISUAL (Si el elemento está en pantalla)
        if (itemElement) {
            itemElement.classList.add('item-deleting');
        }

        // 3. SINCRONIZACIÓN Y REDIBUJADO
        setTimeout(() => {
            updateLocalDataAndRefreshUI(); // Redibuja la lista virtual con los datos ya actualizados.
            if (isRecurrent) renderPlanificacionPage(); // Refresca la vista de planificación si se borra un recurrente.
        }, itemElement ? ANIMATION_DURATION : 0); // Si no hay elemento visual, el redibujado es inmediato.

        // 4. PERSISTENCIA EN BASE DE DATOS (en segundo plano)
        const batch = fbDb.batch();
        const userRef = fbDb.collection('users').doc(currentUser.uid);

        if (!isRecurrent) {
            if (itemToDelete.tipo === 'traspaso') {
                const origenRef = userRef.collection('cuentas').doc(itemToDelete.cuentaOrigenId);
                const destinoRef = userRef.collection('cuentas').doc(itemToDelete.cuentaDestinoId);
                batch.update(origenRef, { saldo: firebase.firestore.FieldValue.increment(itemToDelete.cantidad) });
                batch.update(destinoRef, { saldo: firebase.firestore.FieldValue.increment(-itemToDelete.cantidad) });
            } else {
                const cuentaRef = userRef.collection('cuentas').doc(itemToDelete.cuentaId);
                batch.update(cuentaRef, { saldo: firebase.firestore.FieldValue.increment(-itemToDelete.cantidad) });
            }
        }

        const docToDeleteRef = userRef.collection(collection).doc(id);
        batch.delete(docToDeleteRef);
        await batch.commit();

        hapticFeedback('success');
        showToast("Elemento eliminado.", "info");

    } catch (error) {
        console.error("Error al eliminar:", error);
        showToast("Error al eliminar. Recargando para mantener la consistencia...", "danger");
        setTimeout(() => location.reload(), 1500); // Recarga como último recurso.
    }
};
// ============================================================
// === FIN: FUNCIÓN DE BORRADO OPTIMIZADA ===
// ============================================================
const auditAndFixAllBalances = async (btn) => {
    if (!currentUser) {
        showToast("Debes iniciar sesión para realizar esta acción.", "danger");
        return;
    }

    setButtonLoading(btn, true, 'Auditando...');
    showToast("Iniciando recálculo de saldos... Esto puede tardar un momento.", 'info', 4000);

    try {
        const userRef = fbDb.collection('users').doc(currentUser.uid);
        const cuentasRef = userRef.collection('cuentas');
        const movimientosRef = userRef.collection('movimientos');

        const cuentasSnapshot = await cuentasRef.get();
        const newBalances = {};
        cuentasSnapshot.forEach(doc => {
            newBalances[doc.id] = 0;
        });

        const movimientosSnapshot = await movimientosRef.get();
        console.log(`Procesando ${movimientosSnapshot.size} movimientos para el recálculo.`);

        movimientosSnapshot.forEach(doc => {
            const mov = doc.data();
            if (mov.tipo === 'traspaso') {
                if (newBalances.hasOwnProperty(mov.cuentaOrigenId)) {
                    newBalances[mov.cuentaOrigenId] -= mov.cantidad;
                }
                if (newBalances.hasOwnProperty(mov.cuentaDestinoId)) {
                    newBalances[mov.cuentaDestinoId] += mov.cantidad;
                }
            } else {
                if (newBalances.hasOwnProperty(mov.cuentaId)) {
                    newBalances[mov.cuentaId] += mov.cantidad;
                }
            }
        });

        const batch = fbDb.batch();
        for (const cuentaId in newBalances) {
            const cuentaRef = cuentasRef.doc(cuentaId);
            batch.update(cuentaRef, { saldo: newBalances[cuentaId] });
        }
        
        await batch.commit();

        hapticFeedback('success');
        showToast("¡Auditoría completada! Todos los saldos han sido recalculados y actualizados.", "info", 5000);
        
        loadCoreData(currentUser.uid);

    } catch (error) {
        console.error("Error crítico durante el recálculo de saldos:", error);
        showToast("Ocurrió un error grave durante el recálculo. Revisa la consola.", "danger");
    } finally {
        setButtonLoading(btn, false);
    }
};    

const handleSaveInvestmentAccounts = async (form, btn) => {
    setButtonLoading(btn, true);
    const selectedIds = new Set(Array.from(form.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value));
    const batch = fbDb.batch();
    db.cuentas.forEach(c => {
        const ref = fbDb.collection('users').doc(currentUser.uid).collection('cuentas').doc(c.id);
        batch.update(ref, { esInversion: selectedIds.has(c.id) });
    });
    await batch.commit();
    setButtonLoading(btn, false);
    hideModal('generic-modal');
    hapticFeedback('success');
    showToast('Portafolio actualizado.');
};
const handleResetPortfolioBaseline = async (btn) => {
const investmentAccounts = getVisibleAccounts().filter(c => c.esInversion);
if (investmentAccounts.length === 0) {
    showToast("No hay activos de inversión para resetear.", "warning");
    return;
}

showConfirmationModal(
    `¿Estás seguro? Se creará una nueva valoración para ${investmentAccounts.length} activo(s), poniendo su valor al capital aportado. Esto pondrá su P&L a cero a fecha de hoy. Esta acción no se puede deshacer.`,
    async () => {
        setButtonLoading(btn, true, 'Reseteando...');
        try {
            const batch = fbDb.batch();
            const userRef = fbDb.collection('users').doc(currentUser.uid);
            const todayISO = new Date(new Date().getTime() - (new Date().getTimezoneOffset() * 60000)).toISOString();

            for (const cuenta of investmentAccounts) {
                // Calculamos el capital invertido para esta cuenta específica
                const cashflows = (db.inversion_cashflows || []).filter(cf => cf.cuentaId === cuenta.id);
                const capitalInvertido = cashflows.reduce((sum, cf) => sum + cf.cantidad, 0);

                // Creamos la nueva valoración que iguala el valor al capital
                const newId = generateId();
                const newValoracion = {
                    id: newId,
                    cuentaId: cuenta.id,
                    valor: capitalInvertido, // ¡La magia está aquí!
                    fecha: todayISO
                };
                
                const docRef = userRef.collection('inversiones_historial').doc(newId);
                batch.set(docRef, newValoracion);
            }

            await batch.commit();

            hapticFeedback('success');
            showToast("¡Línea base establecida! El P&L de todos los activos ha sido reseteado a cero.", "info", 5000);
            
            // Cerramos el modal y refrescamos el portafolio para ver el cambio
            hideModal('generic-modal');
            const container = select('patrimonio-inversiones-container');
            if (container) {
                renderInversionesPage('patrimonio-inversiones-container');
            }

        } catch (error) {
            console.error("Error al resetear la línea base del portafolio:", error);
            showToast("Ocurrió un error durante el reseteo.", "danger");
        } finally {
            setButtonLoading(btn, false);
        }
    },
    "Confirmar Reseteo de P&L"
);

};

document.addEventListener('DOMContentLoaded', initApp);

const fetchMovementsInChunks = async (baseQuery, field, ids) => {
    if (ids.length === 0) {
        return [];
    }
    const idChunks = chunkArray(ids, 10);
    
    const queryPromises = idChunks.map(chunk => {
        return baseQuery.where(field, 'in', chunk).get();
    });

    const querySnapshots = await Promise.all(queryPromises);

    let movements = [];
    querySnapshots.forEach(snapshot => {
        snapshot.forEach(doc => {
            movements.push({ id: doc.id, ...doc.data() });
        });
    });

    return movements;
};

const validateField = (id, silent = false) => {
    const input = select(id);
    if (!input) return true;

    clearError(id);
    let isValid = true;
    const value = input.value.trim();
    const traspasoPill = select('mov-type-btn-traspaso');
    const type = traspasoPill && traspasoPill.classList.contains('filter-pill--active') ? 'traspaso' : 'movimiento';

    switch (id) {
        case 'movimiento-cantidad':
            const amount = parseCurrencyString(value);
            if (isNaN(amount) || value === '') {
                displayError(id, 'Cantidad no válida.'); isValid = false;
            }
            break;
        case 'movimiento-descripcion':
            if (type !== 'traspaso' && value === '') {
                displayError(id, 'La descripción es obligatoria.'); isValid = false;
            }
            break;
        case 'movimiento-concepto':
            if (type === 'movimiento' && value === '') {
                displayError(id, 'El concepto es obligatorio.'); isValid = false;
            }
            break;
        case 'movimiento-cuenta':
            if (type === 'movimiento' && value === '') {
                displayError(id, 'La cuenta es obligatoria.'); isValid = false;
            }
            break;
        case 'movimiento-cuenta-origen':
        case 'movimiento-cuenta-destino':
            if (type === 'traspaso') {
                const origen = select('movimiento-cuenta-origen').value;
                const destino = select('movimiento-cuenta-destino').value;
                if (value === '') {
                    displayError(id, 'La cuenta es obligatoria.');
                    isValid = false;
                } else if (origen && destino && origen === destino) {
                    if (input.id === 'movimiento-cuenta-origen') {
                        displayError(id, 'No puede ser la misma cuenta destino.');
                    } else {
                        displayError(id, 'No puede ser la misma cuenta origen.');
                    }
                    isValid = false;
                }
            }
            break;
        case 'movimiento-fecha':
            if (value === '') {
                displayError(id, 'La fecha es obligatoria.'); isValid = false;
            }
            break;
        case 'new-cuenta-nombre':
        case 'new-cuenta-tipo':
        case 'edit-cuenta-nombre':
        case 'edit-cuenta-tipo':
            if (value === '') {
                displayError(id, 'Este campo es obligatorio.'); isValid = false;
            }
            break;
        case 'new-concepto-nombre':
        case 'edit-concepto-nombre':
            if (value === '') {
                displayError(id, 'Este campo es obligatorio.'); isValid = false;
            }
            break;
         case 'valoracion-valor':
            const valor = parseCurrencyString(value);
            if (isNaN(valor) || valor < 0) {
                displayError(id, 'Valor no válido. Debe ser un número positivo.'); isValid = false;
            }
            break;
        case 'valoracion-fecha':
            if (value === '') {
                displayError(id, 'La fecha es obligatoria.'); isValid = false;
            }
            break;
        case 'aportacion-cantidad':
            const aportacion = parseCurrencyString(value);
            if (isNaN(aportacion) || value === '') {
                displayError(id, 'Cantidad no válida.'); isValid = false;
            }
            break;
        case 'aportacion-fecha':
            if (value === '') {
                displayError(id, 'La fecha es obligatoria.'); isValid = false;
            }
            break;
    }

    if (!isValid && !silent) hapticFeedback('light');

    return isValid;
};

const validateMovementForm = () => {
    let isValid = true;
    if (!validateField('movimiento-cantidad')) isValid = false;
    if (!validateField('movimiento-fecha')) isValid = false;

    // --- ✅ INICIO DE LA CORRECCIÓN ---
    // En lugar de buscar por un ID, buscamos el botón activo y leemos su 'data-type'
    const selectedType = document.querySelector('[data-action="set-movimiento-type"].filter-pill--active').dataset.type;
    // --- ✅ FIN DE LA CORRECCIÓN ---

    if (selectedType === 'movimiento' || selectedType === 'gasto' || selectedType === 'ingreso') {
        if (!validateField('movimiento-descripcion')) isValid = false;
        if (!validateField('movimiento-concepto')) isValid = false;
        if (!validateField('movimiento-cuenta')) isValid = false;
    } else { // Esto ahora sí se ejecutará cuando el tipo sea 'traspaso'
        const origenValid = validateField('movimiento-cuenta-origen');
        const destinoValid = validateField('movimiento-cuenta-destino');
        if (!origenValid || !destinoValid) isValid = false;
    }
    return isValid;
};
 
const longPressState = { timer: null, isLongPress: false };
const swipeState = { activeCard: null, startX: 0, currentX: 0, isSwiping: false, isSwipeIntent: false, threshold: 60 };

const handleInteractionStart = (e) => {
    const card = e.target.closest('.transaction-card');
    if (!card || !card.dataset.id) return;

    resetActiveSwipe();

    longPressState.isLongPress = false;
    longPressState.timer = setTimeout(() => {
        longPressState.isLongPress = true;
        swipeState.isSwiping = false;
        
        hapticFeedback('medium');
        
        showContextMenuForMovement(card.dataset.id);
        
    }, 500);

    swipeState.isSwiping = true;
    swipeState.isSwipeIntent = false;
    swipeState.activeCard = card;
    // --- INICIO DE LA MODIFICACIÓN ---
    const point = e.type === 'touchstart' ? e.touches[0] : e;
    swipeState.startX = point.clientX;
    swipeState.currentX = swipeState.startX;
    swipeState.startY = point.clientY; // <-- AÑADE ESTA LÍNEA
    // --- FIN DE LA MODIFICACIÓN ---
};


const handleInteractionMove = (e) => {
    if (!swipeState.isSwiping || !swipeState.activeCard) return;

    // --- INICIO DE LA MODIFICACIÓN ---
    const point = e.type === 'touchmove' ? e.touches[0] : e;
    const deltaX = point.clientX - swipeState.startX;
    const deltaY = point.clientY - swipeState.startY; // <-- AÑADE ESTA LÍNEA

    // Si es la primera vez que se detecta movimiento, decidimos si es scroll o swipe
    if (!swipeState.isSwipeIntent && (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10)) {
        // Si el movimiento es más vertical que horizontal, es un SCROLL.
        if (Math.abs(deltaY) > Math.abs(deltaX)) {
            // Cancelamos todo el proceso de swipe y dejamos que el navegador haga scroll.
            if (longPressState.timer) clearTimeout(longPressState.timer);
            swipeState.isSwiping = false;
            return;
        }
        // Si es más horizontal, es un SWIPE.
        swipeState.isSwipeIntent = true;
        if (longPressState.timer) clearTimeout(longPressState.timer);
    }
    // --- FIN DE LA MODIFICACIÓN ---

    if (swipeState.isSwipeIntent) {
        e.preventDefault(); 
        swipeState.currentX = point.clientX;
        const currentDiff = swipeState.currentX - swipeState.startX;
        
        const direction = currentDiff > 0 ? 'right' : 'left';
        const leftActions = swipeState.activeCard.parentElement.querySelector('.swipe-actions-container.left');
        const rightActions = swipeState.activeCard.parentElement.querySelector('.swipe-actions-container.right');
        const activeActions = direction === 'right' ? leftActions : rightActions;
        const inactiveActions = direction === 'right' ? rightActions : leftActions;

        if (activeActions) activeActions.classList.add('swipe-actions-container--visible');
        if (inactiveActions) inactiveActions.classList.remove('swipe-actions-container--visible');
        
        const progress = Math.min(Math.abs(currentDiff) / swipeState.threshold, 1);
        const icon = activeActions ? activeActions.querySelector('.material-icons') : null;
        if (icon) {
            icon.style.transform = `scale(${0.5 + (progress * 0.7)})`;
            icon.style.opacity = progress;
        }
        
        swipeState.activeCard.style.transition = 'none';
        swipeState.activeCard.style.transform = `translateX(${currentDiff}px)`;
    }
};
const handleInteractionEnd = (e) => {
    // Siempre limpiamos el cronómetro al soltar, por si no se había disparado.
    if (longPressState.timer) {
        clearTimeout(longPressState.timer);
        longPressState.timer = null;
    }
    
    // Si ya se ejecutó la acción de pulsación larga, no hacemos nada más.
    if (longPressState.isLongPress) {
        longPressState.isLongPress = false; // Reseteamos para la próxima vez
        return;
    }

    // El resto de tu lógica de swipe se mantiene igual.
    if (!swipeState.isSwiping || !swipeState.activeCard) return;
    
    if (swipeState.isSwipeIntent) {
        const diff = swipeState.currentX - swipeState.startX;
        swipeState.activeCard.style.transition = 'transform 0.3s ease-out';
        
        if (Math.abs(diff) > swipeState.threshold) {
            const direction = diff > 0 ? 'right' : 'left';
            const finalX = direction === 'right' ? 75 : -75;
            swipeState.activeCard.style.transform = `translateX(${finalX}px)`;
            hapticFeedback('light');
        } else {
            resetActiveSwipe();
        }
    } 

    swipeState.isSwiping = false;
    swipeState.isSwipeIntent = false;
};
const showContextMenuForMovement = (movementId) => {
    const movement = db.movimientos.find(m => m.id === movementId);
    if (!movement) return;

    const html = `
        <div style="display: flex; flex-direction: column; gap: var(--sp-2);">
            <button class="btn btn--secondary btn--full" data-action="context-edit" data-id="${movementId}">
                <span class="material-icons">edit</span> Editar Movimiento
            </button>
            <button class="btn btn--secondary btn--full" data-action="context-duplicate" data-id="${movementId}">
                <span class="material-icons">content_copy</span> Duplicar
            </button>
            <button class="btn btn--danger btn--full" data-action="context-delete" data-id="${movementId}">
                <span class="material-icons">delete</span> Eliminar
            </button>
        </div>
    `;
    
    // Usamos el modal genérico para mostrar las opciones
    showGenericModal(`Acciones para: ${movement.descripcion}`, html);
};
// Asegúrate de que tu función resetActiveSwipe también oculte las acciones
const resetActiveSwipe = () => {
if (swipeState.activeCard) {
swipeState.activeCard.style.transition = 'transform 0.3s ease-out';
swipeState.activeCard.style.transform = 'translateX(0px)';
// También nos aseguramos de ocultar las acciones aquí
const parent = swipeState.activeCard.parentElement;
parent.querySelector('.swipe-actions-container.left')?.classList.remove('swipe-actions-container--visible');
parent.querySelector('.swipe-actions-container.right')?.classList.remove('swipe-actions-container--visible');
}
swipeState.activeCard = null;
};

const handleDescriptionInput = () => {
    clearTimeout(descriptionSuggestionDebounceTimer);
    descriptionSuggestionDebounceTimer = setTimeout(() => {
        const descriptionInput = select('movimiento-descripcion');
        const suggestionsBox = select('description-suggestions');
        if (!descriptionInput || !suggestionsBox) return;

        const query = descriptionInput.value.trim().toLowerCase();
        suggestionsBox.innerHTML = '';

        if (query.length < 2) {
            suggestionsBox.style.display = 'none';
            return;
        }

        // 1. Busca las mejores sugerencias basadas en tus hábitos
        const suggestions = [];
        for (const [desc, data] of intelligentIndex.entries()) {
            if (desc.includes(query)) {
                suggestions.push({ description: desc, ...data });
            }
        }

        const now = Date.now();
        suggestions.sort((a, b) => {
            const recencyA = Math.exp((a.lastUsed - now) / (1000 * 3600 * 24 * 30));
            const recencyB = Math.exp((b.lastUsed - now) / (1000 * 3600 * 24 * 30));
            const scoreA = (a.count * 0.6) + (recencyA * 0.4);
            const scoreB = (b.count * 0.6) + (recencyB * 0.4);
            return scoreB - scoreA;
        });

        const topSuggestion = suggestions[0];
        const conceptoSelect = select('movimiento-concepto');
        const cuentaSelect = select('movimiento-cuenta');

        // ==========================================================
        // ===        ✨ ¡LA MAGIA DEL COPILOTO SUCEDE AQUÍ! ✨      ===
        // ==========================================================
        if (topSuggestion) {
            // 2. Si lo que escribes coincide con el inicio de tu mejor sugerencia...
            if (topSuggestion.description.startsWith(query) && topSuggestion.description.length > query.length) {
                
                // 3. ...y si el campo "Concepto" está vacío, ¡lo rellenamos por ti!
                if (!conceptoSelect.value && conceptoSelect.querySelector(`option[value="${topSuggestion.conceptoId}"]`)) {
                    conceptoSelect.value = topSuggestion.conceptoId;
                    
                    // Animación para que veas lo que ha pasado
                    const parent = conceptoSelect.closest('.form-group-addon');
                    if(parent) {
                        parent.classList.add('field-highlighted');
                        setTimeout(() => parent.classList.remove('field-highlighted'), 1500);
                    }
                }
                
                // 4. ...y hacemos lo mismo con el campo "Cuenta".
                if (!cuentaSelect.value && cuentaSelect.querySelector(`option[value="${topSuggestion.cuentaId}"]`)) {
                    cuentaSelect.value = topSuggestion.cuentaId;

                    // Animación para que veas lo que ha pasado
                    const parent = cuentaSelect.closest('.form-group-addon');
                    if(parent) {
                        parent.classList.add('field-highlighted');
                        setTimeout(() => parent.classList.remove('field-highlighted'), 1500);
                    }
                }
            }
            
            // ==========================================================
            // ===                FIN DE LA MAGIA                     ===
            // ==========================================================

            // 5. El resto del código simplemente muestra la lista de sugerencias, como ya hacía antes.
            suggestionsBox.innerHTML = suggestions.slice(0, DESCRIPTION_SUGGESTION_LIMIT).map(s => {
                const concepto = db.conceptos.find(c => c.id === s.conceptoId)?.nombre || 'S/C';
                const cuenta = db.cuentas.find(c => c.id === s.cuentaId)?.nombre || 'S/C';
                return `
                    <div class="suggestion-item" 
                         data-action="apply-description-suggestion"
                         data-description="${escapeHTML(s.description)}" 
                         data-concepto-id="${s.conceptoId}" 
                         data-cuenta-id="${s.cuentaId}"
                         tabindex="0">
                        <p>${escapeHTML(toSentenceCase(s.description))}</p>
                        <small>${escapeHTML(concepto)} • ${escapeHTML(cuenta)}</small>
                    </div>`;
            }).join('');
            suggestionsBox.style.display = 'block';
        } else {
            suggestionsBox.style.display = 'none';
        }
    }, 250);
};


// =================================================================
// === INICIO: MEJORAS DE USABILIDAD DEL FORMULARIO (NIVEL SUPREMO) ===
// =================================================================



</script>

</body>
</html>