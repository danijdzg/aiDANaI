<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <meta name="description" content="aiDANaI Ultimate Suite - Financial & Crypto">
    <title>aiDANaI Ultimate</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&family=Lexend:wght@300;400;500;700&family=Poppins:wght@400;500;700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    
   <style>
    :root { 
        --safe-top: env(safe-area-inset-top);
        --safe-bottom: env(safe-area-inset-bottom);
        --header-height: 60px; 
        
        /* === PALETA NEÓN (Base: indexxx.html) === */
        --neon-red: #ff0033; 
        --neon-cyan: #00f2ff;
        --neon-lime: #ccff00;
        --neon-yellow: #ffff00;
        --matrix-green: #39ff14;
        
        --crypto-up: #00ff9d;
        --crypto-down: #ff0033;

        /* === UX TRANSICIONES === */
        --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-normal: 250ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    body { overscroll-behavior: none; touch-action: none; } 
    #history-list, .crypto-content { overscroll-behavior: contain; touch-action: pan-y; }

    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; outline: none; }
    
    button, .card, li { touch-action: manipulation; cursor: pointer; }

    .tabular-nums { font-variant-numeric: tabular-nums; letter-spacing: -0.5px; }
    .small-decimal { font-size: 0.75em; vertical-align: baseline; opacity: 0.85; margin-left: 0px; font-weight: 400; }

    /* === ANIMACIONES (Fusión de ambos) === */
    @keyframes slideIn { from { opacity: 0; transform: translateY(-10px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes screenFlash { 0% { box-shadow: inset 0 0 0 rgba(0,0,0,0); } 50% { box-shadow: inset 0 0 60px var(--flash-color); } 100% { box-shadow: inset 0 0 0 rgba(0,0,0,0); } }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
    @keyframes popScale { 0% { transform: scale(1); } 50% { transform: scale(1.08); color: var(--history-res-color); } 100% { transform: scale(1); } }
    @keyframes ripple { to { transform: scale(4); opacity: 0; } }
    @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
    
    /* === NUEVAS ANIMACIONES PARA EFECTOS ESPECTACULARES === */
    @keyframes particleFloatUp { 0% { opacity: 0.8; transform: translateY(0) rotate(0deg) scale(0.5); } 100% { opacity: 0; transform: translateY(-150px) rotate(360deg) scale(1); } }
    @keyframes particleFloatDown { 0% { opacity: 0.8; transform: translateY(0) rotate(0deg) scale(0.5); } 100% { opacity: 0; transform: translateY(150px) rotate(-360deg) scale(1); } }
    @keyframes particleExplosion { 0% { opacity: 1; transform: scale(0) rotate(0deg); } 50% { opacity: 0.8; transform: scale(1.2) rotate(180deg); } 100% { opacity: 0; transform: scale(0.8) rotate(360deg); } }
    @keyframes particleFragmentation { 0% { opacity: 1; transform: translate(0, 0) scale(1) rotate(0deg); } 100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0) rotate(var(--rot)); } }
    @keyframes particleStarFall { 0% { opacity: 1; transform: translateY(-100px) rotate(0deg); } 100% { opacity: 0; transform: translateY(100px) rotate(720deg); } }
    @keyframes particleMatrixRain { 0% { opacity: 0; transform: translateY(-50px) translateX(var(--start-x)); } 10% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; transform: translateY(150px) translateX(var(--end-x)); } }
    @keyframes particleConfetti { 0% { opacity: 1; transform: translateY(-20px) rotate(0deg) scale(0.5); } 100% { opacity: 0; transform: translateY(100px) rotate(720deg) scale(1) translateX(var(--tx)); } }
    
    /* Animaciones de transición entre modos */
    @keyframes modeTransitionFlip { 
        0% { transform: perspective(1000px) rotateY(0deg) scale(1); opacity: 1; }
        50% { transform: perspective(1000px) rotateY(90deg) scale(0.8); opacity: 0.5; }
        100% { transform: perspective(1000px) rotateY(0deg) scale(1); opacity: 1; }
    }
    
    @keyframes modeTransitionFold { 
        0% { transform: perspective(1200px) rotateX(0deg); opacity: 1; }
        50% { transform: perspective(1200px) rotateX(-90deg) scale(0.7); opacity: 0.3; }
        100% { transform: perspective(1200px) rotateX(0deg); opacity: 1; }
    }
    
    @keyframes modeTransitionVortex { 
        0% { transform: scale(1) rotate(0deg); opacity: 1; filter: blur(0px); }
        30% { transform: scale(0.5) rotate(180deg); opacity: 0.5; filter: blur(5px); }
        70% { transform: scale(0.5) rotate(180deg); opacity: 0.5; filter: blur(5px); }
        100% { transform: scale(1) rotate(360deg); opacity: 1; filter: blur(0px); }
    }
    
    @keyframes modeTransitionGlitch { 
        0% { transform: translateX(0); opacity: 1; }
        10% { transform: translateX(-5px) skewX(5deg); opacity: 0.8; }
        20% { transform: translateX(5px) skewX(-5deg); opacity: 0.9; }
        30% { transform: translateX(-3px) skewX(3deg); opacity: 0.7; }
        40% { transform: translateX(3px) skewX(-3deg); opacity: 0.8; }
        50% { transform: translateX(0); opacity: 0.5; filter: blur(8px); }
        60% { transform: translateX(0); opacity: 0.7; filter: blur(4px); }
        70% { transform: translateX(0); opacity: 0.9; filter: blur(2px); }
        100% { transform: translateX(0); opacity: 1; filter: blur(0px); }
    }
    
    @keyframes modeTransitionMorph { 
        0% { clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); transform: scale(1); }
        25% { clip-path: polygon(25% 0%, 100% 25%, 75% 100%, 0% 75%); transform: scale(0.9); }
        50% { clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%); transform: scale(0.7); opacity: 0.7; }
        75% { clip-path: polygon(75% 25%, 75% 75%, 25% 75%, 25% 25%); transform: scale(0.9); }
        100% { clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%); transform: scale(1); opacity: 1; }
    }
    
    /* === NUEVAS ANIMACIONES PARA RETROALIMENTACIÓN TÁCTIL === */
    @keyframes pressureWave { 
        0% { opacity: 0; transform: scale(0.5); }
        50% { opacity: 0.7; transform: scale(1.2); }
        100% { opacity: 0; transform: scale(1.5); }
    }
    
    @keyframes touchTrail { 
        0% { opacity: 0.8; transform: translate(0, 0) scale(1); }
        100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0.5); }
    }
    
    @keyframes bounce { 
        0%, 100% { transform: scale(1); }
        30% { transform: scale(0.9); }
        50% { transform: scale(1.05); }
        70% { transform: scale(0.95); }
    }
    
    @keyframes elastic { 
        0% { transform: scale(1); }
        30% { transform: scale(0.85); }
        50% { transform: scale(1.1); }
        70% { transform: scale(0.95); }
        85% { transform: scale(1.03); }
        100% { transform: scale(1); }
    }
    
    @keyframes circuitFracture { 
        0% { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); }
        25% { clip-path: polygon(0 0, 80% 20%, 100% 100%, 20% 80%); }
        50% { clip-path: polygon(20% 0, 100% 20%, 80% 100%, 0 80%); }
        75% { clip-path: polygon(0 20%, 80% 0, 100% 80%, 20% 100%); }
        100% { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); }
    }
    
    @keyframes rippleGlow { 
        0% { box-shadow: 0 0 0 0 var(--glow-color); }
        70% { box-shadow: 0 0 0 20px rgba(255, 0, 51, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 0, 51, 0); }
    }
    
    @keyframes glowPulse { 
        0%, 100% { filter: drop-shadow(0 0 5px currentColor); }
        50% { filter: drop-shadow(0 0 15px currentColor); }
    }

    /* Clases de utilidad */
    .shake-active { animation: shake 0.3s ease-in-out; }
    .pop-active { animation: popScale 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
    
    /* Clases para transiciones entre modos */
    .transition-flip { animation: modeTransitionFlip 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards; }
    .transition-fold { animation: modeTransitionFold 0.9s cubic-bezier(0.87, 0, 0.13, 1) forwards; }
    .transition-vortex { animation: modeTransitionVortex 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
    .transition-glitch { animation: modeTransitionGlitch 1.2s steps(5, end) forwards; }
    .transition-morph { animation: modeTransitionMorph 1.1s cubic-bezier(0.77, 0, 0.175, 1) forwards; }
    
    /* Clases para retroalimentación táctil */
    .pressure-wave { animation: pressureWave 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
    .bounce-active { animation: bounce 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    .elastic-active { animation: elastic 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards; }
    .circuit-active { animation: circuitFracture 0.8s linear forwards; }
    .ripple-glow { animation: rippleGlow 1s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; }
    .glow-pulse { animation: glowPulse 1.5s ease-in-out infinite; }

    /* ================= TEMA OSCURO (Ultimate Dark) ================= */
    body[data-theme="dark"] { 
        --bg-body: #000000;
        --bg-gradient: radial-gradient(circle at 50% 0%, #1a0505 0%, #000000 70%);
        --chassis-bg: #050505;
        --chassis-border: 1px solid #222;
        --screen-bg: #000000;
        --screen-inset: inset 0 0 30px rgba(0,0,0,1);
        --screen-border: 1px solid rgba(255, 0, 51, 0.2);
        --screen-glow: 0 0 20px rgba(255, 0, 51, 0.05);
        --primary-text: #ffffff;
        --secondary-text: #888;
        --clock-text: var(--neon-yellow);
        --clock-glow: 0 0 15px rgba(255, 255, 0, 0.7);
        --history-op-color: #00f2ff;
        --history-res-color: #39ff14;
        --history-opacity: 0.9;
        --history-glow: 0 0 8px rgba(0, 242, 255, 0.3);
        --btn-bg: linear-gradient(160deg, #333333 0%, #000000 100%);
        --btn-border: 1px solid rgba(255,255,255,0.08);
        --btn-shadow: inset 0 1px 0 rgba(255,255,255,0.35), 0 6px 0 #000000, 0 8px 20px rgba(0,0,0,0.8);
        --btn-shadow-active: inset 0 10px 20px rgba(0,0,0,1), 0 0 0 #000000, 0 0 0 rgba(0,0,0,0);
        --btn-text: #dddddd;
        --accent-blue-text: var(--neon-cyan);
        --accent-red-text: var(--neon-red);
        --accent-green-bg: linear-gradient(180deg, #ccff00 0%, #4caf50 100%);
        --text-glow-blue: 0 0 15px rgba(0, 242, 255, 0.7);
        --text-glow-red: 0 0 15px rgba(255, 0, 51, 0.7);
        --card-bg: rgba(20, 20, 20, 0.85);
        --card-border: 1px solid rgba(255,255,255,0.1);
        --card-hover: rgba(30, 30, 30, 0.95);
        --edit-highlight: rgba(255, 0, 51, 0.15);
        --flash-color: rgba(255, 0, 51, 0.3);
        --op-active-bg: #ffffff;
        --op-active-color: #000000;
        --ripple-color: rgba(255, 255, 255, 0.15);
        --skeleton-bg: rgba(255, 0, 51, 0.1);
        --glow-color: rgba(255, 0, 51, 0.5);
    }

    /* ================= TEMA CLARO (Clean Light) ================= */
    body[data-theme="light"] { 
        --bg-body: #eef2f5;
        --bg-gradient: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        --chassis-bg: #eef2f5;
        --chassis-border: 1px solid rgba(255,255,255,0.8);
        --screen-bg: #e6e9ef;
        --screen-inset: inset 4px 4px 8px #cbced1, inset -4px -4px 8px #ffffff;
        --screen-border: 1px solid #fff;
        --screen-glow: none;
        --primary-text: #2d3436;
        --secondary-text: #636e72;
        --clock-text: #b7950b; 
        --clock-glow: none;
        --history-op-color: #0044ff;
        --history-res-color: #008f39;
        --history-opacity: 1;
        --history-glow: none;
        --btn-bg: linear-gradient(145deg, #ffffff, #d1d9e6);
        --btn-border: 1px solid #fff;
        --btn-shadow: 0 6px 0 #b1b5be, 0 10px 20px rgba(0,0,0,0.1);
        --btn-shadow-active: inset 0 3px 5px rgba(0,0,0,0.1), 0 0 0 #b1b5be, 0 0 0 rgba(0,0,0,0);
        --btn-text: #4a5568;
        --accent-blue-text: #0984e3;
        --accent-red-text: #ff0033;
        --accent-green-bg: linear-gradient(145deg, #55efc4, #00b894);
        --text-glow-blue: none;
        --text-glow-red: none;
        --card-bg: rgba(255,255,255,0.7);
        --card-border: 1px solid #fff;
        --card-hover: rgba(255,255,255,0.95);
        --edit-highlight: rgba(255, 0, 51, 0.1);
        --flash-color: rgba(0,0,0,0.05);
        --op-active-bg: #2d3436;
        --op-active-color: #ffffff;
        --ripple-color: rgba(0, 0, 0, 0.05);
        --skeleton-bg: rgba(0, 0, 0, 0.05);
        --glow-color: rgba(0, 132, 255, 0.3);
    }

    html, body { 
        height: 100dvh; 
        width: 100vw; 
        font-family: 'Poppins', sans-serif; 
        overflow: hidden; 
        background-color: var(--bg-body); 
        transition: background 0.4s ease;
        position: relative;
    }
    
    /* Fondos dinámicos */
    .dynamic-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
        opacity: 0.4;
        transition: opacity 0.5s ease;
    }
    
    .particles-bg {
        background: radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
            transparent 0%, 
            rgba(255, 0, 51, 0.05) 30%, 
            transparent 70%);
        filter: blur(20px);
    }
    
    .grid-pattern {
        background-image: 
            linear-gradient(rgba(255, 0, 51, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255, 0, 51, 0.05) 1px, transparent 1px);
        background-size: 30px 30px;
        background-position: center center;
    }
    
    .circuit-pattern {
        background-image: 
            radial-gradient(circle at 25% 25%, rgba(0, 242, 255, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 75% 75%, rgba(255, 0, 51, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 50% 50%, rgba(204, 255, 0, 0.05) 0%, transparent 60%);
    }
    
    .crypto-waves {
        background: 
            radial-gradient(circle at 20% 80%, rgba(0, 255, 157, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(255, 0, 51, 0.1) 0%, transparent 50%),
            repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(0, 242, 255, 0.03) 2px, rgba(0, 242, 255, 0.03) 4px);
    }
    
    .time-gradient {
        background: linear-gradient(
            var(--gradient-angle, 135deg),
            var(--time-color-1, #1a0505) 0%,
            var(--time-color-2, #000000) 70%
        );
    }
    
    .view-container { 
        width: 100%; 
        height: 100%; 
        position: relative; 
        overflow: hidden; 
        display: flex; 
        flex-direction: column; 
        background: transparent;
    }

    .view { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        display: flex; 
        flex-direction: column; 
        opacity: 0; 
        pointer-events: none; 
        transform: scale(0.95); 
        transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); 
        background: rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
    }
    .view.active { opacity: 1; pointer-events: auto; transform: scale(1); z-index: 10; }
    
    /* Capa para partículas */
    .particles-layer { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        pointer-events: none; 
        z-index: 1000;
        overflow: hidden;
    }
    
    .particle { 
        position: absolute; 
        pointer-events: none; 
        z-index: 1000;
    }
    
    .particle-circle { border-radius: 50%; }
    .particle-star { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); }
    .particle-square { border-radius: 10%; }
    .particle-triangle { clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
    .particle-hexagon { clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%); }
    
    /* Elementos para retroalimentación táctil */
    .pressure-wave-effect {
        position: absolute;
        border-radius: 50%;
        background: radial-gradient(circle, var(--glow-color) 0%, transparent 70%);
        pointer-events: none;
        z-index: 999;
    }
    
    .touch-trail {
        position: absolute;
        border-radius: 50%;
        background: var(--glow-color);
        pointer-events: none;
        z-index: 999;
        filter: blur(5px);
    }
    
    .glow-border {
        position: relative;
        overflow: hidden;
    }
    
    .glow-border::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: inherit;
        padding: 2px;
        background: linear-gradient(45deg, var(--neon-red), var(--neon-cyan), var(--neon-lime));
        -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask-composite: exclude;
        opacity: 0;
        transition: opacity 0.3s;
        pointer-events: none;
    }
    
    .glow-border.active::before {
        opacity: 1;
    }

    /* HEADER - Fusión: Estructura indexxx.html + Iconos Coloridos index.html */
    .app-header { 
        flex: 0 0 auto; 
        display: flex; 
        align-items: center; 
        justify-content: space-between; 
        padding: max(var(--safe-top), 10px) 15px 5px; 
        z-index: 20; 
        gap: 10px; 
        height: calc(var(--header-height) + var(--safe-top)); 
        width: 100%; 
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .embedded-ui { 
        background: var(--card-bg); 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        box-shadow: 0 4px 15px rgba(0,0,0,0.05); 
        border-radius: 16px; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        border: var(--card-border); 
        transition: all 0.2s; 
        flex-shrink: 0; 
        position: relative;
    }
    
    .embedded-ui.glow-active {
        animation: rippleGlow 1s ease-out;
    }

    .icon-btn { 
        width: 44px; 
        height: 44px; 
        cursor: pointer; 
        color: var(--secondary-text); 
        padding: 10px; 
        position: relative; 
        overflow: hidden; 
        transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    .icon-btn:active { transform: scale(0.85); }
    
    /* --- ESTILOS DE BOTONES COLOREADOS (Traídos de index.html) --- */
    .btn-theme { 
        color: #ffab00 !important; 
        filter: drop-shadow(0 0 2px rgba(255, 171, 0, 0.6)); 
        transition: all 0.3s; 
    }
    .btn-theme:hover { filter: drop-shadow(0 0 8px rgba(255, 171, 0, 1)); transform: scale(1.1); }
    
    #btn-mute { 
        color: var(--neon-cyan) !important; 
        filter: drop-shadow(0 0 2px rgba(0, 242, 255, 0.6)); 
        transition: all 0.3s; 
    }
    #btn-mute:hover { filter: drop-shadow(0 0 8px var(--neon-cyan)); transform: scale(1.1); }
    
    #btn-go-crypto { 
        color: var(--crypto-up) !important; 
        filter: drop-shadow(0 0 2px rgba(0, 255, 157, 0.6)); 
        transition: all 0.3s; 
    }
    #btn-go-crypto:hover { filter: drop-shadow(0 0 8px var(--crypto-up)); transform: scale(1.1); }
    
    #btn-go-calc { 
        color: #ff00ff !important; 
        filter: drop-shadow(0 0 2px rgba(255, 0, 255, 0.6)); 
        transition: all 0.3s; 
    }
    #btn-go-calc:hover { filter: drop-shadow(0 0 8px #ff00ff); transform: scale(1.1); }
    /* ------------------------------------------------------------- */

    /* Efecto Ripple (indexxx.html) */
    .ripple { 
        position: absolute; 
        border-radius: 50%; 
        background: var(--ripple-color); 
        transform: scale(0); 
        animation: ripple 0.6s linear; 
        pointer-events: none; 
    }

    .icon-swap svg { 
        position: absolute; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        transition: opacity 0.3s, transform 0.3s; 
    }
    .icon-swap .hidden { opacity: 0; transform: translate(-50%, -40%); pointer-events: none; }
    .icon-swap .shown { opacity: 1; transform: translate(-50%, -50%); }

    /* TITULO NEÓN ROJO (index.html) */
    .app-title { 
        font-family: 'Lexend', sans-serif; 
        font-weight: 800; 
        font-size: 1.2rem; 
        color: #ff0033 !important; 
        background: none !important;
        -webkit-text-fill-color: initial !important;
        text-shadow: 0 0 10px rgba(255, 0, 51, 0.8), 0 0 20px rgba(255, 0, 51, 0.4);
        flex-grow: 1; 
        text-align: center; 
        text-decoration: none; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
        height: 44px; 
        letter-spacing: 2px; 
        transition: all 0.3s;
    }
    
    .app-title.glow-pulse {
        animation: glowPulse 1.5s ease-in-out infinite;
    }
    
    #clock, #clock-crypto { 
        font-family: 'Fira Code', monospace; 
        font-weight: 700; 
        font-size: 0.8rem; 
        color: var(--clock-text); 
        text-shadow: var(--clock-glow);
        padding: 0 12px; 
        min-width: 80px; 
        text-align: center; 
        height: 44px; 
        transition: all 0.3s;
    }
    
    #clock.glow-pulse, #clock-crypto.glow-pulse {
        animation: glowPulse 2s ease-in-out infinite;
    }

    /* PANTALLA CALCULADORA (indexxx.html - Display Lens) */
    .upper-section { 
        flex: 1 1 40%; 
        display: flex; 
        flex-direction: column; 
        padding: 15px 20px; 
        min-height: 0; 
        justify-content: flex-end; 
        position: relative;
    }
    
    .display-lens { 
        width: 100%; 
        flex: 1; 
        background: var(--screen-bg); 
        box-shadow: var(--screen-inset), var(--screen-glow);
        border: var(--screen-border); 
        border-radius: 24px; 
        display: flex; 
        flex-direction: column; 
        padding: 20px; 
        position: relative; 
        overflow: hidden; 
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
    }
    .display-lens.pulse-active { animation: screenFlash 0.15s ease-out; }
    
    .display-lens.circuit-active {
        animation: circuitFracture 0.8s linear forwards;
    }
    
    #history-list { 
        flex: 1; 
        overflow-y: auto; 
        padding: 5px; 
        display: flex; 
        flex-direction: column-reverse; 
        list-style: none; 
        gap: 8px; 
        mask-image: linear-gradient(to top, black 85%, transparent 100%); 
        scrollbar-width: none; 
    }
    #history-list li { 
        text-align: right; 
        cursor: pointer; 
        opacity: var(--history-opacity); 
        font-family: 'Inter', sans-serif; 
        font-size: 1.1rem; 
        color: var(--history-op-color); 
        text-shadow: var(--history-glow);
        animation: slideIn 0.3s ease; 
        padding: 6px 10px; 
        border-radius: 8px; 
        transition: all 0.2s; 
        font-weight: 500;
        position: relative;
        overflow: hidden;
    }
    #history-list li:hover { 
        opacity: 1; 
        background: var(--edit-highlight); 
        transform: scale(1.02) translateX(-5px); 
    }
    #history-list li::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
        transition: left 0.5s;
    }
    #history-list li:hover::before {
        left: 100%;
    }
    #history-list b { 
        color: var(--history-res-color); 
        font-weight: 700; 
        margin-left: 8px; 
    }
    
    .display-area { 
        flex-shrink: 0; 
        text-align: right; 
        padding-top: 10px; 
        display: flex; 
        flex-direction: column; 
        justify-content: flex-end; 
        min-height: 90px; 
        z-index: 2; 
        width: 100%; 
        overflow: hidden; 
    }
    
    #secondary-display { 
        font-family: 'Fira Code', monospace; 
        color: var(--accent-blue-text); 
        text-shadow: var(--text-glow-blue); 
        min-height: 1.5rem; 
        font-size: 1.1rem; 
        opacity: 0; 
        transition: opacity 0.2s; 
        overflow: hidden; 
        white-space: nowrap; 
        text-overflow: ellipsis; 
        margin-bottom: 5px; 
    }
    #secondary-display.visible { opacity: 1; }
    
    #main-display { 
        font-family: 'Lexend', sans-serif; 
        color: var(--primary-text); 
        font-size: 3.2rem; 
        font-weight: 500; 
        line-height: 1.1; 
        width: 100%; 
        text-align: right; 
        white-space: nowrap; 
        overflow-x: auto; 
        overflow-y: hidden; 
        scrollbar-width: none; 
        text-shadow: 0 0 25px rgba(255,255,255,0.15); 
        transition: color 0.2s, font-size 0.1s ease-out; 
        padding-bottom: 2px;
        position: relative; 
        z-index: 2;
    }
    #main-display::-webkit-scrollbar { display: none; }

    /* TECLADO */
    .calculator-body { 
        flex: 1 1 60%; 
        width: 100%; 
        background: var(--chassis-bg); 
        border-top: var(--chassis-border);
        border-radius: 35px 35px 0 0; 
        z-index: 10; 
        padding: 25px; 
        padding-bottom: max(25px, var(--safe-bottom)); 
        box-shadow: 0 -20px 60px rgba(0,0,0,0.4);
        display: flex; 
        flex-direction: column; 
        justify-content: center; 
        backdrop-filter: blur(8px); 
        -webkit-backdrop-filter: blur(8px);
        position: relative;
    }
    
    .calculator-body::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--neon-red), var(--neon-cyan), transparent);
        opacity: 0.3;
    }
    
    .keypad { 
        flex: 1; 
        width: 100%; 
        display: grid; 
        grid-template-columns: repeat(4, 1fr); 
        grid-template-rows: repeat(5, 1fr); 
        gap: 15px; 
        align-items: center; 
        justify-items: center; 
    }

    .btn { 
        background: var(--btn-bg); 
        color: var(--btn-text); 
        box-shadow: var(--btn-shadow); 
        border: var(--btn-border);
        font-family: 'Lexend', sans-serif; 
        cursor: pointer; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        border-radius: 20px; 
        width: 100%; 
        height: 100%; 
        font-size: 1.4rem; 
        font-weight: 500; 
        position: relative; 
        overflow: hidden;
        transition: transform 0.1s, box-shadow 0.1s, color 0.1s, background 0.1s;
    }
    
    .btn.btn-large { grid-column: span 2; border-radius: 24px; }
    .btn:active, .btn.btn-active { 
        box-shadow: var(--btn-shadow-active); 
        transform: translateY(6px); 
        color: var(--primary-text); 
    }
    
    .btn.elastic-active {
        animation: elastic 0.6s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
    }
    
    .btn.bounce-active {
        animation: bounce 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }

    .btn.op-active { 
        background: var(--op-active-bg); 
        color: var(--op-active-color); 
        box-shadow: inset 0 3px 5px rgba(0,0,0,0.2); 
        text-shadow: none; 
        transform: translateY(1px); 
    }

    .btn[data-key="AC"], .btn[data-key="Backspace"] { 
        color: var(--accent-red-text); 
        text-shadow: var(--text-glow-red); 
        font-weight: 700; 
    }
    .token-op, .btn[data-color="blue"] { 
        color: var(--accent-blue-text); 
        text-shadow: var(--text-glow-blue); 
        font-weight: 600; 
        font-size: 1.6rem; 
    }
    .btn[data-color="green"] { 
        background: var(--accent-green-bg); 
        color: #000; 
        border: none; 
        box-shadow: 0 6px 0 #33691e, 0 10px 20px rgba(100, 255, 0, 0.3); 
    }
    .btn[data-color="green"]::after { 
        content: ''; 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 50%; 
        background: linear-gradient(to bottom, rgba(255,255,255,0.5) 0%, transparent 100%); 
        border-radius: 20px 20px 50% 50%; 
        opacity: 0.6; 
        pointer-events: none; 
    }
    .btn[data-color="green"]:active { 
        box-shadow: inset 0 5px 15px rgba(0,0,0,0.5); 
        transform: translateY(6px); 
    }

    /* CRYPTO - Layout elegante con Skeleton Loading (indexxx.html) */
    .crypto-content { 
        flex: 1; 
        padding: 10px 15px; 
        padding-bottom: calc(var(--safe-bottom) + 10px); 
        display: flex; 
        flex-direction: column; 
        overflow-y: auto; 
    }
    #timestamp { 
        flex-shrink: 0; 
        text-align: center; 
        color: var(--secondary-text); 
        font-size: 0.75rem; 
        margin-bottom: 10px; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
        gap: 8px; 
        text-transform: uppercase; 
        letter-spacing: 1px; 
    }
    .crypto-list { 
        flex: 1; 
        display: flex; 
        flex-direction: column; 
        justify-content: space-evenly; 
        min-height: 0; 
        gap: 10px; 
    }

    .card { 
        background: var(--card-bg); 
        border: var(--card-border);
        border-radius: 18px; 
        padding: 12px 16px; 
        box-shadow: 0 5px 15px rgba(0,0,0,0.1); 
        display: flex; 
        justify-content: space-between; 
        align-items: center; 
        cursor: pointer; 
        position: relative; 
        overflow: hidden;
        backdrop-filter: blur(10px); 
        -webkit-backdrop-filter: blur(10px);
        transition: transform 0.2s, box-shadow 0.2s, background 0.2s; 
        min-height: 70px; 
    }
    .card:hover { 
        transform: scale(1.02); 
        box-shadow: 0 5px 20px rgba(0,0,0,0.2), 0 0 10px var(--edit-highlight); 
        border-color: var(--accent-red-text); 
        background: var(--card-hover); 
    }
    
    .card.glow-border.active::before {
        opacity: 1;
        animation: rippleGlow 1s ease-out;
    }
    
    /* Skeleton Loading (indexxx.html) */
    .card.loading { pointer-events: none; }
    .card.loading::after {
        content: ""; 
        position: absolute; 
        top: 0; 
        left: 0; 
        right: 0; 
        bottom: 0;
        background: linear-gradient(90deg, transparent 0%, var(--skeleton-bg) 50%, transparent 100%);
        background-size: 200% 100%; 
        animation: shimmer 1.5s infinite linear; 
        z-index: 5;
    }

    .coin-logo { 
        width: 36px; 
        height: 36px; 
        border-radius: 50%; 
        box-shadow: 0 2px 8px rgba(0,0,0,0.3); 
        transition: transform 0.3s; 
    }
    .card:hover .coin-logo { transform: rotate(10deg) scale(1.1); }
    .coin-info h2 { 
        font-size: 1rem; 
        margin: 0; 
        color: var(--primary-text); 
        font-weight: 700; 
        letter-spacing: 0.5px; 
    }
    
    .change-percentage { 
        font-size: 0.85rem; 
        font-weight: 600; 
        padding: 2px 6px; 
        border-radius: 4px; 
    }
    .change-positive { 
        color: var(--crypto-up); 
        background: rgba(0, 255, 157, 0.1); 
        border: 1px solid rgba(0, 255, 157, 0.2); 
        text-shadow: 0 0 8px rgba(0,255,157,0.3); 
    }
    .change-negative { 
        color: var(--crypto-down); 
        background: rgba(255, 0, 51, 0.1); 
        border: 1px solid rgba(255, 0, 51, 0.2); 
        text-shadow: 0 0 8px rgba(255, 0, 51, 0.4); 
    }
    
    .price-eur { 
        font-size: 1.1rem; 
        font-weight: 700; 
        color: var(--primary-text); 
        text-align: right; 
        letter-spacing: -0.5px; 
    }
    .price-usd { 
        font-size: 0.8rem; 
        color: var(--secondary-text); 
        text-align: right; 
        margin-top: 2px; 
    }

    /* MODALES Y TOAST */
    .status-dot { 
        width: 8px; 
        height: 8px; 
        border-radius: 50%; 
        background-color: var(--secondary-text); 
        box-shadow: 0 0 5px currentColor; 
        transition: 0.3s; 
    }
    .status-dot.online { 
        background-color: var(--neon-cyan); 
        box-shadow: 0 0 10px var(--neon-cyan); 
        animation: glowPulse 1.5s ease-in-out infinite;
    }
    .status-dot.error { 
        background-color: var(--neon-red); 
        box-shadow: 0 0 10px var(--neon-red); 
        animation: glowPulse 1s ease-in-out infinite;
    }

    #chart-modal { 
        position: fixed; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background: rgba(0,0,0,0.9); 
        backdrop-filter: blur(20px); 
        -webkit-backdrop-filter: blur(20px);
        z-index: 100; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
        opacity: 0; 
        pointer-events: none; 
        transition: 0.3s; 
        padding: 20px; 
    }
    #chart-modal.visible { opacity: 1; pointer-events: auto; }
    .modal-content { 
        width: 100%; 
        max-width: 500px; 
        background: var(--chassis-bg); 
        border: 1px solid var(--accent-red-text); 
        box-shadow: 0 0 40px rgba(255,0,51,0.15); 
        border-radius: 30px; 
        padding: 25px; 
        transform: scale(0.9); 
        transition: 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); 
        display: flex; 
        flex-direction: column; 
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }
    #chart-modal.visible .modal-content { transform: scale(1); }
    
    .close-chart { 
        align-self: flex-end; 
        background: none; 
        border: none; 
        font-size: 2rem; 
        color: var(--secondary-text); 
        cursor: pointer; 
        line-height: 1; 
        transition: 0.2s; 
        width: 40px; 
        height: 40px; 
        border-radius: 50%; 
        display: flex; 
        align-items: center; 
        justify-content: center; 
    }
    .close-chart:hover { 
        color: var(--accent-red-text); 
        background: rgba(255,0,51,0.1); 
        text-shadow: 0 0 10px var(--accent-red-text); 
        transform: rotate(90deg);
    }
    
    .chart-controls { 
        display: flex; 
        justify-content: center; 
        gap: 8px; 
        margin-bottom: 20px; 
        background: rgba(128,128,128,0.1); 
        padding: 6px; 
        border-radius: 14px; 
    }
    .time-btn { 
        background: transparent; 
        border: none; 
        color: var(--secondary-text); 
        padding: 8px 16px; 
        border-radius: 10px; 
        font-size: 0.9rem; 
        cursor: pointer; 
        font-family: 'Lexend', sans-serif; 
        font-weight: 600; 
        transition: 0.2s; 
    }
    .time-btn.active { 
        background: var(--card-bg); 
        color: var(--accent-red-text); 
        box-shadow: 0 2px 8px rgba(0,0,0,0.1); 
        text-shadow: 0 0 8px rgba(255, 0, 51, 0.4); 
    }
    
    .loading-spinner { 
        position: absolute; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        width: 50px; 
        height: 50px; 
        border: 4px solid rgba(255,255,255,0.1); 
        border-left-color: var(--neon-red); 
        border-radius: 50%; 
        animation: spin 0.8s linear infinite; 
        display: none; 
        z-index: 10; 
        box-shadow: 0 0 15px var(--neon-red); 
    }
    .loading-spinner.active { display: block; }
    
    .toast { 
        position: fixed; 
        top: 90px; 
        left: 50%; 
        transform: translate(-50%, -20px) scale(0.9); 
        background: rgba(10, 10, 10, 0.95); 
        border: 1px solid var(--accent-red-text); 
        box-shadow: 0 0 20px rgba(255, 0, 51, 0.3); 
        color: white; 
        padding: 12px 30px; 
        border-radius: 40px; 
        font-size: 1rem; 
        opacity: 0; 
        transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
        pointer-events: none; 
        z-index: 200; 
        font-weight: 600; 
        letter-spacing: 0.5px; 
        backdrop-filter: blur(10px); 
        -webkit-backdrop-filter: blur(10px);
    }
    .toast.show { opacity: 1; transform: translate(-50%, 0) scale(1); }

    /* Audio Visualizer */
    .audio-visualizer {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid var(--neon-red);
        z-index: 1001;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s;
        opacity: 0.7;
    }
    
    .audio-visualizer:hover {
        opacity: 1;
        transform: scale(1.1);
        box-shadow: 0 0 20px var(--neon-red);
    }
    
    .visualizer-bar {
        width: 3px;
        background: var(--neon-cyan);
        border-radius: 2px;
        margin: 0 1px;
        transition: height 0.1s;
    }

    @media (max-width: 380px) {
        .app-header { gap: 4px; padding: 5px; }
        .app-header .icon-btn { width: 38px; height: 38px; padding: 8px; }
        .app-title { font-size: 1rem; }
        #clock, #clock-crypto { font-size: 0.7rem; min-width: 65px; }
        .keypad { gap: 10px; }
        .btn { font-size: 1.2rem; border-radius: 16px; }
        .audio-visualizer {
            bottom: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
        }
    }
    
    @media(min-width: 600px) {
        body { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            background: #050505; 
        }
        .view-container { 
            max-width: 420px; 
            height: 92vh; 
            border-radius: 45px; 
            border: 8px solid #111; 
            box-shadow: 0 0 0 2px #333, 0 20px 50px rgba(0,0,0,0.8), 0 0 100px rgba(255, 0, 51, 0.1); 
            overflow: hidden;
        }
        body[data-theme="dark"] .view-container { 
            border-color: #1a1a1a; 
            box-shadow: 0 0 0 2px #333, 0 0 60px rgba(255, 0, 51, 0.15); 
        }
        .dynamic-bg {
            border-radius: 45px;
        }
    }
</style>
</head>
<body data-theme="dark">

    <!-- Capas de fondo dinámico -->
    <div id="dynamic-bg-layer" class="dynamic-bg particles-bg"></div>
    <div id="grid-pattern-layer" class="dynamic-bg grid-pattern"></div>
    <div id="circuit-pattern-layer" class="dynamic-bg circuit-pattern"></div>
    <div id="crypto-waves-layer" class="dynamic-bg crypto-waves"></div>
    <div id="time-gradient-layer" class="dynamic-bg time-gradient"></div>

    <!-- Capa para efectos de partículas -->
    <div id="particles-layer" class="particles-layer"></div>
    
    <!-- Visualizador de audio -->
    <div id="audio-visualizer" class="audio-visualizer" title="Sincronización Audiovisual">
        <div id="visualizer-bars"></div>
    </div>

    <div class="view-container">
        <div id="view-calculator" class="view active">
            <header class="app-header">
				<button class="embedded-ui icon-btn btn-theme" aria-label="Cambiar Tema">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                </button>
                
                <button class="embedded-ui icon-btn icon-swap" id="btn-mute" aria-label="Silenciar">
                    <svg class="shown" id="icon-sound-on" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    <svg class="hidden" id="icon-sound-off" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>
                </button>
                               
                <a href="https://danijdzg.github.io/dani/" target="_blank" class="app-title embedded-ui">aiDANaI</a>
                
                <div id="clock" class="embedded-ui tabular-nums">0:00:00</div>
                
                <button id="btn-go-crypto" class="embedded-ui icon-btn" aria-label="Ir a Crypto">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></svg>
                </button>
            </header>
        
            <div class="upper-section">
                <div class="display-lens" id="display-container">
                    <ul id="history-list"></ul>
                    <div class="display-area">
                        <div id="secondary-display" class="tabular-nums"></div>
                        <div id="main-display" class="tabular-nums">0</div>
                    </div>
                </div>
            </div>

            <div class="calculator-body">
                <div class="keypad">
                    <button class="btn" data-key="AC">AC</button>
                    <button class="btn" data-key="Backspace">⌫</button>
                    <button class="btn" data-key="%" data-color="blue">%</button>
                    <button class="btn" data-key="/" data-color="blue">÷</button>
             
                    <button class="btn" data-key="7">7</button>
                    <button class="btn" data-key="8">8</button>
                    <button class="btn" data-key="9">9</button>
                    <button class="btn" data-key="*" data-color="blue">×</button>
             
                    <button class="btn" data-key="4">4</button>
                    <button class="btn" data-key="5">5</button>
                    <button class="btn" data-key="6">6</button>
                    <button class="btn" data-key="-" data-color="blue">−</button>
  
                    <button class="btn" data-key="1">1</button>
                    <button class="btn" data-key="2">2</button>
                    <button class="btn" data-key="3">3</button>
                    <button class="btn" data-key="+" data-color="blue">+</button>

                    <button class="btn" data-key="0">0</button>
                    <button class="btn" data-key=",">,</button>
                    <button class="btn btn-large" data-key="Enter" data-color="green">=</button>
                </div>
            </div>
        </div>

        <div id="view-crypto" class="view">
            <header class="app-header">
                <button class="embedded-ui icon-btn btn-theme" aria-label="Cambiar Tema">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                </button>
                
                <a href="https://danijdzg.github.io/dani/" target="_blank" class="app-title embedded-ui">Crypto</a>
                
                <div id="clock-crypto" class="embedded-ui tabular-nums">0:00:00</div>
                
                <button id="btn-go-calc" class="embedded-ui icon-btn" aria-label="Volver">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="2" width="16" height="20" rx="2" ry="2" stroke-width="2"></rect><line x1="8" y1="6" x2="16" y2="6" stroke-width="2"></line><line x1="16" y1="14" x2="16" y2="14" stroke-width="3"></line><line x1="12" y1="14" x2="12" y2="14" stroke-width="3"></line><line x1="8" y1="14" x2="8" y2="14" stroke-width="3"></line><line x1="16" y1="18" x2="16" y2="18" stroke-width="3"></line><line x1="12" y1="18" x2="12" y2="18" stroke-width="3"></line><line x1="8" y1="18" x2="8" y2="18" stroke-width="3"></line></svg>
                </button>
            </header>
            
            <div class="crypto-content">
                <p id="timestamp"><span class="status-dot"></span> <span id="time-text">Conectando...</span></p>
                <div class="crypto-list">
                    <div class="card glow-border" data-id="bitcoin" data-name="Bitcoin">
                        <div class="coin-details">
                            <img src="https://assets.coingecko.com/coins/images/1/large/bitcoin.png" class="coin-logo" onerror="this.style.display='none'">
                            <div class="coin-info"><h2>Bitcoin</h2><p class="change-percentage tabular-nums" id="bitcoin-change">--</p></div>
                        </div>
                        <div class="price-container"><p class="price-eur tabular-nums" id="bitcoin-price-eur">--</p><p class="price-usd tabular-nums" id="bitcoin-price-usd">--</p></div>
                    </div>
                    <div class="card glow-border" data-id="ethereum" data-name="Ethereum">
                        <div class="coin-details">
                            <img src="https://assets.coingecko.com/coins/images/279/large/ethereum.png" class="coin-logo" onerror="this.style.display='none'">
                            <div class="coin-info"><h2>Ethereum</h2><p class="change-percentage tabular-nums" id="ethereum-change">--</p></div>
                        </div>
                        <div class="price-container"><p class="price-eur tabular-nums" id="ethereum-price-eur">--</p><p class="price-usd tabular-nums" id="ethereum-price-usd">--</p></div>
                    </div>
                    <div class="card glow-border" data-id="solana" data-name="Solana">
                        <div class="coin-details">
                            <img src="https://assets.coingecko.com/coins/images/4128/large/solana.png" class="coin-logo" onerror="this.style.display='none'">
                            <div class="coin-info"><h2>Solana</h2><p class="change-percentage tabular-nums" id="solana-change">--</p></div>
                        </div>
                        <div class="price-container"><p class="price-eur tabular-nums" id="solana-price-eur">--</p><p class="price-usd tabular-nums" id="solana-price-usd">--</p></div>
                    </div>
                     <div class="card glow-border" data-id="ripple" data-name="XRP">
                        <div class="coin-details">
                            <img src="https://assets.coingecko.com/coins/images/44/large/xrp-symbol-white-128.png" class="coin-logo" onerror="this.style.display='none'">
                            <div class="coin-info"><h2>XRP</h2><p class="change-percentage tabular-nums" id="ripple-change">--</p></div>
                        </div>
                        <div class="price-container"><p class="price-eur tabular-nums" id="ripple-price-eur">--</p><p class="price-usd tabular-nums" id="ripple-price-usd">--</p></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="chart-modal">
        <div class="modal-content">
            <button class="close-chart" aria-label="Cerrar">&times;</button>
            <h2 id="chart-title" style="margin-bottom:15px; color: var(--primary-text); text-align: center;">Moneda</h2>
            
            <div class="chart-controls">
                <button class="time-btn" data-days="1">24h</button>
                <button class="time-btn" data-days="7">7D</button>
                <button class="time-btn active" data-days="30">30D</button>
                <button class="time-btn" data-days="365">1A</button>
            </div>

            <div style="position: relative; min-height: 250px;">
                <div id="loading-chart" class="loading-spinner"></div>
                <div id="chart-container"></div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <script>
        const App = {
            expr: '',
            fresh: true,
            chart: null,
            currentCoinId: null,
            escCounter: 0,
            escTimer: null,
            audioCtx: null,
            touchStartY: 0,
            pullToRefreshActive: false,
            particleCount: 0,
            maxParticles: 100,
            transitionStyles: ['flip', 'fold', 'vortex', 'glitch', 'morph'],
            currentTransition: 0,
            audioVisualizer: null,
            analyser: null,
            audioSource: null,
            animationId: null,
            lastMouseX: 0,
            lastMouseY: 0,
            backgroundMode: 'calc', // 'calc' o 'crypto'
            touchTrailInterval: null,
            chartCache: {}, // Cache mejorado para gráficos
            
            state: { 
                theme: 'dark', 
                muted: false, 
                history: [], 
                cryptoCache: null,
                lastFetchTime: 0,
                chartCache: {}, // Cache persistente
                backgroundIntensity: 0.4,
                visualizerEnabled: true
            },
            
            init() {
                this.loadState();
                this.applyTheme(this.state.theme);
                this.updateMuteIcon();
                this.initBackgroundLayers();
                this.updateBackgroundMode('calc');
                this.startTimeBasedBackground();
                
                this.bindEvents();
                this.startClocks();
                this.renderHistoryFromState(); 
                
                if(this.state.cryptoCache) this.renderCryptoData(this.state.cryptoCache, new Date(this.state.lastFetchTime));
                
                setInterval(() => this.fetchPrices(), 60000);
                this.fixHeight();
                this.initAudioContext();
                this.initAudioVisualizer();
                this.setupPullToRefresh();
                this.setupRippleEffects();
                this.setupTouchTrail();
                this.setupMouseTracking();
                
                document.body.addEventListener('touchstart', () => {
                    if (this.audioCtx && this.audioCtx.state === 'suspended') this.audioCtx.resume();
                }, { once: true });
            },

            fixHeight() {
                const doc = document.documentElement;
                const setH = () => doc.style.setProperty('--doc-height', `${window.innerHeight}px`);
                setH();
                window.addEventListener('resize', setH);
            },

            // ================= FONDOS DINÁMICOS TEMÁTICOS =================
            initBackgroundLayers() {
                // Inicializar capas de fondo
                this.updateBackgroundIntensity(this.state.backgroundIntensity);
                
                // Animar gradiente de tiempo
                this.animateTimeGradient();
                
                // Efecto de partículas en fondo
                this.createBackgroundParticles();
            },
            
            updateBackgroundMode(mode) {
                this.backgroundMode = mode;
                
                const layers = {
                    'particles': document.getElementById('dynamic-bg-layer'),
                    'grid': document.getElementById('grid-pattern-layer'),
                    'circuit': document.getElementById('circuit-pattern-layer'),
                    'crypto': document.getElementById('crypto-waves-layer'),
                    'time': document.getElementById('time-gradient-layer')
                };
                
                // Ajustar opacidades según modo
                if (mode === 'calc') {
                    layers.particles.style.opacity = '0.3';
                    layers.grid.style.opacity = '0.2';
                    layers.circuit.style.opacity = '0.4';
                    layers.crypto.style.opacity = '0';
                    layers.time.style.opacity = '0.3';
                } else { // crypto mode
                    layers.particles.style.opacity = '0.4';
                    layers.grid.style.opacity = '0.1';
                    layers.circuit.style.opacity = '0.2';
                    layers.crypto.style.opacity = '0.5';
                    layers.time.style.opacity = '0.2';
                }
            },
            
            startTimeBasedBackground() {
                const updateTimeBackground = () => {
                    const now = new Date();
                    const hours = now.getHours();
                    
                    // Colores basados en hora del día
                    let color1, color2, angle;
                    
                    if (hours >= 6 && hours < 12) {
                        // Mañana
                        color1 = this.state.theme === 'dark' ? '#0a1929' : '#87CEEB';
                        color2 = this.state.theme === 'dark' ? '#001524' : '#E0F7FA';
                        angle = '135deg';
                    } else if (hours >= 12 && hours < 18) {
                        // Tarde
                        color1 = this.state.theme === 'dark' ? '#1a0505' : '#FFB74D';
                        color2 = this.state.theme === 'dark' ? '#000000' : '#FFF3E0';
                        angle = '45deg';
                    } else if (hours >= 18 && hours < 22) {
                        // Atardecer
                        color1 = this.state.theme === 'dark' ? '#2c0618' : '#E65100';
                        color2 = this.state.theme === 'dark' ? '#000814' : '#FFCCBC';
                        angle = '225deg';
                    } else {
                        // Noche
                        color1 = this.state.theme === 'dark' ? '#000814' : '#0D47A1';
                        color2 = this.state.theme === 'dark' ? '#000000' : '#1A237E';
                        angle = '315deg';
                    }
                    
                    const timeLayer = document.getElementById('time-gradient-layer');
                    timeLayer.style.setProperty('--time-color-1', color1);
                    timeLayer.style.setProperty('--time-color-2', color2);
                    timeLayer.style.setProperty('--gradient-angle', angle);
                };
                
                updateTimeBackground();
                setInterval(updateTimeBackground, 60000); // Actualizar cada minuto
            },
            
            animateTimeGradient() {
                let angle = 135;
                const animate = () => {
                    angle = (angle + 0.1) % 360;
                    document.getElementById('time-gradient-layer').style.setProperty('--gradient-angle', `${angle}deg`);
                    requestAnimationFrame(animate);
                };
                animate();
            },
            
            createBackgroundParticles() {
                // Crear partículas de fondo estáticas
                const particlesLayer = document.getElementById('particles-layer');
                for (let i = 0; i < 30; i++) {
                    const particle = document.createElement('div');
                    const size = Math.random() * 4 + 1;
                    const x = Math.random() * 100;
                    const y = Math.random() * 100;
                    const duration = Math.random() * 20 + 10;
                    
                    particle.style.cssText = `
                        position: absolute;
                        width: ${size}px;
                        height: ${size}px;
                        background: ${this.getRandomNeonColor()};
                        border-radius: 50%;
                        left: ${x}%;
                        top: ${y}%;
                        opacity: ${Math.random() * 0.3 + 0.1};
                        filter: blur(1px);
                        animation: floatUp ${duration}s linear infinite;
                    `;
                    
                    particlesLayer.appendChild(particle);
                }
            },
            
            updateBackgroundIntensity(intensity) {
                this.state.backgroundIntensity = intensity;
                document.querySelectorAll('.dynamic-bg').forEach(layer => {
                    layer.style.opacity = intensity;
                });
                this.saveState();
            },
            
            setupMouseTracking() {
                document.addEventListener('mousemove', (e) => {
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    
                    // Actualizar gradiente radial según posición del mouse
                    const particlesLayer = document.getElementById('dynamic-bg-layer');
                    particlesLayer.style.setProperty('--mouse-x', `${e.clientX}px`);
                    particlesLayer.style.setProperty('--mouse-y', `${e.clientY}px`);
                });
                
                // Efecto de interacción con el fondo
                document.addEventListener('click', (e) => {
                    this.createBackgroundRipple(e.clientX, e.clientY);
                });
            },
            
            createBackgroundRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.style.cssText = `
                    position: fixed;
                    left: ${x}px;
                    top: ${y}px;
                    width: 0;
                    height: 0;
                    border-radius: 50%;
                    background: radial-gradient(circle, ${this.getRandomNeonColor()} 0%, transparent 70%);
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                    z-index: 998;
                    animation: pressureWave 1s ease-out forwards;
                `;
                
                document.body.appendChild(ripple);
                setTimeout(() => ripple.remove(), 1000);
            },
            
            // ================= RETROALIMENTACIÓN TÁCTIL MEJORADA =================
            setupTouchTrail() {
                let lastTouchTime = 0;
                const touchCooldown = 50; // ms
                
                document.addEventListener('touchmove', (e) => {
                    const now = Date.now();
                    if (now - lastTouchTime < touchCooldown) return;
                    lastTouchTime = now;
                    
                    const touch = e.touches[0];
                    this.createTouchTrail(touch.clientX, touch.clientY);
                }, { passive: true });
                
                document.addEventListener('mousemove', (e) => {
                    const now = Date.now();
                    if (now - lastTouchTime < touchCooldown || !e.buttons) return;
                    lastTouchTime = now;
                    
                    this.createTouchTrail(e.clientX, e.clientY);
                });
            },
            
            createTouchTrail(x, y) {
                const trail = document.createElement('div');
                trail.classList.add('touch-trail');
                
                const size = Math.random() * 15 + 5;
                const color = this.getRandomNeonColor();
                
                trail.style.cssText = `
                    width: ${size}px;
                    height: ${size}px;
                    background: ${color};
                    left: ${x}px;
                    top: ${y}px;
                    opacity: 0.7;
                `;
                
                document.getElementById('particles-layer').appendChild(trail);
                
                // Animación personalizada
                const tx = (Math.random() - 0.5) * 30;
                const ty = (Math.random() - 0.5) * 30;
                
                trail.animate([
                    { transform: 'translate(0, 0) scale(1)', opacity: 0.7 },
                    { transform: `translate(${tx}px, ${ty}px) scale(0.5)`, opacity: 0 }
                ], {
                    duration: 600,
                    easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
                }).onfinish = () => trail.remove();
            },
            
            createPressureWave(x, y, element = null) {
                const wave = document.createElement('div');
                wave.classList.add('pressure-wave-effect');
                
                const rect = element ? element.getBoundingClientRect() : { left: x, top: y, width: 0, height: 0 };
                const centerX = element ? rect.left + rect.width / 2 : x;
                const centerY = element ? rect.top + rect.height / 2 : y;
                
                wave.style.cssText = `
                    left: ${centerX}px;
                    top: ${centerY}px;
                    width: 0;
                    height: 0;
                `;
                
                document.getElementById('particles-layer').appendChild(wave);
                
                const finalSize = element ? Math.max(rect.width, rect.height) * 2 : 100;
                
                wave.animate([
                    { width: '0', height: '0', opacity: 0.7, transform: 'translate(-50%, -50%) scale(0.5)' },
                    { width: `${finalSize}px`, height: `${finalSize}px`, opacity: 0, transform: 'translate(-50%, -50%) scale(1.5)' }
                ], {
                    duration: 600,
                    easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
                }).onfinish = () => wave.remove();
            },
            
            createGlowBorder(element, duration = 1000) {
                element.classList.add('active', 'glow-border');
                setTimeout(() => {
                    element.classList.remove('active');
                    setTimeout(() => element.classList.remove('glow-border'), 300);
                }, duration);
            },
            
            applyElasticEffect(element) {
                element.classList.add('elastic-active');
                setTimeout(() => element.classList.remove('elastic-active'), 600);
            },
            
            applyBounceEffect(element) {
                element.classList.add('bounce-active');
                setTimeout(() => element.classList.remove('bounce-active'), 400);
            },
            
            applyCircuitEffect(element) {
                element.classList.add('circuit-active');
                setTimeout(() => element.classList.remove('circuit-active'), 800);
            },
            
            createRippleGlow(element) {
                element.classList.add('ripple-glow');
                setTimeout(() => element.classList.remove('ripple-glow'), 1000);
            },
            
            // ================= SINCRONIZACIÓN AUDIOVISUAL =================
            initAudioVisualizer() {
                if (!this.audioCtx || this.state.muted) return;
                
                try {
                    // Crear analizador de audio
                    this.analyser = this.audioCtx.createAnalyser();
                    this.analyser.fftSize = 256;
                    
                    // Crear fuente de audio oscilatoria para visualización
                    const oscillator = this.audioCtx.createOscillator();
                    const gainNode = this.audioCtx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.analyser);
                    this.analyser.connect(this.audioCtx.destination);
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.value = 440;
                    gainNode.gain.value = 0.01; // Muy bajo para que no se escuche
                    
                    oscillator.start();
                    this.audioSource = oscillator;
                    
                    // Crear barras del visualizador
                    this.createVisualizerBars();
                    
                    // Iniciar animación del visualizador
                    this.startVisualizer();
                    
                } catch (e) {
                    console.log('Error inicializando visualizador:', e);
                }
            },
            
            createVisualizerBars() {
                const container = document.getElementById('visualizer-bars');
                container.innerHTML = '';
                
                const barCount = 12;
                for (let i = 0; i < barCount; i++) {
                    const bar = document.createElement('div');
                    bar.classList.add('visualizer-bar');
                    bar.id = `visualizer-bar-${i}`;
                    container.appendChild(bar);
                }
            },
            
            startVisualizer() {
                if (!this.analyser || !this.state.visualizerEnabled) return;
                
                const updateVisualizer = () => {
                    if (!this.analyser || this.state.muted) {
                        this.animationId = requestAnimationFrame(updateVisualizer);
                        return;
                    }
                    
                    const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    const bars = document.querySelectorAll('.visualizer-bar');
                    bars.forEach((bar, i) => {
                        const index = Math.floor((i / bars.length) * dataArray.length);
                        const value = dataArray[index] / 255;
                        const height = Math.max(3, value * 30);
                        
                        // Sincronizar color con altura
                        let color;
                        if (height < 10) color = 'var(--neon-cyan)';
                        else if (height < 20) color = 'var(--neon-lime)';
                        else color = 'var(--neon-red)';
                        
                        bar.style.height = `${height}px`;
                        bar.style.background = color;
                        bar.style.boxShadow = `0 0 ${height}px ${color}`;
                    });
                    
                    // Sincronizar efectos visuales con audio
                    this.syncVisualEffects(dataArray);
                    
                    this.animationId = requestAnimationFrame(updateVisualizer);
                };
                
                updateVisualizer();
            },
            
            syncVisualEffects(audioData) {
                if (!this.state.visualizerEnabled) return;
                
                const avgVolume = audioData.reduce((a, b) => a + b) / audioData.length / 255;
                
                // Sincronizar intensidad de fondo con volumen
                if (avgVolume > 0.1) {
                    const intensity = 0.4 + (avgVolume * 0.3);
                    this.updateBackgroundIntensity(intensity);
                    
                    // Sincronizar efectos de partículas con frecuencias altas
                    if (audioData[100] > 200) {
                        this.createAudioParticles(avgVolume);
                    }
                }
                
                // Sincronizar brillo de elementos con ritmo
                const bass = audioData[0] / 255;
                if (bass > 0.5) {
                    this.pulseElements(bass);
                }
            },
            
            createAudioParticles(intensity) {
                const count = Math.floor(intensity * 10);
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const x = Math.random() * window.innerWidth;
                        const y = Math.random() * window.innerHeight;
                        this.createParticle(x, y, {
                            animation: 'floatUp',
                            color: this.getRandomNeonColor(),
                            size: Math.random() * 4 + 2,
                            glow: true,
                            lifetime: Math.random() * 1 + 0.5
                        });
                    }, i * 50);
                }
            },
            
            pulseElements(intensity) {
                // Hacer pulsar elementos clave al ritmo
                const elements = [
                    document.querySelector('.app-title'),
                    document.querySelector('#clock'),
                    document.querySelectorAll('.btn[data-color="green"]')[0]
                ].filter(el => el);
                
                elements.forEach(el => {
                    el.classList.add('glow-pulse');
                    setTimeout(() => el.classList.remove('glow-pulse'), 500);
                });
            },
            
            toggleVisualizer() {
                this.state.visualizerEnabled = !this.state.visualizerEnabled;
                const visualizer = document.getElementById('audio-visualizer');
                
                if (this.state.visualizerEnabled) {
                    visualizer.style.opacity = '0.7';
                    this.startVisualizer();
                    this.showToast('🎵 Sincronización Activada');
                } else {
                    visualizer.style.opacity = '0.3';
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                    this.showToast('🎵 Sincronización Desactivada');
                }
                
                this.saveState();
            },
            
            // ================= MANEJO DE CACHE MEJORADO PARA GRÁFICOS =================
            getChartCacheKey(coinId, days) {
                return `${coinId}_${days}`;
            },
            
            getCachedChartData(coinId, days) {
                const cacheKey = this.getChartCacheKey(coinId, days);
                const cached = this.state.chartCache[cacheKey];
                
                if (!cached) return null;
                
                // Verificar si la cache ha expirado (10 minutos)
                const now = Date.now();
                const cacheAge = now - cached.timestamp;
                const cacheExpired = cacheAge > 10 * 60 * 1000; // 10 minutos
                
                if (cacheExpired) {
                    delete this.state.chartCache[cacheKey];
                    this.saveState();
                    return null;
                }
                
                return cached.data;
            },
            
            setChartCache(coinId, days, data) {
                const cacheKey = this.getChartCacheKey(coinId, days);
                this.state.chartCache[cacheKey] = {
                    data: data,
                    timestamp: Date.now()
                };
                
                // Limitar tamaño del cache (máximo 20 entradas)
                const keys = Object.keys(this.state.chartCache);
                if (keys.length > 20) {
                    // Eliminar la entrada más antigua
                    let oldestKey = keys[0];
                    let oldestTime = this.state.chartCache[oldestKey].timestamp;
                    
                    keys.forEach(key => {
                        if (this.state.chartCache[key].timestamp < oldestTime) {
                            oldestKey = key;
                            oldestTime = this.state.chartCache[key].timestamp;
                        }
                    });
                    
                    delete this.state.chartCache[oldestKey];
                }
                
                this.saveState();
            },
            
            // ================= CÓDIGO EXISTENTE ACTUALIZADO =================
            bindEvents() {
                document.getElementById('btn-go-crypto').onclick = () => {
                    this.updateBackgroundMode('crypto');
                    this.switchViewWithTransition('crypto');
                };
                document.getElementById('btn-go-calc').onclick = () => {
                    this.updateBackgroundMode('calc');
                    this.switchViewWithTransition('calc');
                };
                document.getElementById('btn-mute').onclick = () => this.toggleMute();
                document.getElementById('audio-visualizer').onclick = () => this.toggleVisualizer();

                document.querySelectorAll('.btn-theme').forEach(b => b.onclick = (e) => {
                    this.applyTheme(this.state.theme === 'dark' ? 'light' : 'dark');
                    this.createRipple(e, b);
                    this.createPressureWave(e.clientX, e.clientY, b);
                    this.applyElasticEffect(b);
                    this.haptic(15);
                });

                document.querySelectorAll('.btn[data-key]').forEach(b => {
                    const key = b.dataset.key;
                    if (key === 'AC') {
                        let pressTimer;
                        let longPressTriggered = false;
                        const startPress = (e) => {
                            if(e.cancelable) e.preventDefault();
                            this.createRipple(e, b);
                            this.createPressureWave(e.clientX, e.clientY, b);
                            b.classList.add('btn-active');
                            longPressTriggered = false;
                            pressTimer = setTimeout(() => {
                                longPressTriggered = true;
                                this.clearAllHistory(); 
                            }, 800);
                        };
                        const endPress = () => {
                            clearTimeout(pressTimer);
                            b.classList.remove('btn-active');
                            if (!longPressTriggered) {
                                this.haptic(10);
                                this.handleInput('AC');
                                this.pulseDisplay();
                            }
                        };
                        b.addEventListener('pointerdown', startPress);
                        b.addEventListener('pointerup', endPress);
                        b.addEventListener('pointerleave', () => { clearTimeout(pressTimer); b.classList.remove('btn-active'); });
                    } else {
                        const press = (e) => {
                            if(e.cancelable) e.preventDefault(); 
                            this.createRipple(e, b);
                            this.createPressureWave(e.clientX, e.clientY, b);
                            this.applyBounceEffect(b);
                            this.haptic(10); 
                            b.classList.add('btn-active'); 
                            this.pulseDisplay(); 
                            this.handleInput(key);
                            
                            // Crear partículas para teclas específicas
                            if (['+', '-', '*', '/', '%', 'Enter'].includes(key)) {
                                this.createButtonParticles(e, key);
                            }
                        };
                        const release = () => b.classList.remove('btn-active');
                        b.addEventListener('pointerdown', press);
                        b.addEventListener('pointerup', release);
                        b.addEventListener('pointerleave', release);
                    }
                });

                document.addEventListener('keydown', (e) => {
                    const k = e.key === 'Enter' ? 'Enter' : e.key;
                    if (k === 'Escape') {
                        this.escCounter++;
                        clearTimeout(this.escTimer);
                        this.escTimer = setTimeout(() => { this.escCounter = 0; }, 800);
                        const btn = document.querySelector('.btn[data-key="AC"]');
                        if(btn) { 
                            btn.classList.add('btn-active'); 
                            this.createRipple({clientX: btn.getBoundingClientRect().x + 20, clientY: btn.getBoundingClientRect().y + 20}, btn);
                            setTimeout(()=>btn.classList.remove('btn-active'), 100); 
                        }
                        if (this.escCounter >= 3) { this.clearAllHistory(); this.escCounter = 0; } 
                        else { this.handleInput('AC'); }
                        return;
                    }
                    if(!/^[0-9+\-*/.,=()%]$|Enter|Backspace|Delete/.test(k)) return;
                    let vKey = k;
                    if(k==='Enter'||k==='=') vKey='Enter';
                    if(k==='Delete') vKey='AC';
                    if(k==='.') vKey=',';
                    const btn = document.querySelector(`.btn[data-key="${vKey}"]`) || document.querySelector(`.btn[data-key="${k}"]`);
                    if(btn) {
                        btn.classList.add('btn-active');
                        this.createRipple({clientX: btn.getBoundingClientRect().x + 30, clientY: btn.getBoundingClientRect().y + 30}, btn);
                        this.createPressureWave(btn.getBoundingClientRect().x + 30, btn.getBoundingClientRect().y + 30, btn);
                        this.pulseDisplay();
                        setTimeout(() => btn.classList.remove('btn-active'), 100);
                        this.handleInput(vKey === 'AC' ? 'AC' : (vKey === 'Enter' ? 'Enter' : (vKey === ',' ? ',' : k)));
                    }
                });

                const chartModal = document.getElementById('chart-modal');
                document.querySelectorAll('.card').forEach(c => {
                    c.onclick = (e) => {
                        this.createRipple(e, c);
                        this.createGlowBorder(c, 2000);
                        this.createPressureWave(e.clientX, e.clientY, c);
                        this.openChart(c.dataset.id, c.dataset.name);
                    }
                });
                document.querySelector('.close-chart').onclick = () => {
                    chartModal.classList.remove('visible');
                    if(this.chart) { this.chart.destroy(); this.chart = null; }
                };
                chartModal.onclick = (e) => { if (e.target === chartModal) document.querySelector('.close-chart').click(); };

                document.querySelectorAll('.time-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.applyBounceEffect(e.target);
                        this.updateChartData(e.target.dataset.days);
                    }
                });
            },

            // SISTEMA DE PARTÍCULAS MEJORADO
            createParticle(x, y, config = {}) {
                if (this.particleCount >= this.maxParticles) return;
                
                const particle = document.createElement('div');
                const size = config.size || Math.random() * 8 + 4;
                const color = config.color || this.getRandomNeonColor();
                const shape = config.shape || this.getRandomShape();
                const lifetime = config.lifetime || Math.random() * 1.5 + 0.5;
                
                particle.classList.add('particle', `particle-${shape}`);
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.background = color;
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                particle.style.opacity = '0.8';
                particle.style.position = 'absolute';
                
                if (config.glow) {
                    particle.style.boxShadow = `0 0 ${size * 2}px ${color}`;
                }
                
                document.getElementById('particles-layer').appendChild(particle);
                this.particleCount++;
                
                const animation = config.animation || 'floatUp';
                const animationName = this.getAnimationName(animation);
                const tx = config.tx || 0;
                const ty = config.ty || 0;
                const rot = config.rotation || 0;
                
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                particle.style.setProperty('--rot', `${rot}deg`);
                particle.style.setProperty('--start-x', `${Math.random() * 100 - 50}px`);
                particle.style.setProperty('--end-x', `${Math.random() * 100 - 50}px`);
                
                particle.style.animation = `${animationName} ${lifetime}s ease-out forwards`;
                
                particle.addEventListener('animationend', () => {
                    particle.remove();
                    this.particleCount--;
                });
                
                return particle;
            },
            
            getRandomNeonColor() {
                const colors = [
                    'var(--neon-red)', 
                    'var(--neon-cyan)', 
                    'var(--neon-lime)', 
                    'var(--neon-yellow)',
                    'var(--matrix-green)',
                    'var(--crypto-up)',
                    '#ff00ff', // magenta
                    '#00ffff'  // cyan puro
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            getRandomShape() {
                const shapes = ['circle', 'star', 'square', 'triangle', 'hexagon'];
                return shapes[Math.floor(Math.random() * shapes.length)];
            },
            
            getAnimationName(type) {
                const animations = {
                    'floatUp': 'particleFloatUp',
                    'floatDown': 'particleFloatDown',
                    'explosion': 'particleExplosion',
                    'fragmentation': 'particleFragmentation',
                    'starFall': 'particleStarFall',
                    'matrixRain': 'particleMatrixRain',
                    'confetti': 'particleConfetti'
                };
                return animations[type] || 'particleFloatUp';
            },
            
            // EFECTOS DE PARTÍCULAS POR OPERACIÓN
            createOperationParticles(operationType, x, y) {
                const displayRect = document.getElementById('display-container').getBoundingClientRect();
                const centerX = displayRect.left + displayRect.width / 2;
                const centerY = displayRect.top + displayRect.height / 2;
                
                switch(operationType) {
                    case '+':
                    case '-':
                        // Partículas ascendentes/descendentes
                        const direction = operationType === '+' ? 'floatUp' : 'floatDown';
                        for (let i = 0; i < 15; i++) {
                            setTimeout(() => {
                                const px = centerX + Math.random() * 100 - 50;
                                const py = centerY + Math.random() * 50 - 25;
                                this.createParticle(px, py, {
                                    animation: direction,
                                    color: operationType === '+' ? 'var(--crypto-up)' : 'var(--crypto-down)',
                                    size: Math.random() * 6 + 3,
                                    glow: true
                                });
                            }, i * 30);
                        }
                        break;
                        
                    case '*':
                        // Explosión radial
                        for (let i = 0; i < 25; i++) {
                            setTimeout(() => {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = Math.random() * 60;
                                const px = centerX + Math.cos(angle) * distance;
                                const py = centerY + Math.sin(angle) * distance;
                                this.createParticle(centerX, centerY, {
                                    animation: 'explosion',
                                    color: 'var(--neon-yellow)',
                                    size: Math.random() * 8 + 4,
                                    glow: true,
                                    tx: px - centerX,
                                    ty: py - centerY,
                                    rotation: Math.random() * 360
                                });
                            }, i * 20);
                        }
                        break;
                        
                    case '/':
                        // Fragmentación
                        for (let i = 0; i < 20; i++) {
                            setTimeout(() => {
                                const angle = Math.random() * Math.PI * 2;
                                const distance = 40 + Math.random() * 40;
                                const px = centerX + Math.cos(angle) * distance;
                                const py = centerY + Math.sin(angle) * distance;
                                this.createParticle(centerX, centerY, {
                                    animation: 'fragmentation',
                                    color: 'var(--neon-cyan)',
                                    size: Math.random() * 6 + 2,
                                    tx: px - centerX,
                                    ty: py - centerY,
                                    rotation: Math.random() * 720
                                });
                            }, i * 25);
                        }
                        break;
                        
                    case '%':
                        // Lluvia de estrellas
                        for (let i = 0; i < 12; i++) {
                            setTimeout(() => {
                                const px = centerX + Math.random() * 120 - 60;
                                this.createParticle(px, centerY - 50, {
                                    animation: 'starFall',
                                    shape: 'star',
                                    color: 'var(--matrix-green)',
                                    size: Math.random() * 10 + 5,
                                    glow: true
                                });
                            }, i * 40);
                        }
                        break;
                        
                    case 'Enter':
                        // Confetti de éxito
                        for (let i = 0; i < 30; i++) {
                            setTimeout(() => {
                                const px = centerX + Math.random() * 150 - 75;
                                this.createParticle(px, centerY - 30, {
                                    animation: 'confetti',
                                    shape: Math.random() > 0.5 ? 'star' : 'circle',
                                    color: this.getRandomNeonColor(),
                                    size: Math.random() * 8 + 4,
                                    tx: Math.random() * 100 - 50,
                                    glow: true
                                });
                            }, i * 20);
                        }
                        break;
                }
            },
            
            createButtonParticles(event, key) {
                const rect = event.target.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top + rect.height / 2;
                
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 40;
                        const px = x + Math.cos(angle) * distance;
                        const py = y + Math.sin(angle) * distance;
                        
                        this.createParticle(x, y, {
                            animation: 'floatUp',
                            color: this.getColorByKey(key),
                            size: Math.random() * 5 + 2,
                            glow: true,
                            tx: px - x,
                            ty: py - y
                        });
                    }, i * 30);
                }
            },
            
            getColorByKey(key) {
                const colorMap = {
                    '+': 'var(--crypto-up)',
                    '-': 'var(--crypto-down)',
                    '*': 'var(--neon-yellow)',
                    '/': 'var(--neon-cyan)',
                    '%': 'var(--matrix-green)',
                    'Enter': 'var(--neon-lime)'
                };
                return colorMap[key] || this.getRandomNeonColor();
            },
            
            // EFECTO RIPPLE (Traído de indexxx.html)
            createRipple(event, element) {
                const ripple = document.createElement('span');
                const rect = element.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                
                // Si el evento es un teclado simulado, centramos el ripple
                const x = (event.clientX ? event.clientX : rect.left + rect.width/2) - rect.left - size / 2;
                const y = (event.clientY ? event.clientY : rect.top + rect.height/2) - rect.top - size / 2;
                
                ripple.style.width = ripple.style.height = size + 'px';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                ripple.classList.add('ripple');
                
                element.appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
            },
            
            setupRippleEffects() {
                // Ya se maneja dinámicamente en los listeners
            },

            // EFECTO PARTICULAS AL GANAR MEJORADO
            createSuccessEffect() {
                const display = document.getElementById('main-display');
                const rect = display.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Confetti extravagante
                for(let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 80;
                        const px = centerX + Math.cos(angle) * distance;
                        const py = centerY + Math.sin(angle) * distance;
                        
                        this.createParticle(centerX, centerY, {
                            animation: 'explosion',
                            shape: Math.random() > 0.7 ? 'star' : 'circle',
                            color: this.getRandomNeonColor(),
                            size: Math.random() * 10 + 5,
                            glow: true,
                            tx: px - centerX,
                            ty: py - centerY,
                            rotation: Math.random() * 720,
                            lifetime: Math.random() * 1.5 + 0.8
                        });
                    }, i * 15);
                }
                
                // Efecto Matrix Rain alrededor del display
                for(let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const startX = rect.left + Math.random() * rect.width;
                        this.createParticle(startX, rect.top - 20, {
                            animation: 'matrixRain',
                            shape: 'square',
                            color: 'var(--matrix-green)',
                            size: Math.random() * 6 + 3,
                            lifetime: Math.random() * 1 + 0.5
                        });
                    }, i * 50);
                }
            },

            // TRANSICIONES ENTRE MODOS PREMIUM
            switchViewWithTransition(targetView) {
                const currentView = targetView === 'crypto' ? 'view-calculator' : 'view-crypto';
                const nextView = targetView === 'crypto' ? 'view-crypto' : 'view-calculator';
                
                // Seleccionar estilo de transición (cambia cada vez)
                const transitionStyle = this.transitionStyles[this.currentTransition];
                this.currentTransition = (this.currentTransition + 1) % this.transitionStyles.length;
                
                // Añadir sonido de transición
                if(!this.state.muted) this.playTransitionSound();
                
                // Crear partículas de transición
                this.createTransitionParticles(currentView, nextView);
                
                // Aplicar animación de transición
                const currentElement = document.getElementById(currentView);
                const nextElement = document.getElementById(nextView);
                
                // Añadir clase de transición
                currentElement.classList.add(`transition-${transitionStyle}`);
                nextElement.classList.add(`transition-${transitionStyle}`);
                
                // Esperar a que termine la animación antes de cambiar vistas
                setTimeout(() => {
                    document.querySelectorAll('.view').forEach(el => el.classList.remove('active'));
                    document.getElementById(nextView).classList.add('active');
                    
                    // Remover clases de transición después de un tiempo
                    setTimeout(() => {
                        currentElement.classList.remove(`transition-${transitionStyle}`);
                        nextElement.classList.remove(`transition-${transitionStyle}`);
                    }, 100);
                    
                    if(targetView === 'crypto') { 
                        this.fetchPrices(); 
                        this.showToast('📊 Modo Crypto Activado');
                    } else { 
                        this.showToast('🧮 Modo Calculadora Activado');
                    }
                }, transitionStyle === 'vortex' ? 500 : 600);
            },
            
            createTransitionParticles(fromViewId, toViewId) {
                const fromView = document.getElementById(fromViewId);
                const toView = document.getElementById(toViewId);
                
                if(!fromView || !toView) return;
                
                const fromRect = fromView.getBoundingClientRect();
                const toRect = toView.getBoundingClientRect();
                
                // Crear partículas que viajan de una vista a otra
                for(let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        const fromX = fromRect.left + Math.random() * fromRect.width;
                        const fromY = fromRect.top + Math.random() * fromRect.height;
                        const toX = toRect.left + Math.random() * toRect.width;
                        const toY = toRect.top + Math.random() * toRect.height;
                        
                        const particle = this.createParticle(fromX, fromY, {
                            color: this.getRandomNeonColor(),
                            size: Math.random() * 6 + 3,
                            glow: true
                        });
                        
                        // Animar partícula hacia la nueva vista
                        if(particle) {
                            particle.animate([
                                { transform: `translate(0, 0)`, opacity: 1 },
                                { transform: `translate(${toX - fromX}px, ${toY - fromY}px)`, opacity: 0 }
                            ], {
                                duration: 800,
                                easing: 'cubic-bezier(0.34, 1.56, 0.64, 1)'
                            }).onfinish = () => particle.remove();
                        }
                    }, i * 20);
                }
                
                // Efecto de desvanecimiento con partículas
                for(let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const x = fromRect.left + fromRect.width / 2 + (Math.random() - 0.5) * 100;
                        const y = fromRect.top + fromRect.height / 2 + (Math.random() - 0.5) * 100;
                        
                        this.createParticle(x, y, {
                            animation: 'explosion',
                            color: 'var(--neon-red)',
                            size: Math.random() * 8 + 4,
                            glow: true,
                            lifetime: 0.8
                        });
                    }, i * 30);
                }
            },
            
            playTransitionSound() {
                if(!this.audioCtx) return;
                
                try {
                    if(this.audioCtx.state === 'suspended') this.audioCtx.resume();
                    
                    const now = this.audioCtx.currentTime;
                    const oscillator1 = this.audioCtx.createOscillator();
                    const oscillator2 = this.audioCtx.createOscillator();
                    const gainNode = this.audioCtx.createGain();
                    
                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    gainNode.connect(this.audioCtx.destination);
                    
                    oscillator1.type = 'sine';
                    oscillator2.type = 'triangle';
                    
                    oscillator1.frequency.setValueAtTime(523.25, now);
                    oscillator1.frequency.exponentialRampToValueAtTime(1046.50, now + 0.3);
                    
                    oscillator2.frequency.setValueAtTime(659.25, now);
                    oscillator2.frequency.exponentialRampToValueAtTime(1318.51, now + 0.3);
                    
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(0.1, now + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    
                    oscillator1.start(now);
                    oscillator2.start(now);
                    oscillator1.stop(now + 0.5);
                    oscillator2.stop(now + 0.5);
                } catch(e) {
                    console.log('Error playing transition sound:', e);
                }
            },

            toggleMute() {
                this.state.muted = !this.state.muted;
                this.updateMuteIcon();
                this.saveState();
                if(!this.state.muted) {
                    this.playTone('Enter');
                    this.initAudioVisualizer();
                } else {
                    if (this.animationId) {
                        cancelAnimationFrame(this.animationId);
                        this.animationId = null;
                    }
                }
                this.showToast(this.state.muted ? 'Silencio Activado 🔇' : 'Sonido Activado 🔊');
            },

            updateMuteIcon() {
                const onIcon = document.getElementById('icon-sound-on');
                const offIcon = document.getElementById('icon-sound-off');
                if(this.state.muted) {
                    onIcon.classList.replace('shown', 'hidden');
                    offIcon.classList.replace('hidden', 'shown');
                } else {
                    offIcon.classList.replace('shown', 'hidden');
                    onIcon.classList.replace('hidden', 'shown');
                }
            },

            clearAllHistory() {
                this.state.history = []; 
                this.saveState(); 
                document.getElementById('history-list').innerHTML = '';
                this.showToast('🗑️ Historial Eliminado');
                this.haptic([50, 50, 50]); 
                this.pulseDisplay();
                
                // Efecto de partículas al limpiar historial
                const displayRect = document.getElementById('display-container').getBoundingClientRect();
                for(let i = 0; i < 40; i++) {
                    setTimeout(() => {
                        const x = displayRect.left + Math.random() * displayRect.width;
                        const y = displayRect.top + Math.random() * displayRect.height;
                        this.createParticle(x, y, {
                            animation: 'explosion',
                            color: 'var(--neon-red)',
                            size: Math.random() * 7 + 3,
                            glow: true,
                            lifetime: 1.2
                        });
                    }, i * 20);
                }
                
                this.handleInput('AC'); 
            },

            pulseDisplay() {
                const lens = document.getElementById('display-container');
                lens.classList.remove('pulse-active');
                void lens.offsetWidth; 
                lens.classList.add('pulse-active');
                setTimeout(()=>lens.classList.remove('pulse-active'), 300);
            },

            handleInput(k) {
                if(this.fresh) {
                    if(!"+-*/%".includes(k) && k !== 'Enter') { this.expr=''; }
                    this.fresh = false;
                    document.getElementById('secondary-display').classList.remove('visible');
                }
                
                // Crear partículas para operaciones especiales
                if (['+', '-', '*', '/', '%', 'Enter'].includes(k)) {
                    const displayRect = document.getElementById('display-container').getBoundingClientRect();
                    const centerX = displayRect.left + displayRect.width / 2;
                    const centerY = displayRect.top + displayRect.height / 2;
                    this.createOperationParticles(k, centerX, centerY);
                }
                
                if(k==='AC') { this.expr = ''; }
                else if(k==='Backspace') { this.expr = this.expr.toString().slice(0, -1); }
                else if(k==='Enter') { this.calculate(); }
                else if(k==='(') { this.smartParen(); }
                else if(k==='%') { this.handlePercent(); } 
                else {
                    const last = this.expr.slice(-1);
                    if (k === ',') k = '.';
                    
                    if (k === '.') {
                        const currentNum = this.expr.split(/[\+\-\*\/]/).pop();
                        if (currentNum.includes('.')) return; 
                        if (this.expr === '' || "+-*/(".includes(last)) {
                            this.expr += '0.';
                            this.render(); this.playTone(k); return;
                        }
                    }

                    if ("+-*/".includes(k) && "+-*/".includes(last)) { 
                        this.expr = this.expr.slice(0, -1) + k;
                    } else { 
                        this.expr += k; 
                    }
                }
                this.render();
                this.playTone(k);
            },

            handlePercent() {
                if (!this.expr) return;
                const operators = ['+', '-', '*', '/'];
                let lastOpIndex = -1;
                let lastOp = '';
                for (let i = this.expr.length - 1; i >= 0; i--) {
                    if (operators.includes(this.expr[i])) { lastOpIndex = i; lastOp = this.expr[i]; break; }
                }
                const match = this.expr.match(/(\d+(\.\d+)?)$/);
                if (!match) return;

                const currentVal = parseFloat(match[0]);
                let replacement = '';
                if (lastOpIndex !== -1 && (lastOp === '+' || lastOp === '-')) {
                    const baseExpr = this.expr.substring(0, lastOpIndex);
                    try {
                        const cleanBase = baseExpr.replace(/[^0-9+\-*/.]/g, ''); 
                        const baseVal = new Function('return ' + cleanBase)();
                        const percentVal = baseVal * (currentVal / 100);
                        replacement = percentVal.toString();
                    } catch (e) { replacement = (currentVal / 100).toString(); }
                } else { replacement = (currentVal / 100).toString(); }

                this.expr = this.expr.substring(0, this.expr.length - match[0].length) + replacement;
                this.fresh = false;
                this.render();
            },

            calculate() {
                if(!this.expr) return;
                try {
                    let formattedExpr = this.expr.replace(/\*/g, '×').replace(/\//g, '÷');
                    formattedExpr = formattedExpr.replace(/\d+(\.\d+)?/g, (match) => {
                        const [int, dec] = match.split('.');
                        return dec ? `${parseInt(int).toLocaleString('es-ES')},${dec}` : parseInt(int).toLocaleString('es-ES');
                    });

                    let clean = this.expr.replace(/[^0-9+\-*/().]/g, '');
                    clean = clean.replace(/([+\-*/])\1+/g, '$1'); 
                    clean = clean.replace(/\)\(/g, ')*('); 

                    if(clean.includes('/0') && !clean.match(/\/0\./)) throw new Error("DIV_ZERO");
                    const openParen = (clean.match(/\(/g)||[]).length;
                    const closeParen = (clean.match(/\)/g)||[]).length;
                    if(openParen !== closeParen) throw new Error("PAREN");

                    let res = new Function('return ' + clean)();
                    if(!isFinite(res)) throw new Error("INVALID");
                    
                    res = parseFloat(parseFloat(res).toPrecision(12)); 
                    
                    this.addToHistoryState(this.expr, res);
                    this.expr = String(res); 
                    this.fresh = true;
                    
                    const secDisp = document.getElementById('secondary-display');
                    secDisp.innerText = formattedExpr + ' =';
                    secDisp.classList.add('visible');
                    this.pulseDisplay();
                    
                    // Efecto de éxito con partículas
                    const displayRect = document.getElementById('display-container').getBoundingClientRect();
                    const centerX = displayRect.left + displayRect.width / 2;
                    const centerY = displayRect.top + displayRect.height / 2;
                    
                    // Efecto de explosión central
                    for(let i = 0; i < 25; i++) {
                        setTimeout(() => {
                            const angle = Math.random() * Math.PI * 2;
                            const distance = Math.random() * 80;
                            const px = centerX + Math.cos(angle) * distance;
                            const py = centerY + Math.sin(angle) * distance;
                            
                            this.createParticle(centerX, centerY, {
                                animation: 'explosion',
                                color: 'var(--matrix-green)',
                                size: Math.random() * 10 + 5,
                                glow: true,
                                tx: px - centerX,
                                ty: py - centerY,
                                rotation: Math.random() * 360
                            });
                        }, i * 20);
                    }
                    
                    // FEEDBACK VISUAL MEJORADO (Pop + Partículas)
                    const d = document.getElementById('main-display');
                    d.classList.remove('pop-active');
                    void d.offsetWidth;
                    d.classList.add('pop-active');
                    this.createSuccessEffect();

                } catch(e) { 
                    const dContainer = document.getElementById('display-container');
                    dContainer.classList.add('shake-active');
                    setTimeout(() => dContainer.classList.remove('shake-active'), 300);
                    
                    // Efecto de error con partículas rojas
                    const displayRect = document.getElementById('display-container').getBoundingClientRect();
                    const centerX = displayRect.left + displayRect.width / 2;
                    const centerY = displayRect.top + displayRect.height / 2;
                    
                    for(let i = 0; i < 15; i++) {
                        setTimeout(() => {
                            this.createParticle(centerX, centerY, {
                                animation: 'explosion',
                                color: 'var(--neon-red)',
                                size: Math.random() * 8 + 4,
                                glow: true,
                                lifetime: 0.8
                            });
                        }, i * 30);
                    }
                    
                    let msg = "❌ Error";
                    if(e.message === "DIV_ZERO") msg = "⚠️ División por 0";
                    else if(e.message === "PAREN") msg = "⚠️ Paréntesis ()";
                    this.showToast(msg);
                    this.haptic([50, 50, 100]);
                    
                    const d = document.getElementById('main-display');
                    const originalColor = d.style.color;
                    d.style.color = 'var(--neon-red)';
                    setTimeout(() => d.style.color = originalColor, 800);
                }
                this.render();
            },

            smartParen() {
                const o = (this.expr.match(/\(/g)||[]).length;
                const c = (this.expr.match(/\)/g)||[]).length;
                const last = this.expr.slice(-1);
                if(o > c && (/[0-9.]$/.test(last) || last===')')) this.expr += ')';
                else if(/[0-9.]$/.test(last) || last===')') this.expr += '*(';
                else this.expr += '(';
                this.render();
            },

            render() {
                const d = document.getElementById('main-display');
                if(!this.expr) { d.innerHTML = '0'; d.style.fontSize = '3.2rem'; return; }
                
                const parts = this.expr.split(/([\+\-\*\/])/);
                let h = '';
                
                document.querySelectorAll('.btn').forEach(b => b.classList.remove('op-active'));
                const lastChar = this.expr.slice(-1);
                if ("+-*/".includes(lastChar)) {
                    const opMap = {'+':'+', '-':'-', '*':'*', '/':'/'};
                    const btn = document.querySelector(`.btn[data-key="${opMap[lastChar]}"]`);
                    if(btn) btn.classList.add('op-active');
                }

                parts.forEach((p) => {
                    if(p==='') return;
                    if("+-*/".includes(p)) { 
                        const op = p.replace('*','×').replace('/','÷'); 
                        h += `<span class="token token-op" style="margin:0 2px">${op}</span>`;
                    } else {
                        if(!isNaN(parseFloat(p))) { 
                            let [int, dec] = p.split('.'); 
                            const intFormatted = int ? parseInt(int).toLocaleString('es-ES') : '';
                            const finalInt = (int === '0' || int === '') && p.startsWith('0') ? '0' : intFormatted;

                            if(dec !== undefined) {
                                h += `<span>${finalInt}<span class="small-decimal" style="opacity:0.7">,${dec}</span></span>`;
                            } else {
                                h += `<span>${finalInt}</span>`;
                            }
                        } else {
                            h += p;
                        }
                    }
                });
                d.innerHTML = h;
                const plainTextLen = d.innerText.replace(/,/g, '').length; 
                let size = 3.2;
                if (plainTextLen > 7) {
                    size = Math.max(1.25, 3.2 - ((plainTextLen - 7) * 0.20)); 
                }
                d.style.fontSize = `${size}rem`;
                requestAnimationFrame(() => d.scrollLeft = d.scrollWidth);
            },

            addToHistoryState(ex, r) {
                const item = { expr: ex, res: r, date: Date.now() };
                this.state.history.unshift(item); 
                if (this.state.history.length > 20) this.state.history.pop(); 
                this.saveState();
                this.renderHistoryItem(item, true); 
                
                // Efecto sutil al añadir al historial
                if(this.state.history.length % 3 === 0) {
                    const historyList = document.getElementById('history-list');
                    const firstItem = historyList.querySelector('li:first-child');
                    if(firstItem) {
                        const rect = firstItem.getBoundingClientRect();
                        this.createParticle(rect.right - 10, rect.top + 10, {
                            animation: 'floatUp',
                            color: 'var(--history-res-color)',
                            size: 4,
                            glow: true,
                            lifetime: 1
                        });
                    }
                }
            },

            renderHistoryFromState() {
                const list = document.getElementById('history-list');
                list.innerHTML = '';
                [...this.state.history].reverse().forEach(item => this.renderHistoryItem(item, false));
            },

            renderHistoryItem(item, isNew) {
                const li = document.createElement('li');
                const formattedRes = item.res.toLocaleString('es-ES', { maximumFractionDigits: 10 });
                let prettyExpr = item.expr.replace(/\*/g, '×').replace(/\//g, '÷');
                
                prettyExpr = prettyExpr.replace(/\d+(\.\d+)?/g, (match) => {
                    const [int, dec] = match.split('.');
                    const intFormatted = parseInt(int).toLocaleString('es-ES');
                    return dec ? `${intFormatted},${dec}` : intFormatted;
                });

                li.innerHTML = `${prettyExpr} = <b>${formattedRes}</b>`;
                li.onclick = () => { 
                    this.expr = String(item.res); 
                    this.fresh = true; 
                    this.render(); 
                    this.haptic(10);
                    
                    // Efecto al recuperar del historial
                    const rect = li.getBoundingClientRect();
                    for(let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            this.createParticle(rect.right - 5, rect.top + 15, {
                                animation: 'floatUp',
                                color: 'var(--history-res-color)',
                                size: Math.random() * 5 + 2,
                                glow: true
                            });
                        }, i * 50);
                    }
                    
                    this.showToast('✓ Recuperado');
                };
                const list = document.getElementById('history-list');
                if(isNew) list.prepend(li); else list.prepend(li); 
            },

            async fetchPrices(force = false) {
                const dot = document.querySelector('.status-dot');
                const label = document.getElementById('time-text');
                const now = Date.now();
                const cacheValid = this.state.cryptoCache && (now - this.state.lastFetchTime < 60000);
                
                if (cacheValid && !force) {
                    this.renderCryptoData(this.state.cryptoCache, new Date(this.state.lastFetchTime));
                    return;
                }
                
                document.querySelectorAll('.card').forEach(c => c.classList.add('loading'));

                try {
                    dot.className = 'status-dot'; 
                    label.innerText = "Actualizando...";

                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 8000);
                    const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana,ripple&vs_currencies=eur,usd&include_24hr_change=true', { signal: controller.signal });
                    
                    if(res.status === 429) throw new Error("Límite API");
                    if(!res.ok) throw new Error("Error API");
                    
                    const d = await res.json();
                    
                    this.state.cryptoCache = d;
                    this.state.lastFetchTime = Date.now();
                    this.saveState();
                    this.renderCryptoData(d, new Date());
                    
                    // Efecto de éxito al actualizar
                    const timestamp = document.querySelector('#timestamp');
                    if(timestamp) {
                        const rect = timestamp.getBoundingClientRect();
                        for(let i = 0; i < 8; i++) {
                            setTimeout(() => {
                                this.createParticle(rect.left + rect.width/2, rect.top + 10, {
                                    animation: 'floatUp',
                                    color: 'var(--crypto-up)',
                                    size: Math.random() * 4 + 2,
                                    glow: true
                                });
                            }, i * 60);
                        }
                    }

                } catch(e) { 
                    if (this.state.cryptoCache) {
                        this.renderCryptoData(this.state.cryptoCache, new Date(this.state.lastFetchTime));
                        dot.className = 'status-dot';
                        dot.style.backgroundColor = 'var(--neon-yellow)'; 
                        dot.style.boxShadow = '0 0 10px var(--neon-yellow)';
                        label.innerText = "Modo Offline";
                        this.showToast("⚠️ Datos guardados");
                    } else {
                        dot.className = 'status-dot error';
                        label.innerText = "Sin conexión";
                    }
                } finally {
                    document.querySelectorAll('.card').forEach(c => c.classList.remove('loading'));
                }
            },

            renderCryptoData(d, dateObj) {
                const dot = document.querySelector('.status-dot');
                const label = document.getElementById('time-text');
                const fmtEur = new Intl.NumberFormat('es-ES', {style:'currency', currency:'EUR'});
                const fmtUsd = new Intl.NumberFormat('en-US', {style:'currency', currency:'USD'});

                ['bitcoin','ethereum','solana','ripple'].forEach(id => {
                    if(d[id]) {
                        document.getElementById(`${id}-price-eur`).textContent = fmtEur.format(d[id].eur);
                        document.getElementById(`${id}-price-usd`).textContent = fmtUsd.format(d[id].usd);
                        const chg = d[id].eur_24h_change;
                        const cEl = document.getElementById(`${id}-change`);
                        cEl.innerText = (chg>0?'+':'') + chg.toFixed(2)+'%';
                        cEl.className = `change-percentage tabular-nums ${chg>=0?'change-positive':'change-negative'}`;
                        
                        // Efecto sutil en cambio positivo/negativo
                        if(Math.abs(chg) > 2) {
                            const card = document.querySelector(`.card[data-id="${id}"]`);
                            if(card) {
                                const rect = card.getBoundingClientRect();
                                const color = chg >= 0 ? 'var(--crypto-up)' : 'var(--crypto-down)';
                                for(let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        this.createParticle(rect.right - 20, rect.top + rect.height/2, {
                                            animation: chg >= 0 ? 'floatUp' : 'floatDown',
                                            color: color,
                                            size: Math.random() * 4 + 2,
                                            glow: true
                                        });
                                    }, i * 100);
                                }
                            }
                        }
                    }
                });

                const timeStr = dateObj.toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit', second: '2-digit'});
                if(label.innerText !== "Modo Offline") {
                    dot.className = 'status-dot online';
                    dot.style.backgroundColor = ''; 
                    dot.style.boxShadow = '';
                    label.innerText = `Actualizado: ${timeStr}`;
                }
            },

            async openChart(id, name) {
                this.currentCoinId = id;
                document.getElementById('chart-title').innerText = name;
                document.getElementById('chart-modal').classList.add('visible');
                document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                document.querySelector('.time-btn[data-days="30"]').classList.add('active');
                if(this.chart) { this.chart.destroy(); this.chart = null; }
                await this.initChart();
                this.updateChartData(30);
                
                // Efecto al abrir chart
                const modal = document.getElementById('chart-modal');
                const rect = modal.getBoundingClientRect();
                for(let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        this.createParticle(rect.left + rect.width/2, rect.top + 50, {
                            animation: 'explosion',
                            color: 'var(--neon-cyan)',
                            size: Math.random() * 6 + 3,
                            glow: true
                        });
                    }, i * 40);
                }
            },

            async initChart() {
                const options = {
                    series: [],
                    chart: { type: 'area', height: 250, toolbar:{show:false}, background:'transparent', animations: { enabled: true, speed: 800 } },
                    theme: { mode: this.state.theme },
                    stroke: { curve: 'smooth', width: 2 },
                    fill: { type: 'gradient', gradient: { shadeIntensity: 1, opacityFrom: 0.5, opacityTo: 0.1 } },
                    dataLabels: { enabled: false },
                    xaxis: { type: 'datetime', tooltip:{enabled:false}, axisBorder:{show:false}, labels: { show: false } },
                    yaxis: { show: true, labels: { style:{ colors:'var(--secondary-text)' }, formatter: v=>v.toLocaleString('es-ES',{maximumFractionDigits:0}) + '€' } },
                    grid: { borderColor: 'rgba(255,255,255,0.05)', strokeDashArray: 5, padding: { left: 10, right: 0 } },
                    tooltip: { theme: this.state.theme, x: { format: 'dd MMM HH:mm' } }
                };
                this.chart = new ApexCharts(document.querySelector("#chart-container"), options);
                await this.chart.render();
            },

            async updateChartData(days) {
                const spinner = document.getElementById('loading-chart');
                spinner.classList.add('active');
                
                // Intentar obtener datos de cache primero
                const cachedData = this.getCachedChartData(this.currentCoinId, days);
                
                if (cachedData) {
                    // Usar datos cacheados
                    const isPositive = cachedData[cachedData.length-1][1] >= cachedData[0][1];
                    const color = isPositive ? '#00ff9d' : '#ff0033';
                    
                    if(this.chart) {
                        this.chart.updateOptions({ colors: [color], tooltip: { theme: this.state.theme } });
                        this.chart.updateSeries([{ name: 'Precio', data: cachedData }]);
                    }
                    
                    spinner.classList.remove('active');
                    
                    // Efecto visual para datos cacheados
                    this.showToast('📈 Datos en cache');
                    const chartContainer = document.getElementById('chart-container');
                    if(chartContainer) {
                        const rect = chartContainer.getBoundingClientRect();
                        for(let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                this.createParticle(rect.left + rect.width/2, rect.top + rect.height/2, {
                                    animation: 'floatUp',
                                    color: 'var(--neon-yellow)',
                                    size: Math.random() * 4 + 2,
                                    glow: true
                                });
                            }, i * 100);
                        }
                    }
                    
                    return;
                }

                try {
                    const url = `https://api.coingecko.com/api/v3/coins/${this.currentCoinId}/market_chart?vs_currency=eur&days=${days}`;
                    const res = await fetch(url);
                    
                    if(res.status === 429) {
                        this.showToast("⚠️ Límite de API. Usando datos guardados.");
                        throw new Error("API_LIMIT");
                    }
                    
                    if(!res.ok) throw new Error("Error API");
                    
                    const data = await res.json();
                    if(!data.prices || data.prices.length === 0) throw new Error("Sin datos");

                    const isPositive = data.prices[data.prices.length-1][1] >= data.prices[0][1];
                    const color = isPositive ? '#00ff9d' : '#ff0033';

                    // Guardar en cache
                    this.setChartCache(this.currentCoinId, days, data.prices);

                    if(this.chart) {
                        this.chart.updateOptions({ colors: [color], tooltip: { theme: this.state.theme } });
                        this.chart.updateSeries([{ name: 'Precio', data: data.prices }]);
                    }
                    
                    // Efecto al cargar datos del chart
                    const chartContainer = document.getElementById('chart-container');
                    if(chartContainer) {
                        const rect = chartContainer.getBoundingClientRect();
                        for(let i = 0; i < 10; i++) {
                            setTimeout(() => {
                                this.createParticle(rect.left + rect.width/2, rect.top + rect.height/2, {
                                    animation: 'explosion',
                                    color: color,
                                    size: Math.random() * 5 + 3,
                                    glow: true
                                });
                            }, i * 50);
                        }
                    }
                    
                    this.showToast('📊 Datos actualizados');
                    
                } catch(e) { 
                    if (e.message === "API_LIMIT") {
                        // Mostrar mensaje amigable
                        this.showToast("⏳ Espera un minuto antes de intentar nuevamente");
                    } else {
                        this.showToast("❌ Error cargando gráfico");
                    }
                } 
                finally { 
                    spinner.classList.remove('active'); 
                }
            },

            switchView(v) {
                // Este método es mantenido por compatibilidad
                if (v === 'crypto') {
                    this.updateBackgroundMode('crypto');
                    this.switchViewWithTransition(v);
                } else {
                    this.updateBackgroundMode('calc');
                    this.switchViewWithTransition(v);
                }
            },
            
            applyTheme(t) {
                this.state.theme = t;
                document.body.dataset.theme = t;
                if(this.chart) this.chart.updateOptions({ theme: {mode: t}, tooltip: {theme: t} });
                this.saveState();
                
                // Efecto al cambiar tema
                const bodyRect = document.body.getBoundingClientRect();
                for(let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        this.createParticle(
                            Math.random() * bodyRect.width,
                            Math.random() * bodyRect.height,
                            {
                                animation: 'explosion',
                                color: t === 'dark' ? 'var(--neon-red)' : '#0984e3',
                                size: Math.random() * 8 + 4,
                                glow: true,
                                lifetime: 1
                            }
                        );
                    }, i * 40);
                }
            },
            
            haptic(p) { 
                if(navigator.vibrate) {
                    const d = typeof p === 'number' ? Math.min(p, 10) : p;
                    navigator.vibrate(d);
                } 
            },
            
            showToast(msg) { 
                const t = document.getElementById('toast');
                t.innerText = msg; t.classList.add('show'); 
                setTimeout(()=>t.classList.remove('show'),2000); 
            },
            
            saveState() { 
                localStorage.setItem('aidanaiUltimate', JSON.stringify(this.state)); 
            },
            
            loadState() { 
                try {
                    const s = JSON.parse(localStorage.getItem('aidanaiUltimate')); 
                    if(s) {
                        // Merge del estado, preservando nuevas propiedades
                        this.state = {...this.state, ...s};
                        
                        // Inicializar propiedades que puedan faltar en datos viejos
                        if (this.state.chartCache === undefined) this.state.chartCache = {};
                        if (this.state.backgroundIntensity === undefined) this.state.backgroundIntensity = 0.4;
                        if (this.state.visualizerEnabled === undefined) this.state.visualizerEnabled = true;
                    }
                } catch(e) {
                    console.log('Error loading state:', e);
                } 
            },
            
            startClocks() {
                const update = () => {
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('es-ES', {hour:'numeric', minute:'2-digit', second:'2-digit'});
                    document.querySelectorAll('#clock, #clock-crypto').forEach(e => e.innerText = timeStr);
                };
                update(); setInterval(update, 1000);
            },
            
            initAudioContext() {
                try { 
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)(); 
                } catch(e) { 
                    this.audioCtx = null; 
                }
            },
            
            // AUDIO SINTETIZADO (Afinación Ultimate Suite)
            playTone(key) {
                if(this.state.muted || !this.audioCtx) return;
                try {
                    if(this.audioCtx.state === 'suspended') this.audioCtx.resume();
                    const osc = this.audioCtx.createOscillator();
                    const gain = this.audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(this.audioCtx.destination);
                    osc.type = 'sine';
                    const frequencies = { 'Enter': 880, 'AC': 440, 'Backspace': 392, '%': 523.25, '+': 659.25, '-': 587.33, '*': 698.46, '/': 783.99, 'default': 1046.50 };
                    osc.frequency.value = frequencies[key] || frequencies.default;
                    const now = this.audioCtx.currentTime;
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.15, now + 0.002);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
                    osc.start(now);
                    osc.stop(now + 0.07);
                } catch(e) {}
            },
            
            setupPullToRefresh() {
                const cryptoContent = document.querySelector('.crypto-content');
                if(!cryptoContent) return;
                
                cryptoContent.addEventListener('touchstart', (e) => {
                    if(cryptoContent.scrollTop === 0) this.touchStartY = e.touches[0].clientY;
                }, { passive: true });
                
                cryptoContent.addEventListener('touchmove', (e) => {
                    if(this.touchStartY && !this.pullToRefreshActive) {
                        const pullDistance = e.touches[0].clientY - this.touchStartY;
                        if(pullDistance > 100 && cryptoContent.scrollTop === 0) {
                            this.pullToRefreshActive = true;
                            this.showToast('🔄 Actualizando...');
                            this.fetchPrices(true);
                            this.haptic(20);
                            
                            // Efecto visual al hacer pull to refresh
                            const timestamp = document.querySelector('#timestamp');
                            if(timestamp) {
                                const rect = timestamp.getBoundingClientRect();
                                for(let i = 0; i < 12; i++) {
                                    setTimeout(() => {
                                        this.createParticle(rect.left + rect.width/2, rect.top + 5, {
                                            animation: 'floatUp',
                                            color: 'var(--neon-cyan)',
                                            size: Math.random() * 5 + 3,
                                            glow: true
                                        });
                                    }, i * 50);
                                }
                            }
                            
                            setTimeout(() => { this.touchStartY = 0; this.pullToRefreshActive = false; }, 1000);
                        }
                    }
                }, { passive: true });
                cryptoContent.addEventListener('touchend', () => { this.touchStartY = 0; }, { passive: true });
            }
        };
        
        // Limpiar partículas periódicamente para evitar acumulación
        setInterval(() => {
            const particles = document.querySelectorAll('.particle');
            if(particles.length > 100) {
                for(let i = 0; i < particles.length - 80; i++) {
                    particles[i].remove();
                    App.particleCount--;
                }
            }
        }, 5000);
        
        App.init();
    </script>
</body>
</html>
