import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
import { getFirestore, enableIndexedDbPersistence, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

// --- CONFIGURACIÓN REQUERIDA ---
const GOOGLE_CLIENT_ID = '364074046164-bb80vb1bodaaj7rc2i9e7520l9hp8klo.apps.googleusercontent.com';
const GOOGLE_API_KEY = 'AIzaSyD_EI1odi7jWdv7vSGkc58KCoSOJedt8uY';
const firebaseConfig = { apiKey: "AIzaSyAp-t-2qmbvSX-QEBW9B1aAJHBESqnXy9M", authDomain: "cuentas-aidanai.firebaseapp.com", projectId: "cuentas-aidanai", storageBucket: "cuentas-aidanai.appspot.com", messagingSenderId: "58244686591", appId: "1:58244686591:web:85c87256c2287d350322ca" };

const CONSTANTS = { VIEWS: { TODAY: 'today', CALENDAR: 'calendar', TASKS: 'tasks', HELP: 'help', SEARCH: 'search' }, ITEM_TYPES: { AGENDA: 'agenda', TASK: 'task' }, ANIMATION_CLASSES: { ITEM_ENTERING: 'item-entering', ITEM_EXITING: 'item-exiting' } };
const THEMES = { 'cyberpunk-night': { name: 'Cyberpunk Night', bg: '#000000', color: '#00E5FF' }, 'midnight-plum': { name: 'Midnight Plum', bg: '#191724', color: '#C39DFF' }, 'evergreen': { name: 'Evergreen', bg: '#232A2E', color: '#37EFCB' }, 'paperwhite': { name: 'Paperwhite', bg: '#FBFBFB', color: '#005A9C' }, 'coral-sunset': { name: 'Coral Sunset', bg: '#FFF6F0', color: '#FF6B6B' }, 'ocean-breeze': { name: 'Ocean Breeze', bg: '#EFFBFF', color: '#0096C7' } };
const THEME_CYCLE_ORDER = ['cyberpunk-night', 'midnight-plum', 'evergreen', 'paperwhite', 'coral-sunset', 'ocean-breeze'];
const GOOGLE_DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest"];
const GOOGLE_SCOPES = "https://www.googleapis.com/auth/calendar.events";
const MESES = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
const MESES_CORTOS = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
const DIAS_SEMANA_LARGOS = ['lunes', 'martes', 'miércoles', 'jueves', 'viernes', 'sábado', 'domingo'];
const DIAS_SEMANA_CORTOS = ['Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb', 'Dom'];
const VIEW_ORDER = ['today', 'calendar', 'tasks', 'help'];

let appState = { currentView: 'today', lastView: 'today', calendar: { currentMonth: new Date().getMonth(), currentYear: new Date().getFullYear(), selectedDate: dateToYYYYMMDD(new Date()), displayMode: 'month' }, tasks: { selectedListId: 'default' } };
let flatpickrInstance = null, currentUser = null, unsubscribeFromDb = null, saveTimeout = null;
let db = {}; let activeTimers = {}; let newlyCreatedItemId = null; let originalButtonTexts = new Map();
let isGoogleSignedIn = false, isAppInitialized = false, isViewSwitching = false, isSyncingWithGoogle = false;
let isTutorialReady = false;

const gebi = id => document.getElementById(id);
const qsa = selector => document.querySelectorAll(selector);
function dateToYYYYMMDD(date) { if (!date || isNaN(date.getTime())) return ''; return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`; }
function dateToHHMM(date) { if (!date || isNaN(date.getTime())) return "00:00"; return `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`; }
function yyyymmddToDate(dateStr) { if (!dateStr) return new Date(); const parts = dateStr.split('-'); return new Date(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1, parseInt(parts[2], 10)); }
function uuid() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
function triggerHapticFeedback(type = 'light') { if ('vibrate' in navigator) { switch (type) { case 'light': navigator.vibrate(10); break; case 'medium': navigator.vibrate(40); break; case 'success': navigator.vibrate([20, 50, 20]); break; default: navigator.vibrate(10); } } }
function debounce(func, delay = 250) { let timeout; return (...args) => { clearTimeout(timeout); timeout = setTimeout(() => { func.apply(this, args); }, delay); }; }
function showToast(message, isError = false) { const container = gebi('toast-container'); if (!container) return; const toast = document.createElement('div'); toast.className = 'toast'; if (isError) { toast.style.backgroundColor = 'var(--accent-delete)'; } toast.textContent = message; container.appendChild(toast); setTimeout(() => toast.remove(), 3000); }
const setButtonLoading = (btn, isLoading, text = 'Cargando...') => { if (!btn) return; if (isLoading) { if (!originalButtonTexts.has(btn)) { originalButtonTexts.set(btn, btn.innerHTML); } btn.disabled = true; btn.classList.add('btn--loading'); btn.innerHTML = `<span class="spinner"></span> <span>${text}</span>`; } else { btn.disabled = false; btn.classList.remove('btn--loading'); if (originalButtonTexts.has(btn)) { btn.innerHTML = originalButtonTexts.get(btn); originalButtonTexts.delete(btn); } } };
const displayError = (elementId, message) => { const errorElement = gebi(`${elementId}-error`); if (errorElement) { errorElement.textContent = message; } const inputElement = gebi(elementId); if (inputElement) { inputElement.classList.add('form-input--invalid'); } };
const clearAllErrors = (formId) => { const form = gebi(formId); if (!form) return; form.querySelectorAll('.form-error').forEach(el => el.textContent = ''); form.querySelectorAll('.form-input--invalid').forEach(el => el.classList.remove('form-input--invalid')); const generalErrorEl = gebi('login-error'); if(generalErrorEl) generalErrorEl.textContent = ''; };

const app = initializeApp(firebaseConfig);
const fbAuth = getAuth(app);
const fbDb = getFirestore(app);
setPersistence(fbAuth, browserLocalPersistence);
enableIndexedDbPersistence(fbDb).catch(err => { if (err.code == 'failed-precondition') { console.warn("Persistencia offline falló: Múltiples pestañas abiertas."); } else if (err.code == 'unimplemented') { console.warn("Persistencia offline no soportada en este navegador."); } });
const getInitialDb = () => ({ items: [], taskLists: [{ id: 'default', name: 'General' }], config: { theme: 'cyberpunk-night', tutorialCompleted: false, googleSyncToken: null } });
const saveData = () => new Promise((resolve, reject) => { if (!currentUser) { return reject(new Error("Usuario no autenticado. No se puede guardar.")); } clearTimeout(saveTimeout); saveTimeout = setTimeout(() => { const userDocRef = doc(fbDb, 'users', currentUser.uid); setDoc(userDocRef, { db }).then(() => { console.log("Sincronización con Firebase exitosa."); resolve(); }).catch(error => { console.error("Error al guardar en Firestore:", error); reject(error); }); }, 500); });
const loadData = (uid) => { const userDocRef = doc(fbDb, 'users', uid); if (unsubscribeFromDb) { unsubscribeFromDb(); } unsubscribeFromDb = onSnapshot(userDocRef, docSnapshot => { let needsInitialSave = false; if (docSnapshot.exists() && docSnapshot.data().db) { db = docSnapshot.data().db; if (!db.items) { db.items = []; needsInitialSave = true; } if (!db.config || !db.config.theme) { db.config = { theme: 'cyberpunk-night', tutorialCompleted: false, googleSyncToken: null, ...db.config }; needsInitialSave = true; } if (db.config.tutorialCompleted === undefined) { db.config.tutorialCompleted = false; needsInitialSave = true; } if (db.config.googleSyncToken === undefined) { db.config.googleSyncToken = null; needsInitialSave = true;} if (!db.taskLists || db.taskLists.length === 0) { db.taskLists = [{ id: 'default', name: 'General' }]; needsInitialSave = true; } } else { db = getInitialDb(); needsInitialSave = true; } if (needsInitialSave && currentUser) { saveData().catch(err => showToast("No se pudo guardar la configuración inicial.", true)); } if (!isAppInitialized) { startMainApp(); } renderApp(); }, error => { console.error("Error de conexión con Firestore:", error); showToast("Error de conexión con la base de datos.", true); }); };

function applyTheme(theme) { document.documentElement.setAttribute('data-theme', theme); localStorage.setItem('theme', theme); }
function handleThemeChange(newTheme, toastMessage) { db.config.theme = newTheme; applyTheme(newTheme); saveData().catch(err => showToast("No se pudo guardar el tema.", true)); triggerHapticFeedback('light'); if (toastMessage) showToast(toastMessage); }
function handleThemeToggle() { const currentTheme = document.documentElement.getAttribute('data-theme') || THEME_CYCLE_ORDER[0]; const currentIndex = THEME_CYCLE_ORDER.indexOf(currentTheme); const nextIndex = (currentIndex + 1) % THEME_CYCLE_ORDER.length; const newTheme = THEME_CYCLE_ORDER[nextIndex]; handleThemeChange(newTheme, `Tema: ${THEMES[newTheme].name}`); }
function renderThemeSelector() { const container = gebi('theme-selector'); if (!container) return; container.innerHTML = Object.entries(THEMES).map(([id, theme]) => `<button class="theme-option" data-theme="${id}" style="background-color: ${theme.bg}; color: ${theme.color}; border: 2px solid ${theme.color}; padding: 16px 8px; border-radius: 12px; font-weight: 500; cursor: pointer; text-align: center; transition: all 0.2s;">${theme.name}</button>`).join(''); container.querySelectorAll('.theme-option').forEach(btn => { btn.addEventListener('click', () => { handleThemeChange(btn.dataset.theme, `Tema '${THEMES[btn.dataset.theme].name}' aplicado.`); }); }); }

function initApp() { 
    const welcomeScreen = gebi('welcomeScreen'); 
    const welcomeImage = gebi('welcomeImage'); 
    welcomeScreen.classList.add('visible'); 
    welcomeImage.addEventListener('animationend', () => { 
        welcomeScreen.style.opacity = '0'; 
        welcomeScreen.addEventListener('transitionend', () => { 
            welcomeScreen.style.display = 'none'; 
            checkAuthState(); 
        }, { once: true }); 
    }, { once: true }); 
    
    attachGlobalEventListeners(); 
    initializeDatePicker(); 
    updateSyncStatus(); 
    
    loadGisScript();
    loadGapiScript();

    // NUEVO: Lógica mejorada de registro del Service Worker y escucha de mensajes
    if ('serviceWorker' in navigator) { 
        window.addEventListener('load', () => { 
            navigator.serviceWorker.register('./service-worker.js')
                .then(reg => console.log('Service Worker registrado con éxito:', reg))
                .catch(err => console.log('Error en el registro del Service Worker:', err)); 
        }); 

        // NUEVO: Escucha mensajes del Service Worker para ejecutar la sincronización en segundo plano.
        navigator.serviceWorker.addEventListener('message', event => {
            if (event.data && event.data.type === 'EXECUTE_GOOGLE_SYNC') {
                console.log('Recibido disparador de sincronización desde el Service Worker. Iniciando...');
                // Nos aseguramos de tener los datos más recientes antes de sincronizar
                if (currentUser) {
                    syncWithGoogleCalendar();
                }
            }
        });
    }
}
const checkAuthState = () => onAuthStateChanged(fbAuth, user => { if (user) { currentUser = user; loadData(user.uid); } else { currentUser = null; isAppInitialized = false; if (unsubscribeFromDb) unsubscribeFromDb(); db = getInitialDb(); showLoginScreen(); } });
const startMainApp = () => { if (isAppInitialized) return; isAppInitialized = true; applyTheme(db.config.theme || 'cyberpunk-night'); gebi('login-screen').classList.remove('login-view--visible'); const appRoot = gebi('app-root'); appRoot.classList.add('visible'); updateNav(appState.currentView); appRoot.querySelector('.view.active')?.classList.remove('active'); appRoot.querySelector(`#${appState.currentView}View`).classList.add('active'); renderThemeSelector(); scheduleAllNotifications(); if (!db.config.tutorialCompleted && isTutorialReady) { startOnboardingTutorial(); } };
const showLoginScreen = () => { applyTheme(localStorage.getItem('theme') || 'cyberpunk-night'); gebi('app-root').classList.remove('visible'); gebi('login-screen').classList.add('login-view--visible'); const emailInput = gebi('login-email'); const passwordInput = gebi('login-password'); if (emailInput) emailInput.value = ''; if (passwordInput) passwordInput.value = ''; clearAllErrors('login-form'); };
const handleAuthError = (error, submitterBtn) => { clearAllErrors('login-form'); setButtonLoading(submitterBtn, false); triggerHapticFeedback('medium'); const loginErrorEl = gebi('login-error'); switch (error.code) { case 'auth/user-not-found': case 'auth/wrong-password': case 'auth/invalid-credential': loginErrorEl.textContent = 'Error: Credenciales incorrectas.'; displayError('login-email', ''); displayError('login-password', ''); break; case 'auth/invalid-email': displayError('login-email', 'Formato de correo no válido.'); break; case 'auth/email-already-in-use': displayError('login-email', 'El correo ya está registrado.'); break; case 'auth/weak-password': displayError('login-password', 'La contraseña debe tener al menos 6 caracteres.'); break; default: loginErrorEl.textContent = 'Ocurrió un error. Inténtalo de nuevo.'; console.error("Error de autenticación no manejado:", error); break; } };
const handleLogin = async (btn) => { clearAllErrors('login-form'); const email = (gebi('login-email')).value.trim(); const password = (gebi('login-password')).value; let isValid = true; if (!email) { displayError('login-email', 'El correo es obligatorio.'); isValid = false; } if (!password) { displayError('login-password', 'La contraseña es obligatoria.'); isValid = false; } if (!isValid) { triggerHapticFeedback('error'); gebi('login-error').textContent = 'Por favor, revisa los campos marcados.'; return; } setButtonLoading(btn, true, 'Iniciando...'); try { await signInWithEmailAndPassword(fbAuth, email, password); showToast(`¡Bienvenido/a de nuevo!`); } catch (error) { handleAuthError(error, btn); } finally { setButtonLoading(btn, false); } };
const handleRegister = async (btn) => { clearAllErrors('login-form'); const email = (gebi('login-email')).value.trim(); const password = (gebi('login-password')).value; let isValid = true; if (!email) { displayError('login-email', 'El correo es obligatorio.'); isValid = false; } if (password.length < 6) { displayError('login-password', 'La contraseña debe tener al menos 6 caracteres.'); isValid = false; } if (!isValid) { triggerHapticFeedback('error'); gebi('login-error').textContent = 'Por favor, revisa los campos marcados.'; return; } setButtonLoading(btn, true, 'Registrando...'); try { await createUserWithEmailAndPassword(fbAuth, email, password); showToast(`¡Registro completado!`); } catch (error) { handleAuthError(error, btn); } };

function renderApp() { if (!db || !currentUser || !isAppInitialized) return; updateNav(appState.currentView); renderCurrentView(); }
function renderCurrentView() { const { currentView } = appState; if (currentView === 'today') renderTodayView(); if (currentView === 'calendar') renderCalendarView(); if (currentView === 'tasks') renderTaskListView(); if (currentView === 'search') renderSearchView(gebi('search-input').value); }
function updateNav(currentView) { qsa('.nav-item[data-view]').forEach(item => { item.classList.toggle('active', item.dataset.view === currentView); }); }
function renderTodayView() { const hours = new Date().getHours(); const greeting = hours < 12 ? "Buenos días" : hours < 20 ? "Buenas tardes" : "Buenas noches"; gebi('today-greeting').textContent = greeting; const todayStart = new Date(); todayStart.setHours(0, 0, 0, 0); const todayEnd = new Date(); todayEnd.setHours(23, 59, 59, 999); const tomorrowStart = new Date(todayStart); tomorrowStart.setDate(tomorrowStart.getDate() + 1); const tomorrowEnd = new Date(todayEnd); tomorrowEnd.setDate(tomorrowEnd.getDate() + 1); const todayEvents = db.items.filter(i => !i.isDeleted && i.type === 'agenda' && !i.isComplete && i.dueDate && new Date(i.dueDate) >= todayStart && new Date(i.dueDate) <= todayEnd).sort((a,b) => new Date(a.dueDate) - new Date(b.dueDate)); const pendingTasks = db.items.filter(i => !i.isDeleted && i.type === 'task' && !i.isComplete).sort((a,b) => a.createdAt - b.createdAt); const tomorrowEvents = db.items.filter(i => !i.isDeleted && i.type === 'agenda' && !i.isComplete && i.dueDate && new Date(i.dueDate) >= tomorrowStart && new Date(i.dueDate) <= tomorrowEnd).sort((a,b) => new Date(a.dueDate) - new Date(b.dueDate)); const renderListWithEmptyState = (containerId, emptyStateId, titleId, items) => { const container = gebi(containerId); const emptyState = gebi(emptyStateId); const title = gebi(titleId); container.innerHTML = ''; if (items.length > 0) { items.forEach(item => container.appendChild(createUniversalListItemNode(item))); emptyState.style.display = 'none'; title.style.display = 'flex'; } else { emptyState.style.display = 'block'; title.style.display = 'none'; } }; renderListWithEmptyState('today-events-list', 'empty-today-events', 'today-events-title', todayEvents); renderListWithEmptyState('today-tasks-list', 'empty-today-tasks', 'today-tasks-title', pendingTasks); renderListWithEmptyState('tomorrow-events-list', 'empty-tomorrow-events', 'tomorrow-events-title', tomorrowEvents); }
function renderCalendarView() { const { calendar } = appState; const { items } = db; const { currentMonth, currentYear, selectedDate, displayMode } = calendar; gebi('calendar-title-btn').textContent = `${MESES_CORTOS[currentMonth]} ${currentYear}`; gebi('calendarView').dataset.displayMode = displayMode; qsa('.view-toggle .btn-toggle').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === displayMode)); if (displayMode === 'month') { renderMonthGrid(currentMonth, currentYear, selectedDate, items); renderAgendaFromSelectedDay(items, selectedDate); } else { renderWeekGrid(currentMonth, currentYear, selectedDate, items); } }
function renderMonthGrid(currentMonth, currentYear, selectedDate, items) { const weekdaysContainer = gebi('calendarWeekdays'); if (weekdaysContainer.innerHTML.length < 5) { weekdaysContainer.innerHTML = DIAS_SEMANA_CORTOS.map((day) => `<div class="weekday">${day}</div>`).join(''); } const calendarDays = gebi('calendarDays'); calendarDays.innerHTML = ''; const firstDayOfMonth = new Date(currentYear, currentMonth, 1); const offset = (firstDayOfMonth.getDay() + 6) % 7; const startDate = new Date(firstDayOfMonth); startDate.setDate(startDate.getDate() - offset); const todayStr = dateToYYYYMMDD(new Date()); const dailyEventMarkers = new Map(); items.filter(it => !it.isDeleted && it.type === 'agenda' && it.dueDate && !it.isComplete).forEach(it => { const dateStr = dateToYYYYMMDD(new Date(it.dueDate)); if (!dailyEventMarkers.has(dateStr)) dailyEventMarkers.set(dateStr, { hasImportant: false, hasNormal: false }); const marker = dailyEventMarkers.get(dateStr); if (it.isImportant) marker.hasImportant = true; else marker.hasNormal = true; }); for (let i = 0; i < 42; i++) { const cellDate = new Date(startDate); cellDate.setDate(startDate.getDate() + i); const dateStr = dateToYYYYMMDD(cellDate); const dayEl = document.createElement('div'); dayEl.className = 'calendar-day'; dayEl.dataset.date = dateStr; if (cellDate.getMonth() !== currentMonth) { dayEl.classList.add('other-month'); } if (dateStr === todayStr) { dayEl.classList.add('today'); } if (dateStr === selectedDate) { dayEl.classList.add('selected'); } let dotsHtml = ''; if (dailyEventMarkers.has(dateStr)) { const markers = dailyEventMarkers.get(dateStr); dotsHtml = `<div class="event-dots-container">${markers.hasImportant ? '<span class="event-dot important"></span>' : ''}${markers.hasNormal ? '<span class="event-dot normal"></span>' : ''}</div>`; } dayEl.innerHTML = `<span class="day-number">${cellDate.getDate()}</span>${dotsHtml}`; dayEl.dataset.action = 'selectDate'; calendarDays.appendChild(dayEl); } }
function renderWeekGrid(currentMonth, currentYear, selectedDateStr, items) { const weeklyViewContainer = gebi('weekly-view-container'); weeklyViewContainer.innerHTML = ''; const selectedDate = yyyymmddToDate(selectedDateStr); const startOfWeek = new Date(selectedDate); startOfWeek.setDate(selectedDate.getDate() - ((selectedDate.getDay() + 6) % 7)); for (let i = 0; i < 7; i++) { const day = new Date(startOfWeek); day.setDate(startOfWeek.getDate() + i); const dayStr = dateToYYYYMMDD(day); const eventsForDay = items.filter(item => !item.isDeleted && item.type === 'agenda' && !item.isComplete && item.dueDate && dateToYYYYMMDD(new Date(item.dueDate)) === dayStr ).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate)); const daySection = document.createElement('div'); daySection.className = 'weekly-day-section'; daySection.innerHTML = ` <div class="weekly-day-header"> <span class="material-icons">${dayStr === dateToYYYYMMDD(new Date()) ? 'today' : 'event'}</span> ${DIAS_SEMANA_LARGOS[day.getDay() === 0 ? 6 : day.getDay() - 1]} ${day.getDate()} de ${MESES[day.getMonth()]} </div> <div class="weekly-day-events" id="weekly-events-${dayStr}"></div> `; weeklyViewContainer.appendChild(daySection); const eventsListContainer = gebi(`weekly-events-${dayStr}`); if (eventsForDay.length > 0) { eventsForDay.forEach(item => eventsListContainer.appendChild(createUniversalListItemNode(item))); } else { eventsListContainer.innerHTML = `<div class="empty-state"><p>Nada programado.</p></div>`; } } }
function renderAgendaFromSelectedDay(items, selectedDateStr) { const agendaList = gebi('agendaList'); agendaList.innerHTML = ''; if (!selectedDateStr) return; const selectedDate = yyyymmddToDate(selectedDateStr); selectedDate.setHours(0, 0, 0, 0); const itemsForDayAndBeyond = items.filter(item => !item.isDeleted && item.type === 'agenda' && !item.isComplete && item.dueDate && new Date(item.dueDate) >= selectedDate ).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate)); if (itemsForDayAndBeyond.length === 0) { agendaList.innerHTML = `<div class="empty-state" style="padding-top: 24px;"><span class="material-icons">event_available</span><div>Nada programado a partir de este día.</div></div>`; return; } let lastHeaderDate = null; itemsForDayAndBeyond.forEach(item => { const itemDate = new Date(item.dueDate); const itemDateStr = dateToYYYYMMDD(itemDate); if (itemDateStr !== lastHeaderDate) { const header = document.createElement('div'); header.className = 'agenda-date-header'; header.textContent = itemDate.toLocaleDateString('es-ES', { weekday: 'long', day: 'numeric', month: 'long' }); agendaList.appendChild(header); lastHeaderDate = itemDateStr; } agendaList.appendChild(createUniversalListItemNode(item)); }); }
function renderTaskListView() { const filter = gebi('task-list-filter'); filter.innerHTML = db.taskLists.map(list => `<option value="${list.id}">${list.name}</option>`).join(''); filter.value = appState.tasks.selectedListId; const tasksContainer = gebi('tasks-content'); tasksContainer.innerHTML = ''; const listId = appState.tasks.selectedListId; const pendingTasks = db.items.filter(i => !i.isDeleted && i.type === 'task' && !i.isComplete && (i.listId || 'default') === listId).sort((a, b) => a.createdAt - b.createdAt); const completedTasks = db.items.filter(i => !i.isDeleted && i.type === 'task' && i.isComplete && (i.listId || 'default') === listId).sort((a, b) => (b.completedAt || 0) - (a.completedAt || 0)); if (pendingTasks.length > 0) { const title = document.createElement('h3'); title.className = 'section-title'; title.textContent = 'Tareas Pendientes'; tasksContainer.appendChild(title); pendingTasks.forEach(item => tasksContainer.appendChild(createUniversalListItemNode(item))); } if (completedTasks.length > 0) { const details = document.createElement('details'); details.className = 'completed-tasks-section'; const summary = document.createElement('summary'); summary.innerHTML = `<h3 class="section-title">Tareas Completadas (${completedTasks.length})</h3><span class="material-icons">expand_more</span>`; const completedList = document.createElement('div'); completedList.className = 'completed-tasks-list'; completedTasks.slice(0, 20).forEach(item => completedList.appendChild(createUniversalListItemNode(item))); details.appendChild(summary); details.appendChild(completedList); tasksContainer.appendChild(details); } const isAllEmpty = pendingTasks.length === 0 && completedTasks.length === 0; gebi('emptyTasks').style.display = isAllEmpty ? 'block' : 'none'; }
function renderSearchView(query) { const resultsList = gebi('searchResultsList'); resultsList.innerHTML = ''; const emptyState = gebi('emptySearch'); const lowerCaseQuery = query.toLowerCase(); const results = db.items.filter(item => !item.isDeleted && item.description.toLowerCase().includes(lowerCaseQuery)); if (results.length > 0) { emptyState.style.display = 'none'; results.sort((a,b) => (a.createdAt < b.createdAt) ? 1 : -1).forEach(item => resultsList.appendChild(createUniversalListItemNode(item))); } else { emptyState.style.display = 'block'; } }
function createUniversalListItemNode(item) { const node = item.type === 'task' ? createTaskItemNode(item) : createEventItemNode(item); if (newlyCreatedItemId && item.localId === newlyCreatedItemId) { node.classList.add(CONSTANTS.ANIMATION_CLASSES.ITEM_ENTERING); node.addEventListener('animationend', () => { node.classList.remove(CONSTANTS.ANIMATION_CLASSES.ITEM_ENTERING); }, { once: true }); newlyCreatedItemId = null; } return node; }
function createEventItemNode(item) { const itemEl = document.createElement('div'); itemEl.className = `list-item-swipe-container type-agenda ${item.isComplete ? 'completed' : ''}`; itemEl.dataset.id = item.localId; const itemColor = item.isImportant ? 'var(--accent-event-important)' : 'var(--accent-event-normal)'; itemEl.style.borderLeftColor = itemColor; const time = item.isAllDay ? 'Todo el día' : (item.dueDate ? dateToHHMM(new Date(item.dueDate)) : ''); const hasGoogleId = !!item.googleCalendarEventId; const syncStatusIconHtml = hasGoogleId ? `<span class="material-icons event-meta-icon google-cal-icon" title="Sincronizado con Google Calendar">event_available</span>` : `<span class="material-icons event-meta-icon aidanai-only-icon" title="Guardado solo en aiDANaI (no en Google Calendar)">cloud_done</span>`; itemEl.innerHTML = ` <div class="item-card-swipe-background"><span class="material-icons">check_circle</span><span class="material-icons">delete</span></div> <div class="item-icon"><span class="material-icons" style="color: ${itemColor};">event</span></div> <div class="item-content" data-action="edit-item"> <div class="item-title">${item.description}</div> <div class="item-metadata-container"> <span class="event-time">${time}</span> ${syncStatusIconHtml} ${item.recurrenceRule !== 'none' ? '<span class="material-icons event-meta-icon">repeat</span>' : ''} </div> </div> `; attachSwipeListeners(itemEl); return itemEl; }
function createTaskItemNode(item) { const itemEl = document.createElement('div'); itemEl.dataset.id = item.localId; itemEl.className = `list-item-swipe-container type-task ${item.isComplete ? 'completed' : ''}`; itemEl.style.borderLeftColor = 'var(--accent-task)'; let progressHtml = ''; if (item.subtasks && item.subtasks.length > 0) { const completedCount = item.subtasks.filter(st => st.isComplete).length; const progressPercent = (completedCount / item.subtasks.length) * 100; const subtasksListViewHtml = item.subtasks.map(st => ` <div class="subtask-list-view-item ${st.isComplete ? 'completed' : ''}" data-action="toggle-subtask" data-task-id="${item.localId}" data-subtask-id="${st.id}"> <span class="material-icons">${st.isComplete ? 'check_circle' : 'radio_button_unchecked'}</span> <span>${st.description}</span> </div> `).join(''); progressHtml = ` <div class="task-progress-container"> <div class="progress-bar-wrapper"> <span>${completedCount} de ${item.subtasks.length}</span> <div class="progress-bar"> <div class="progress-bar-fill" style="width: ${progressPercent}%;"></div> </div> </div> <div class="subtasks-list-view">${subtasksListViewHtml}</div> </div>`; } const titleAndMetaHtml = ` <div style="display: flex; flex-direction: column; align-items: flex-start; width: 100%;"> <div class="item-title" data-action="edit-item">${item.description}</div> <div class="item-metadata-container" style="margin-top: 4px;"> <span class="material-icons event-meta-icon aidanai-only-icon" title="Guardado en tu cuenta de aiDANaI">cloud_done</span> </div> </div> `; itemEl.innerHTML = ` <div class="item-card-swipe-background"><span class="material-icons">check_circle</span><span class="material-icons">delete</span></div> <div class="item-icon item-checkbox" data-action="complete-item"> <span class="material-icons">${item.isComplete ? 'check_circle' : 'radio_button_unchecked'}</span> </div> <div class="item-content"> ${titleAndMetaHtml} ${progressHtml} </div>`; attachSwipeListeners(itemEl); return itemEl; }
function attachGlobalEventListeners() { const safeAddListener = (id, event, handler) => { const el = gebi(id); if (el) el.addEventListener(event, handler); }; document.body.addEventListener('click', e => { const actionTarget = e.target.closest('[data-action]'); if (actionTarget) { const action = actionTarget.dataset.action; triggerHapticFeedback('light'); if (action === 'edit-item') { const itemId = actionTarget.closest('.list-item-swipe-container').dataset.id; const item = db.items.find(i => i.localId === itemId); if (item) openAddItemModal(item); } if (action === 'complete-item') { const itemId = actionTarget.closest('.list-item-swipe-container').dataset.id; const item = db.items.find(i => i.localId === itemId); if (item) { triggerHapticFeedback('success'); handleItemComplete(itemId, !item.isComplete); } } if (action === 'toggle-subtask') { const taskId = actionTarget.dataset.taskId; const subtaskId = actionTarget.dataset.subtaskId; if (taskId && subtaskId) { triggerHapticFeedback('success'); handleSubtaskToggle(taskId, subtaskId); } } if (action === 'forgot-password') { e.preventDefault(); showToast('La función para recuperar contraseña no está implementada.', false); } if (action === 'logout') { showCustomConfirm("¿Seguro que quieres cerrar sesión?", () => signOut(fbAuth)); } if (action === 'quick-add') openModal('quick-add-modal'); if (action === 'selectDate') { const dateStr = actionTarget.dataset.date; selectDate(dateStr); } } }); qsa('.nav-item[data-view]').forEach(item => item.addEventListener('click', () => switchView(item.dataset.view))); safeAddListener('nav-theme-btn', 'click', handleThemeToggle); safeAddListener('google-sync-btn', 'click', handleGoogleAuthClick); safeAddListener('prev-nav-btn', 'click', () => { appState.calendar.displayMode === 'month' ? changeMonth(-1) : changeWeek(-1); }); safeAddListener('next-nav-btn', 'click', () => { appState.calendar.displayMode === 'month' ? changeMonth(1) : changeWeek(1); }); safeAddListener('today-btn', 'click', goToToday); safeAddListener('calendar-title-btn', 'click', openDatePickerModal); safeAddListener('month-view-btn', 'click', () => setCalendarDisplayMode('month')); safeAddListener('week-view-btn', 'click', () => setCalendarDisplayMode('week')); safeAddListener('fab-add-item', 'click', () => { triggerHapticFeedback('medium'); openModal('quick-add-modal'); }); safeAddListener('quick-add-input', 'input', debounce(handleQuickAddInput)); safeAddListener('quick-add-form', 'submit', handleQuickAddSubmit); safeAddListener('cancel-quick-add-btn', 'click', () => closeModal('quick-add-modal')); safeAddListener('open-advanced-editor-btn', 'click', openAdvancedFromQuickAdd); safeAddListener('add-item-form', 'submit', handleItemFormSubmit); safeAddListener('cancel-item-btn', 'click', () => closeModal('add-item-modal')); safeAddListener('item-type', 'change', toggleModalOptionsVisibility); safeAddListener('item-notification-enabled', 'change', toggleModalOptionsVisibility); safeAddListener('delete-item-btn', 'click', handleDeleteFromModal); safeAddListener('date-picker-form', 'submit', handleDateSelectionFromPicker); safeAddListener('cancel-date-picker-btn', 'click', () => closeModal('date-picker-modal')); safeAddListener('search-toggle-btn', 'click', toggleSearchBar); safeAddListener('search-form', 'submit', handleSearchSubmit); safeAddListener('task-list-filter', 'change', handleTaskListFilterChange); safeAddListener('manage-lists-btn', 'click', openManageListsModal); safeAddListener('close-manage-lists-btn', 'click', () => closeModal('manage-lists-modal')); safeAddListener('add-list-form', 'submit', handleAddTaskList); safeAddListener('add-subtask-btn', 'click', handleAddSubtask); safeAddListener('new-subtask-input', 'keydown', e => { if (e.key === 'Enter') { e.preventDefault(); handleAddSubtask(); } }); safeAddListener('login-form', 'submit', (e) => { e.preventDefault(); handleLogin(gebi('login-submit-btn')); }); safeAddListener('register-btn', 'click', (e) => { e.preventDefault(); handleRegister(gebi('register-btn')); }); window.addEventListener('online', updateSyncStatus); window.addEventListener('offline', updateSyncStatus); safeAddListener('item-all-day', 'change', toggleModalOptionsVisibility); }
function handleQuickAddInput(e) { const text = e.target.value; const feedbackContainer = gebi('quick-add-feedback'); if (!text.trim()) { feedbackContainer.innerHTML = ''; return; } const parsedData = parseNaturalLanguage(text); let feedbackHtml = ''; if (parsedData.type === 'agenda') { const formattedDate = formatDateForFeedback(parsedData.dueDate); feedbackHtml = `<div class="feedback-chip type-agenda"><span class="material-icons">event</span><span>Evento: ${formattedDate}</span></div>`; } else { feedbackHtml = `<div class="feedback-chip type-task"><span class="material-icons">task_alt</span><span>Tarea</span></div>`; } feedbackContainer.innerHTML = feedbackHtml; }
function formatDateForFeedback(isoDate) { if (!isoDate) return ''; const date = new Date(isoDate); const now = new Date(); const tomorrow = new Date(); tomorrow.setDate(now.getDate() + 1); let datePart; if (date.toDateString() === now.toDateString()) { datePart = 'Hoy'; } else if (date.toDateString() === tomorrow.toDateString()) { datePart = 'Mañana'; } else { datePart = date.toLocaleDateString('es-ES', { weekday: 'short', month: 'short', day: 'numeric' }); } const timePart = date.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', hour12: false }); return timePart !== '00:00' ? `${datePart}, ${timePart}` : datePart; }
function switchView(view, isInitial = false) { if (!view || view === appState.currentView || isViewSwitching) return; if (view === 'help') renderThemeSelector(); if (view === 'search') { appState.lastView = appState.currentView; } isViewSwitching = true; const oldViewName = appState.currentView; const newViewName = view; appState.currentView = newViewName; const oldViewEl = gebi(`${oldViewName}View`); const newViewEl = gebi(`${newViewName}View`); if (!newViewEl) { isViewSwitching = false; return; } renderApp(); if (isInitial || !oldViewEl) { newViewEl.classList.add('active'); isViewSwitching = false; return; } const oldViewIndex = VIEW_ORDER.indexOf(oldViewName); const newViewIndex = VIEW_ORDER.indexOf(newViewName); let enterClass, exitClass; if (newViewIndex > oldViewIndex) { enterClass = 'view-enter-from-right'; exitClass = 'view-exit-to-left'; } else { enterClass = 'view-enter-from-left'; exitClass = 'view-exit-to-right'; } if (newViewIndex === -1 || oldViewIndex === -1) { newViewEl.classList.add('active'); oldViewEl.classList.remove('active'); isViewSwitching = false; return; } newViewEl.classList.add(enterClass, 'active', 'is-animating'); oldViewEl.classList.add(exitClass, 'is-animating'); newViewEl.addEventListener('animationend', () => { oldViewEl.classList.remove('active', 'is-animating', exitClass); newViewEl.classList.remove(enterClass, 'is-animating'); isViewSwitching = false; }, { once: true }); }
function selectDate(dateStr) { appState.calendar.selectedDate = dateStr; renderApp(); }
function changeMonth(delta) { const d = new Date(appState.calendar.currentYear, appState.calendar.currentMonth, 1); d.setMonth(d.getMonth() + delta); appState.calendar.currentMonth = d.getMonth(); appState.calendar.currentYear = d.getFullYear(); renderApp(); }
function changeWeek(delta) { const d = yyyymmddToDate(appState.calendar.selectedDate); d.setDate(d.getDate() + (delta * 7)); appState.calendar.selectedDate = dateToYYYYMMDD(d); appState.calendar.currentMonth = d.getMonth(); appState.calendar.currentYear = d.getFullYear(); renderApp(); }
function goToToday() { const today = new Date(); appState.calendar = { ...appState.calendar, currentMonth: today.getMonth(), currentYear: today.getFullYear(), selectedDate: dateToYYYYMMDD(today), displayMode: 'month' }; if (appState.currentView === 'calendar') { renderApp(); } else { switchView('calendar'); } }
function setCalendarDisplayMode(mode) { if (appState.calendar.displayMode === mode) return; appState.calendar.displayMode = mode; renderApp(); }
function openModal(modalId) { gebi(modalId)?.classList.add('active'); if (modalId === 'quick-add-modal') { const input = gebi('quick-add-input'); input.value = ''; setTimeout(() => input.focus(), 100); } }
function closeModal(modalId) { gebi(modalId)?.classList.remove('active'); }
function openAddItemModal(itemToEdit = null) { const form = gebi('add-item-form'); form.reset(); closeModal('quick-add-modal'); gebi('delete-item-btn').style.display = itemToEdit ? 'block' : 'none'; const localId = itemToEdit?.localId || uuid(); gebi('item-local-id').value = localId; const itemData = itemToEdit || parseNaturalLanguage(gebi('quick-add-input').value); const defaultType = appState.currentView === 'tasks' ? 'task' : 'agenda'; gebi('item-type').value = itemData?.type || defaultType; gebi('item-description').value = itemData?.description || ''; const taskListSelect = gebi('item-task-list'); taskListSelect.innerHTML = db.taskLists.map(list => `<option value="${list.id}">${list.name}</option>`).join(''); taskListSelect.value = itemData?.listId || appState.tasks.selectedListId; renderSubtasksInModal(itemData?.subtasks || []); const dateToShow = itemData?.dueDate ? new Date(itemData.dueDate) : yyyymmddToDate(appState.calendar.selectedDate); flatpickrInstance.setDate(dateToShow, false); gebi('item-all-day').checked = itemData?.isAllDay || false; gebi('item-important').checked = itemData?.isImportant || false; gebi('item-notification-enabled').checked = itemData?.notificationEnabled || false; gebi('item-recurrence').value = itemData?.recurrenceRule || 'none'; gebi('item-reminder').value = itemData?.reminderMinutes || '0'; toggleModalOptionsVisibility(); openModal('add-item-modal'); gebi('item-description').focus(); }
function toggleModalOptionsVisibility() { const isAgenda = gebi('item-type').value === 'agenda'; const isAllDay = gebi('item-all-day').checked; const isNotificationEnabled = gebi('item-notification-enabled').checked && !isAllDay; gebi('datetime-notification-group').style.display = isAgenda ? 'block' : 'none'; gebi('task-options-group').style.display = isAgenda ? 'none' : 'block'; flatpickrInstance.set('enableTime', !isAllDay); gebi('item-notification-enabled').disabled = isAllDay; if (isAllDay) { gebi('item-notification-enabled').checked = false; } gebi('reminder-time-group').style.display = (isAgenda && isNotificationEnabled) ? 'block' : 'none'; }
async function handleItemFormSubmit(e) { e.preventDefault(); if (isSyncingWithGoogle) { showToast("Sincronización en curso, por favor espera.", true); return; } const localId = gebi('item-local-id').value; const existingItem = db.items.find(i => i.localId === localId); const subtasks = Array.from(qsa('#subtasks-container .subtask-item')).map(el => ({ id: el.dataset.id, description: el.querySelector('input[type="text"]').value, isComplete: el.querySelector('input[type="checkbox"]').checked })); let itemData = { localId, type: gebi('item-type').value, description: gebi('item-description').value.trim(), isComplete: existingItem?.isComplete || false, createdAt: existingItem?.createdAt || Date.now(), updatedAt: Date.now(), isAllDay: gebi('item-type').value === 'agenda' ? gebi('item-all-day').checked : false, isImportant: gebi('item-type').value === 'agenda' ? gebi('item-important').checked : false, notificationEnabled: gebi('item-type').value === 'agenda' ? gebi('item-notification-enabled').checked : false, reminderMinutes: gebi('item-type').value === 'agenda' && gebi('item-notification-enabled').checked ? parseInt(gebi('item-reminder').value, 10) : 0, notificationShown: (existingItem && existingItem.dueDate === flatpickrInstance.selectedDates[0]?.toISOString()) ? existingItem.notificationShown : false, recurrenceRule: gebi('item-type').value === 'agenda' ? gebi('item-recurrence').value : 'none', dueDate: gebi('item-type').value === 'agenda' ? flatpickrInstance.selectedDates[0]?.toISOString() : null, listId: gebi('item-type').value === 'task' ? gebi('item-task-list').value : null, subtasks: gebi('item-type').value === 'task' ? subtasks : [], googleCalendarEventId: existingItem?.googleCalendarEventId || null, parentId: existingItem?.parentId || null, isDeleted: false }; if (itemData.description.trim() === "") { showToast("La descripción no puede estar vacía.", true); return; } if (itemData.notificationEnabled) requestNotificationPermission(); const isNewItem = !existingItem; handleItemSave(itemData, isNewItem); closeModal('add-item-modal'); if (isGoogleSignedIn && itemData.type === 'agenda') { syncWithGoogleCalendar(); } }
function handleItemSave(itemData, isNewItem = false) { triggerHapticFeedback('medium'); const index = db.items.findIndex(i => i.localId === itemData.localId); if (index > -1) { db.items[index] = { ...db.items[index], ...itemData }; } else { db.items.unshift(itemData); } if (isNewItem) { newlyCreatedItemId = itemData.localId; } handlePostSaveNavigation(itemData); saveDataAndSchedule(); }
function handlePostSaveNavigation(itemData) { if (!itemData) { renderApp(); return; } if (itemData.type === 'agenda' && itemData.dueDate) { const itemDate = new Date(itemData.dueDate); appState.calendar.selectedDate = dateToYYYYMMDD(itemDate); appState.calendar.currentMonth = itemDate.getMonth(); appState.calendar.currentYear = itemDate.getFullYear(); if (appState.currentView !== 'calendar') { switchView('calendar'); } else { renderApp(); } } else if (itemData.type === 'task') { appState.tasks.selectedListId = itemData.listId || 'default'; if (appState.currentView !== 'tasks') { switchView('tasks'); } else { renderApp(); } } else { renderApp(); } }
async function handleItemComplete(localId, isComplete) { if (isSyncingWithGoogle) { showToast("Sincronización en curso, por favor espera.", true); return; } const itemIndex = db.items.findIndex(i => i.localId === localId); if (itemIndex === -1) return; const item = { ...db.items[itemIndex] }; try { if (isComplete) { if (isGoogleSignedIn && item.googleCalendarEventId && item.type === 'agenda') { await borrarEventoEnGoogle(item); } showToast(`"${item.description}" completado.`); const updatedItem = { ...item, isComplete: true, completedAt: Date.now(), updatedAt: Date.now() }; if (updatedItem.type === 'task' && updatedItem.subtasks) { updatedItem.subtasks.forEach(st => st.isComplete = true); } db.items[itemIndex] = updatedItem; if (item.type === 'agenda' && item.recurrenceRule !== 'none') { const nextDueDate = calculateNextDueDate(new Date(item.dueDate), item.recurrenceRule); if (nextDueDate) { const nextEvent = { ...item, localId: uuid(), dueDate: nextDueDate.toISOString(), isComplete: false, completedAt: null, notificationShown: false, createdAt: Date.now(), updatedAt: Date.now(), googleCalendarEventId: null, parentId: item.localId }; delete nextEvent.googleCalendarEventId; db.items.unshift(nextEvent); showToast(`Evento reprogramado para la próxima ocurrencia.`); } } } else { if (item.recurrenceRule !== 'none') { const childItemIndex = db.items.findIndex(i => i.parentId === localId); if (childItemIndex > -1) { db.items.splice(childItemIndex, 1); } } const updatedItem = { ...item, isComplete: false, completedAt: null, updatedAt: Date.now() }; db.items[itemIndex] = updatedItem; } renderApp(); saveDataAndSchedule(); if (isGoogleSignedIn && item.type === 'agenda') { syncWithGoogleCalendar(); } } catch (error) { showToast("Error al sincronizar con Google. La operación local se ha completado.", true); console.error("Error in handleItemComplete:", error); renderApp(); } }
async function handleDeleteItem(localId) { triggerHapticFeedback('medium'); const itemEl = document.querySelector(`.list-item-swipe-container[data-id="${localId}"]`); const index = db.items.findIndex(i => i.localId === localId); if (index === -1) return; const itemToDelete = db.items[index]; const performDelete = () => { if (itemToDelete.type === 'agenda' && itemToDelete.googleCalendarEventId && isGoogleSignedIn) { console.log('Soft deleting item for Google Sync:', itemToDelete.description); itemToDelete.isDeleted = true; itemToDelete.updatedAt = Date.now(); syncWithGoogleCalendar(); } else { db.items.splice(index, 1); } saveDataAndSchedule(); if (!itemEl) { renderApp(); } }; if (itemEl) { itemEl.classList.add('item-exiting'); itemEl.addEventListener('animationend', () => { if (!itemToDelete.isDeleted) { renderApp(); } }, { once: true }); } performDelete(); }
function saveDataAndSchedule() { scheduleAllNotifications(); saveData().catch(error => { showToast(`Error al sincronizar con Firebase.`, true); renderApp(); }); }
function handleDeleteFromModal() { const localId = gebi('item-local-id').value; const item = db.items.find(i => i.localId === localId); if (item) { showCustomConfirm(`¿Eliminar este ítem permanentemente: "${item.description}"?`, () => { closeModal('add-item-modal'); handleDeleteItem(localId); }); } }
function calculateNextDueDate(currentDueDate, recurrenceRule) { const nextDate = new Date(currentDueDate); switch (recurrenceRule) { case 'daily': nextDate.setDate(nextDate.getDate() + 1); break; case 'weekly': nextDate.setDate(nextDate.getDate() + 7); break; case 'monthly': nextDate.setMonth(nextDate.getMonth() + 1); break; case 'yearly': nextDate.setFullYear(nextDate.getFullYear() + 1); break; default: return null; } return nextDate; }
async function handleQuickAddSubmit(e) { e.preventDefault(); const input = gebi('quick-add-input').value.trim(); if (!input) return; let parsedData = parseNaturalLanguage(input); let itemToSave = { ...parsedData, localId: uuid(), isComplete: false, createdAt: Date.now(), updatedAt: Date.now(), listId: parsedData.type === 'task' ? appState.tasks.selectedListId : null, isDeleted: false }; handleItemSave(itemToSave, true); closeModal('quick-add-modal'); if (isGoogleSignedIn && itemToSave.type === 'agenda') { syncWithGoogleCalendar(); } }
function openAdvancedFromQuickAdd() { const itemToEdit = parseNaturalLanguage(gebi('quick-add-input').value); openAddItemModal(itemToEdit); }
function parseNaturalLanguage(text) { let cleanText = text.toLowerCase(); let date = new Date(); let dateFound = false; let isAllDay = true; const timeRegex = /(?:a las|a la|)\s*(\d{1,2})(?::(\d{2}))?\s*(am|pm|de la mañana|de la tarde|de la noche)?/i; const timeMatch = cleanText.match(timeRegex); if (timeMatch) { isAllDay = false; let hour = parseInt(timeMatch[1], 10); const minute = parseInt(timeMatch[2], 10) || 0; const period = timeMatch[3] ? timeMatch[3].toLowerCase() : ''; if ((period.includes('pm') || period.includes('tarde') || period.includes('noche')) && hour < 12) { hour += 12; } if ((period.includes('am') || period.includes('mañana')) && hour === 12) { hour = 0; } date.setHours(hour, minute, 0, 0); cleanText = cleanText.replace(timeMatch[0], '').trim(); dateFound = true; } else { date.setHours(0,0,0,0); } const numericDateRegex = /\b(\d{1,2})\/(\d{1,2})(?:\/(\d{2,4}))?\b/; const numericDateMatch = cleanText.match(numericDateRegex); if (numericDateMatch) { const day = parseInt(numericDateMatch[1], 10); const month = parseInt(numericDateMatch[2], 10) - 1; let year = numericDateMatch[3] ? parseInt(numericDateMatch[3], 10) : new Date().getFullYear(); if (year < 100) { year += 2000; } date.setFullYear(year, month, day); dateFound = true; cleanText = cleanText.replace(numericDateMatch[0], '').trim(); } else { const dateRegex = /(\d{1,2})(?:\s+de\s+|\s*\/\s*)(\w+)/i; const dateRegexExec = dateRegex.exec(cleanText); if (dateRegexExec) { const day = parseInt(dateRegexExec[1], 10); const monthStr = dateRegexExec[2].toLowerCase(); const monthIndex = MESES.findIndex(m => m.toLowerCase().startsWith(monthStr)); if (monthIndex > -1) { date.setMonth(monthIndex, day); dateFound = true; cleanText = cleanText.replace(dateRegexExec[0], '').trim(); } } else if (/\bhoy\b/i.test(cleanText)) { dateFound = true; cleanText = cleanText.replace(/\bhoy\b/i, '').trim(); } else if (/\bmañana\b/i.test(cleanText)) { date.setDate(date.getDate() + 1); dateFound = true; cleanText = cleanText.replace(/\bmañana\b/i, '').trim(); } else { for (let i = 0; i < DIAS_SEMANA_LARGOS.length; i++) { const dayName = DIAS_SEMANA_LARGOS[i]; if (cleanText.includes(dayName)) { const currentDay = (new Date().getDay() + 6) % 7; const targetDay = i; let dayDiff = targetDay - currentDay; if (dayDiff <= 0) dayDiff += 7; date.setDate(date.getDate() + dayDiff); dateFound = true; cleanText = cleanText.replace(new RegExp(`\\b(el\\s+)?${dayName}\\b`, 'i'), '').trim(); break; } } } } const description = cleanText.charAt(0).toUpperCase() + cleanText.slice(1); return { type: dateFound ? 'agenda' : 'task', description: description.replace(/,$/, '').trim(), dueDate: dateFound ? date.toISOString() : null, isAllDay: dateFound ? isAllDay : false }; }
function handleTaskListFilterChange(e) { appState.tasks.selectedListId = e.target.value; renderTaskListView(); }
function openManageListsModal() { const editor = gebi('task-lists-editor'); editor.innerHTML = ''; db.taskLists.forEach(list => { const el = document.createElement('div'); el.style.cssText = 'display:flex; align-items:center; gap:8px; margin-bottom:8px;'; const input = document.createElement('input'); input.type = 'text'; input.value = list.name; input.className = 'form-input'; input.onchange = () => handleRenameTaskList(list.id, input.value); if(list.id === 'default') input.disabled = true; el.appendChild(input); if (list.id !== 'default') { const deleteBtn = document.createElement('button'); deleteBtn.className = 'icon-button'; deleteBtn.innerHTML = '<span class="material-icons">delete</span>'; deleteBtn.onclick = () => handleDeleteTaskList(list.id); el.appendChild(deleteBtn); } editor.appendChild(el); }); openModal('manage-lists-modal'); }
function handleAddTaskList(e) { e.preventDefault(); const input = gebi('new-list-name'); const name = input.value.trim(); if (name) { const newList = { id: uuid(), name }; db.taskLists.push(newList); saveData().then(() => { input.value = ''; openManageListsModal(); renderTaskListView(); }).catch(err => showToast("Error al añadir lista", true)); } }
function handleRenameTaskList(id, newName) { const list = db.taskLists.find(l => l.id === id); if (list && newName) { list.name = newName; saveData().then(() => { openManageListsModal(); renderTaskListView(); }).catch(err => showToast("Error al renombrar lista", true)); } }
function handleDeleteTaskList(id) { const listName = db.taskLists.find(l => l.id === id)?.name; showCustomConfirm(`¿Seguro que quieres eliminar la lista "${listName}" y TODAS sus tareas? Esta acción es irreversible.`, () => { db.taskLists = db.taskLists.filter(l => l.id !== id); db.items = db.items.filter(i => i.listId !== id); if (appState.tasks.selectedListId === id) { appState.tasks.selectedListId = 'default'; } saveData().then(() => { openManageListsModal(); renderTaskListView(); }).catch(err => showToast("Error al eliminar la lista.", true)); }); }
function renderSubtasksInModal(subtasks = []) { const container = gebi('subtasks-container'); container.innerHTML = ''; subtasks.forEach(subtask => { const el = document.createElement('div'); el.className = 'subtask-item'; el.dataset.id = subtask.id; el.innerHTML = ` <input type="checkbox" ${subtask.isComplete ? 'checked' : ''}> <input type="text" value="${subtask.description}"> <button type="button" class="icon-button delete-subtask-btn"><span class="material-icons">close</span></button> `; el.querySelector('.delete-subtask-btn').onclick = () => { el.remove(); }; container.appendChild(el); }); }
function handleAddSubtask() { const input = gebi('new-subtask-input'); const description = input.value.trim(); if (description) { const container = gebi('subtasks-container'); const el = document.createElement('div'); el.className = 'subtask-item'; el.dataset.id = uuid(); el.innerHTML = ` <input type="checkbox"> <input type="text" value="${description}"> <button type="button" class="icon-button delete-subtask-btn"><span class="material-icons">close</span></button> `; el.querySelector('.delete-subtask-btn').onclick = () => { el.remove(); }; container.appendChild(el); input.value = ''; input.focus(); } }
function handleSubtaskToggle(taskId, subtaskId) { const taskIndex = db.items.findIndex(i => i.localId === taskId); if (taskIndex === -1) return; const updatedTask = JSON.parse(JSON.stringify(db.items[taskIndex])); const subtaskIndex = updatedTask.subtasks.findIndex(st => st.id === subtaskId); if (subtaskIndex === -1) return; updatedTask.subtasks[subtaskIndex].isComplete = !updatedTask.subtasks[subtaskIndex].isComplete; const allSubtasksComplete = updatedTask.subtasks.every(st => st.isComplete); updatedTask.isComplete = allSubtasksComplete; if (allSubtasksComplete) { if (!updatedTask.completedAt) updatedTask.completedAt = Date.now(); } else { updatedTask.completedAt = null; } updatedTask.updatedAt = Date.now(); db.items[taskIndex] = updatedTask; renderApp(); saveData().catch(error => { showToast('Error al actualizar la subtarea.', true); renderApp(); }); }

window.onDriverJsLoaded = function() {
    console.log("Driver.js ha cargado exitosamente.");
    isTutorialReady = true;
    if (isAppInitialized && !db.config.tutorialCompleted) {
        startOnboardingTutorial();
    }
}

function startOnboardingTutorial() { if (typeof driver !== 'function') { console.error("Se intentó iniciar el tutorial, pero Driver.js no está disponible."); return; } const driverObj = driver.driver({ showProgress: true, steps: [ { element: '#today-greeting', popover: { title: '¡Bienvenido/a a Agenda aiDANaI!', description: 'Este es tu centro de mando. Permítenos mostrarte rápidamente cómo funciona.' } }, { element: '#fab-add-item', popover: { title: 'Creación Rápida con IA', description: 'Usa este botón para añadir eventos y tareas usando lenguaje natural, como "Cena con amigos mañana a las 9". ¡La IA se encarga del resto!' } }, { element: '#todayView', popover: { title: 'Gestos que Ahorran Tiempo', description: 'En cualquier lista, desliza un ítem a la DERECHA para completarlo, y a la IZQUIERDA para eliminarlo. ¡Así de fácil!' } }, { element: '.bottom-nav', popover: { title: 'Navega por tu Agenda', description: 'Usa estos botones para cambiar entre la vista de Hoy, la Agenda completa, tus listas de Tareas y más.', side: "top", align: 'start' } } ], onDestroyStarted: async () => { if (!driverObj.isActivated()) { db.config.tutorialCompleted = true; try { await saveData(); } catch (err) { showToast("Error al guardar el estado del tutorial.", true); } } } }); driverObj.drive(); }

function initializeDatePicker() { flatpickr.localize(flatpickr.l10ns.es); flatpickrInstance = flatpickr("#item-datetime", { enableTime: true, dateFormat: "Y-m-d H:i", time_24hr: true, minuteIncrement: 15 }); }
function openDatePickerModal() { openModal('date-picker-modal'); const monthSelect = gebi('month-select'); monthSelect.innerHTML = MESES.map((mes, i) => `<option value="${i}">${mes}</option>`).join(''); monthSelect.value = appState.calendar.currentMonth; gebi('year-select').value = appState.calendar.currentYear; }
function handleDateSelectionFromPicker(e) { e.preventDefault(); appState.calendar.currentMonth = parseInt(gebi('month-select').value, 10); appState.calendar.currentYear = parseInt(gebi('year-select').value, 10); appState.calendar.selectedDate = dateToYYYYMMDD(new Date(appState.calendar.currentYear, appState.calendar.currentMonth, 1)); appState.calendar.displayMode = 'month'; switchView('calendar'); closeModal('date-picker-modal'); }
function toggleSearchBar() { const searchContainer = gebi('search-container'); const isActive = searchContainer.classList.toggle('active'); if (isActive) { gebi('search-input').focus(); if (appState.currentView !== 'search') appState.lastView = appState.currentView; } else { gebi('search-input').value = ''; executeSearch(''); } }
function handleSearchSubmit(event) { event.preventDefault(); executeSearch(gebi('search-input').value); }
function executeSearch(query) { if (query.trim() !== '') { switchView('search'); } else { if (appState.currentView === 'search') { switchView(appState.lastView || 'today'); } } }
function attachSwipeListeners(cardEl) { if (!cardEl || cardEl.dataset.hammer) return; cardEl.dataset.hammer = 'true'; const mc = new Hammer.Manager(cardEl); mc.add(new Hammer.Pan({ threshold: 10, pointers: 1 })); mc.on('panstart', () => { cardEl.style.transition = 'none'; }); mc.on('pan', e => { if (e.target.closest('.subtasks-list-view')) { cardEl.style.transform = 'translateX(0)'; return; } cardEl.style.transform = `translateX(${e.deltaX}px)`; if (e.deltaX > 20) cardEl.classList.add('swiping-right'); else if (e.deltaX < -20) cardEl.classList.add('swiping-left'); else cardEl.classList.remove('swiping-right', 'swiping-left'); }); mc.on('panend', e => { cardEl.style.transition = 'transform 0.3s var(--ease-out-quint)'; const threshold = cardEl.offsetWidth * 0.35; const id = cardEl.dataset.id; const item = db.items.find(i => i.localId === id); if (!item) { cardEl.style.transform = 'translateX(0)'; return; } if (e.deltaX > threshold) { triggerHapticFeedback('success'); handleItemComplete(id, true); cardEl.style.transform = 'translateX(0)'; } else if (e.deltaX < -threshold) { showCustomConfirm(`¿Eliminar "${item.description}"?`, () => { handleDeleteItem(id); }, () => { cardEl.style.transform = 'translateX(0)'; }); } else { cardEl.style.transform = 'translateX(0)'; } setTimeout(() => { cardEl.classList.remove('swiping-right', 'swiping-left'); }, 300); }); }
function showCustomConfirm(message, onConfirm, onCancel) { const modalId = 'custom-confirm-modal'; gebi('confirm-message').textContent = message; const confirmOkBtn = gebi('confirm-ok-btn'); const confirmCancelBtn = gebi('confirm-cancel-btn'); confirmOkBtn.onclick = null; confirmCancelBtn.onclick = null; const newConfirmOkHandler = () => { onConfirm(); closeModal(modalId); }; const newConfirmCancelHandler = () => { if (onCancel) onCancel(); closeModal(modalId); }; confirmOkBtn.onclick = newConfirmOkHandler; confirmCancelBtn.onclick = newConfirmCancelHandler; openModal(modalId); }
function updateSyncStatus() { const indicator = gebi('sync-status-indicator'); if (!indicator) return; const icon = indicator.querySelector('.material-icons') || document.createElement('span'); icon.classList.add('material-icons'); const isOnline = navigator.onLine; if (isOnline) { indicator.className = 'online'; icon.textContent = 'cloud_done'; indicator.title = "Conectado y sincronizado."; } else { indicator.className = 'offline'; icon.textContent = 'cloud_off'; indicator.title = "Sin conexión. Los cambios se guardarán localmente."; } if (!indicator.hasChildNodes()) { indicator.appendChild(icon); } }
async function requestNotificationPermission() { if (!("Notification" in window)) { showToast("Este navegador no soporta notificaciones.", true); return 'denied'; } const permission = await Notification.requestPermission(); if (permission === 'granted') { showToast("¡Permiso de notificaciones concedido!"); } else { showToast("Permiso de notificaciones denegado.", true); } return permission; }
function showNotification(item) { if (Notification.permission !== "granted") return; const body = `Tu evento "${item.description}" es ahora.`; new Notification('Recordatorio de Agenda', { body: body, icon: './aiDANaI.webp', badge: './aiDANaI.webp' }); const index = db.items.findIndex(x => x.localId === item.localId); if (index > -1) { db.items[index].notificationShown = true; saveData().catch(err => showToast("Error al guardar estado de notificación", true)); } }
function scheduleNotification(item) { if (activeTimers[item.localId]) { clearTimeout(activeTimers[item.localId]); } if (!item.notificationEnabled || item.isComplete || !item.dueDate || item.notificationShown) { return; } const reminderOffsetMs = (parseInt(item.reminderMinutes, 10) || 0) * 60 * 1000; const notificationTimeMs = new Date(item.dueDate).getTime() - reminderOffsetMs; const delay = notificationTimeMs - Date.now(); if (delay > 0) { activeTimers[item.localId] = setTimeout(() => { showNotification(item); delete activeTimers[item.localId]; }, delay); } }
function scheduleAllNotifications() { if (!db.items) return; Object.values(activeTimers).forEach(clearTimeout); activeTimers = {}; db.items.forEach(scheduleNotification); }

// --- SECCIÓN DE GOOGLE CALENDAR (VERSIÓN ACTUALIZADA CON BACKGROUND SYNC) ---
let gapiIniciado = false;
let gisIniciado = false;
let tokenClient;

function loadGisScript() { const script = document.createElement('script'); script.src = 'https://accounts.google.com/gsi/client'; script.async = true; script.defer = true; script.onload = initializeGisClient; document.body.appendChild(script); }
function loadGapiScript() { const script = document.createElement('script'); script.src = 'https://apis.google.com/js/api.js'; script.async = true; script.defer = true; script.onload = initializeGapiClient; document.body.appendChild(script); }
function initializeGapiClient() { gapi.load('client', () => { gapi.client.init({ apiKey: GOOGLE_API_KEY, discoveryDocs: GOOGLE_DISCOVERY_DOCS, }).then(() => { gapiIniciado = true; checkReadyStateAndEnableButton(); }).catch(error => { console.error("Error initializing GAPI client:", error); showToast("No se pudo iniciar la API de Google Calendar.", true); }); }); }
function initializeGisClient() { tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_SCOPES, callback: async (tokenResponse) => { if (tokenResponse && tokenResponse.access_token) { gapi.client.setToken(tokenResponse); isGoogleSignedIn = true; updateGoogleSigninStatus(true); await syncWithGoogleCalendar(); } else { console.error("Respuesta de token inválida:", tokenResponse); showToast("Fallo al obtener el permiso de Google.", true); } }, error_callback: (error) => { console.error("Error en el flujo de autenticación:", error); showToast("Ocurrió un error al conectar con Google.", true); } }); gisIniciado = true; checkReadyStateAndEnableButton(); }
function checkReadyStateAndEnableButton() { if (gapiIniciado && gisIniciado) { const syncButton = gebi('google-sync-btn'); if (syncButton) { syncButton.disabled = false; syncButton.classList.remove('loading'); console.log("Bibliotecas de Google listas para usarse."); } } }
function handleGoogleAuthClick() { if (!gisIniciado || !gapiIniciado) { showToast("Las bibliotecas de Google aún no están listas.", true); return; } if (gapi.client.getToken() === null) { tokenClient.requestAccessToken({ prompt: 'consent' }); } else { syncWithGoogleCalendar(); } }
function updateGoogleSigninStatus(isSignedIn) { isGoogleSignedIn = isSignedIn; const syncButton = gebi('google-sync-btn'); if (isSignedIn) { syncButton.classList.add('connected'); syncButton.title = 'Conectado. Haz clic para sincronizar manualmente.'; syncButton.querySelector('.material-icons').textContent = 'cloud_done'; } else { syncButton.classList.remove('connected'); syncButton.title = 'Sincronizar con Google'; syncButton.querySelector('.material-icons').textContent = 'sync'; gapi.client.setToken(null); } }
function buildGoogleEventResource(item) { const resource = { 'summary': item.description, 'reminders': { 'useDefault': false, 'overrides': (item.notificationEnabled && !item.isAllDay) ? [{ 'method': 'popup', 'minutes': item.reminderMinutes }] : [] }, 'colorId': item.isImportant ? '11' : null }; if (item.isAllDay) { const startDate = new Date(item.dueDate); startDate.setHours(0, 0, 0, 0); const endDate = new Date(startDate); endDate.setDate(startDate.getDate() + 1); resource.start = { 'date': dateToYYYYMMDD(startDate) }; resource.end = { 'date': dateToYYYYMMDD(endDate) }; } else { const startDate = new Date(item.dueDate); const endDate = new Date(startDate.getTime() + 60 * 60 * 1000); resource.start = { 'dateTime': startDate.toISOString(), 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone }; resource.end = { 'dateTime': endDate.toISOString(), 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone }; } if (item.recurrenceRule && item.recurrenceRule !== 'none') { const recurrenceMap = { 'daily': 'DAILY', 'weekly': 'WEEKLY', 'monthly': 'MONTHLY', 'yearly': 'YEARLY' }; resource.recurrence = [`RRULE:FREQ=${recurrenceMap[item.recurrenceRule]}`]; } return resource; }
async function crearEventoEnGoogle(item) { if (!isGoogleSignedIn || item.type !== 'agenda') return null; const eventResource = buildGoogleEventResource(item); try { const response = await gapi.client.calendar.events.insert({ 'calendarId': 'primary', 'resource': eventResource }); return response.result.id; } catch (error) { console.error('Error creando evento en Google:', error); throw error; } }
async function actualizarEventoEnGoogle(item) { if (!isGoogleSignedIn || !item.googleCalendarEventId || item.type !== 'agenda') return; const eventResource = buildGoogleEventResource(item); try { await gapi.client.calendar.events.update({ 'calendarId': 'primary', 'eventId': item.googleCalendarEventId, 'resource': eventResource }); } catch (error) { console.error('Error actualizando evento en Google:', error); throw error; } }
async function borrarEventoEnGoogle(item) { if (!isGoogleSignedIn || !item.googleCalendarEventId || item.type !== 'agenda') return; try { await gapi.client.calendar.events.delete({ 'calendarId': 'primary', 'eventId': item.googleCalendarEventId }); } catch (error) { console.error('Error eliminando evento en Google:', error); if (error.result && (error.result.error.code === 404 || error.result.error.code === 410)) { console.log("El evento ya no existía en Google Calendar."); } else { throw error; } } }
function convertGoogleEventToAidanaiItem(googleEvent, existingItem = {}) { const dueDateISO = googleEvent.start?.dateTime || googleEvent.start?.date; if (!dueDateISO) return null; const isAllDay = !!googleEvent.start.date; const dueDate = new Date(dueDateISO); if (isAllDay) { dueDate.setMinutes(dueDate.getMinutes() + dueDate.getTimezoneOffset()); } return { ...existingItem, localId: existingItem.localId || uuid(), googleCalendarEventId: googleEvent.id, type: CONSTANTS.ITEM_TYPES.AGENDA, description: googleEvent.summary || 'Sin Título', dueDate: dueDate.toISOString(), isAllDay: isAllDay, isComplete: false, createdAt: existingItem.createdAt || new Date(googleEvent.created).getTime(), updatedAt: new Date(googleEvent.updated).getTime(), isImportant: googleEvent.colorId === '11', notificationEnabled: !isAllDay && googleEvent.reminders?.useDefault === false && googleEvent.reminders?.overrides?.length > 0, reminderMinutes: googleEvent.reminders?.overrides?.[0]?.minutes || 0, recurrenceRule: 'none', notificationShown: false, isDeleted: false, }; }

// NUEVO: Función para registrar la tarea de sincronización en segundo plano.
async function registerGoogleBackgroundSync() {
    if (!('serviceWorker' in navigator) || !('SyncManager' in window)) {
        showToast("Sincronización en segundo plano no soportada en este navegador.", true);
        return;
    }
    try {
        const swRegistration = await navigator.serviceWorker.ready;
        await swRegistration.sync.register('google-sync-tag');
        console.log("Tarea de sincronización en segundo plano registrada.");
        showToast("Sin conexión. Los cambios se sincronizarán con Google cuando vuelvas a estar en línea.");
    } catch (err) {
        console.error("No se pudo registrar la sincronización en segundo plano:", err);
        showToast("Error al intentar la sincronización en segundo plano.", true);
    }
}

async function syncWithGoogleCalendar(forceFullSync = false) {
    if (isSyncingWithGoogle) { showToast("Sincronización ya en curso."); return; }
    if (!isGoogleSignedIn || !currentUser) return;
    // NUEVO: Si estamos offline, no intentamos sincronizar, solo registramos la tarea.
    if (!navigator.onLine) {
        await registerGoogleBackgroundSync();
        return;
    }
    const syncButton = gebi('google-sync-btn');
    isSyncingWithGoogle = true;
    syncButton.classList.add('loading');
    showToast("Sincronizando con Google Calendar...");
    let changesMade = false;
    try {
        const itemsToDeleteLocally = db.items.filter(i => i.isDeleted && i.googleCalendarEventId);
        if (itemsToDeleteLocally.length > 0) { console.log(`Enviando ${itemsToDeleteLocally.length} eliminaciones a Google...`); for (const item of itemsToDeleteLocally) { await borrarEventoEnGoogle(item); } db.items = db.items.filter(i => !i.isDeleted); changesMade = true; }
        const itemsToCreateInGoogle = db.items.filter(i => i.type === 'agenda' && !i.googleCalendarEventId && !i.isDeleted && !i.isComplete);
        if (itemsToCreateInGoogle.length > 0) { console.log(`Subiendo ${itemsToCreateInGoogle.length} nuevos eventos locales a Google...`); for (const item of itemsToCreateInGoogle) { const newGoogleId = await crearEventoEnGoogle(item); if (newGoogleId) { item.googleCalendarEventId = newGoogleId; item.updatedAt = Date.now(); changesMade = true; } } }
        const syncToken = forceFullSync ? null : db.config.googleSyncToken;
        let request;
        if (syncToken) { console.log("Realizando sincronización incremental desde Google..."); request = gapi.client.calendar.events.list({ calendarId: 'primary', syncToken: syncToken }); } else { console.log("Realizando sincronización completa desde Google..."); const timeMin = new Date(); timeMin.setMonth(timeMin.getMonth() - 1); request = gapi.client.calendar.events.list({ calendarId: 'primary', timeMin: timeMin.toISOString(), showDeleted: true, singleEvents: true, maxResults: 2500 }); }
        const response = await request;
        const googleEvents = response.result.items;
        const localItemsByGoogleId = new Map(db.items.map(i => [i.googleCalendarEventId, i]));
        for (const googleEvent of googleEvents) {
            const localItem = localItemsByGoogleId.get(googleEvent.id);
            if (googleEvent.status === 'cancelled') { if (localItem) { const index = db.items.findIndex(i => i.localId === localItem.localId); db.items.splice(index, 1); changesMade = true; console.log(`Evento eliminado desde Google: ${localItem.description}`); } continue; }
            const googleUpdatedTime = new Date(googleEvent.updated).getTime();
            if (!localItem) { const newItem = convertGoogleEventToAidanaiItem(googleEvent); if (newItem) { db.items.unshift(newItem); changesMade = true; console.log(`Evento añadido desde Google: ${newItem.description}`); } continue; }
            if (googleUpdatedTime > localItem.updatedAt) { const updatedItem = convertGoogleEventToAidanaiItem(googleEvent, localItem); const index = db.items.findIndex(i => i.localId === localItem.localId); db.items[index] = updatedItem; changesMade = true; console.log(`Evento actualizado desde Google (remoto es más nuevo): ${updatedItem.description}`); } else if (localItem.updatedAt > googleUpdatedTime) { await actualizarEventoEnGoogle(localItem); console.log(`Evento actualizado hacia Google (local es más nuevo): ${localItem.description}`); }
        }
        const newSyncToken = response.result.nextSyncToken;
        if (newSyncToken) { db.config.googleSyncToken = newSyncToken; }
        if (changesMade) { showToast("Sincronización completada. Datos actualizados.", false); await saveData(); renderApp(); } else { showToast("Tus datos ya estaban sincronizados.", false); }
    } catch (error) {
        // NUEVO: Si falla por error de red o similar, registramos la sincronización en segundo plano.
        if (error.result && error.result.error.code === 410) { console.warn("Sync token inválido. Realizando sincronización completa."); showToast("La sesión de Google requiere una resincronización completa.", true); db.config.googleSyncToken = null; await saveData(); syncWithGoogleCalendar(true); } else {
            console.error("Error en syncWithGoogleCalendar:", error);
            await registerGoogleBackgroundSync(); // Intentar registrar en cualquier otro error de red.
        }
    } finally { isSyncingWithGoogle = false; syncButton.classList.remove('loading'); }
}

document.addEventListener('DOMContentLoaded', initApp);